[{"title":"C语言基础-下","url":"/2023/10/10/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%8B/","content":" 十二.位运算\n 2. 概念\n 1. 进制转换\n 1. 二进制转换为10进制：\n按权展开，然后求和，就可把二进制数转换成十进制数。例如：\n(101.1)2＝1×22+0×21+1×20+1×2−1＝(5.5)10(101.1)_2＝1×2^2+0×2^1+1×2^0+1×2^{-1}＝( 5.5 )_{10}\n(101.1)2​＝1×22+0×21+1×20+1×2−1＝(5.5)10​\n 2. 十进制转二进制\n十进制数有整数和小数两部分。\n在转换时，整数部分采用除2取余法\n小数部分采用乘2取整法c\n\n\n 3. 二进制转八进制\n三位并一位：以小数点为基准，整数部分从右到左，小数部分从左到右，每三位一组，不足三位添0补足，然后把每组的三位二进制数按权展开后相加，得到相应的一位八进制数码，再按权的顺序连接即得相应的八进制数。\n(1011100.00101011)2=(?)8(001,011,100.001,010,110)2=(134.126)8134.126(1011100.00101011)_2=(?)_8\\\\\n   (001,011,100.001,010,110)_2=(134.126)_8\\\\\n    1  3  4 . 1  2  6\n(1011100.00101011)2​=(?)8​(001,011,100.001,010,110)2​=(134.126)8​134.126\n 4. 八进制转二进制\n\n\\xxx表示3为八进制,\\1011超char范围（非法）\n\n一位拆三位：将每一位八进制数写成对应的三位二进制数，然后按权连接即可。\n123.67(八进制)001,010,011.110111(二进制)(123.67)8=(1010011.110111)21   2   3 . 6  7   (八进制)\\\\\n001,010,011.110111  (二进制)\\\\\n(123.67)_8=(1010011.110111)_2\n123.67(八进制)001,010,011.110111(二进制)(123.67)8​=(1010011.110111)2​\n 5. 二进制转十六进制\n四位并一位：以小数点为基准，整数部分从右到左，小数部分从左到右，每四位一组，不足四位添0补足,然后把每组的四位二进制数按权展开后相加，得到相应的一位十六进制数码，再按权的顺序连接即得相应的十六进制数。\n(1011110.00011)2=(?)16(0101,1110.0001,1000)2=(?)165E.18(1011110.00011)_2=(?)_{16}\\\\\n(0101,1110.0001,1000)_2=(?)_{16}\\\\\n5    E .  1    8\n(1011110.00011)2​=(?)16​(0101,1110.0001,1000)2​=(?)16​5E.18\n 6. 十六进制转二进制\n\n‘\\xa’ --合法，0xa 合法，\\0xa非法\n\n一位拆四位：把一位十六进制数写成对应的四位二进制数，然后按权连接即可。\n123.EF(十六进制)0001,0010,0011.1110,1111(二进制)(123.EF)16=(100100011.11101111)21  2  3 . E  F  (十六进制)\\\\\n\n0001,0010,0011.1110,1111 (二进制)\\\\\n\n(123.EF)_{16}=(100100011.11101111)_2\n123.EF(十六进制)0001,0010,0011.1110,1111(二进制)(123.EF)16​=(100100011.11101111)2​\n\n指按二进制位进行运算。\n\n＆  按位与    ~   取反\n|  按位或    &lt;&lt;   左移\n^  按位异或   &gt;&gt;   右移\n(1)位运算符中除~以外，均为二目（元）运算符，即要求两侧各有一个运算量。\n(2)运算量只能是整型或字符型的数据，不能为实型数据（浮点型）。\n 3.按位与&amp;\n含义：参加运算的两个数据，按二进制位进行“与”运算。\n如果两个相应的二进制位都为１，则该位的结果值为１；否则为０。\n例如：\n０＆０＝０，０＆１＝０，\n１＆０＝０，１＆１＝１\n\n如果参加&amp;运算的是负数（如-3&amp;-5），则要\n以补码形式表示为二进制数，然后再按位进行\n“与”运算。\n1111011的第二位是0\n 4.按位或 |\n两个相应的二进制位中只要有一个为１，该位的结果值为１。\n０|０＝０，０|１＝１，\n１|０＝１，１|１＝１\n 大小写转换\n大写写字母二进制第五位变成一1就是小写字母\n32 100000\n223  1101 1111\n255   1111 1111\n#include &lt;stdio.h>\n#include &lt;conio.h>\n\nvoid main()\n{\n      char ch, temp;\n\n      printf(\"请输入一个字母: \\n\");\n      ch = getchar();\n      temp = getchar();//吃一个回车\n\n      while( !(ch>'A' &amp;&amp; ch&lt;'z') || (ch > 'Z' &amp;&amp; ch &lt; 'a') )\n      {\n           printf(\"输入有误, 请重新输入一个字母: \\n\");\n           ch = getchar();\n      }\n      if( ch &amp; 32 )   \n      {\n            ch = ch &amp; 223;  // 使第五位为0，变大写\n      }\n      else\n      {\n            ch = ch | 32;  // 使第五位为1，变小写\n      }\n      putchar(ch);\n      printf(\"\\n\");\n}\n\n 5. 异或(XOR运算符)^\n若参加运算的两个二进制位同号则结果为0(假)，异号则结果为１(真)\n即:0^0=0，0^1=1，1^0=1， 1^1=0\n 使特定位翻转\n比如低4位翻转\n\n 与0相^，保留原值\n 交换两个值\na=a^b;\nb=b^a;\na=a^b;\n\n~是一个单目(元)运算符~，用来对一个二进制数按位取反，即将0变1,将1变0.\n","categories":["大一"],"tags":[]},{"title":"C语言基础-上","url":"/2023/10/05/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%8A/","content":" C语言基础-上\n 0基础\n下载vc6，devc，visual studio 2022。建议visual studio 2022\n 1. 简介\n\n1字节1B，1024b=1kb\n内存四大区:CODE(代码区),DATA(全局数据区),STACK(栈),HEAP(堆内存)\n一个C语言源程序是由函数组成.\nC语言本身没有输入输出语句\nC语言中的标识符只能由字母、数字和下划线三种字符组成，且第一个字符必须为字母或下划线\n\n下列可作为C语言赋值语句的是 i–;\n目标程序是指源程序经编译可直接被计算机运行的 机器码 集合。目标程序文件的扩展名为.obj\n函数一般由函数头和函数体组成\n一个函数的函数体一般包括参数和返回值\n程序是指一组计算机能识别和执行的指令\n\n\n 2. 简单快捷键\n\nctrl+s保存\nvc6\nalt+f8自动缩进\nshift+tab往前缩进\ntab往后缩进\nvisual studio 2022\nctrl+D 复制这行到下一行\n\n 3. 常见问题解决(重点)\n\n\n判断整成赋值\na==1，a=1\n\n\n忘记取地址符&amp;\n \t   scanf(&quot;%d&quot;,&amp;a);\n\n\n\n控制台按回车键，getch()会识别成\\r(13)，getchar()，scanf()会识别成\\n(10)。\n\n\nscanf(“%c”,&amp;op)吃回车键的问题\n\n\n//解决方法\nscanf(\"%d%d\",&amp;a,&amp;b);\nfflush(stdin);\nscanf(\"%c\",&amp;op);\n//或者\nscanf(\"%d%d\",&amp;a,&amp;b);\ngetchar();\nscanf(\"%c\",&amp;op);\n//或者\nscanf(\"%d%d %c\",&amp;a,&amp;b,&amp;c);\n\n\n转义输出\n\nprintf(\"\\\\  %%\");//输出\\ %\n\n\n常见运算符顺序问题\n\na++*2;//相当于a*2;a++\n\n\nswitch漏break\n\nint a=2;\nswitch(a)&#123;\n\tcase 2: printf(&quot;2 &quot;);\n\tcase 1: printf(&quot;1\\n&quot;);break;\n&#125;//2 1\n\n\n\nvisual studio 2022需要#define _CRT_SECURE_NO_WARNINGS\n\n\n数组越界。(自己看着办)\n\n\nputchar(‘\\n’);表示字符要单引号，而不是双引号\n\n\n(*pointer_1)相当于a，要打括号，因为从右往左结合\n\n\nvc6和devc会把%hhu解析成%u导致unsigned char读取时出现数据覆盖问题。\n\n\n 4. 简单输入输出\n#include &lt;stdio.h>\nint main(int argc, char *argv[]){\n    int a;\n    scanf(\"%d\",&amp;a);\n    printf(\"%d\",a);\n\treturn 0;\n}\n\n 5. 注释方法\n//这是行注释\n/*多行\n注释*/\n#if(0)//if(0)不执行其中的代码\n\tint a[3][4]={1,2,3};\n#endif\n\n 1.数据类型\n 1. 储存空间和内存四大区\n\n\n\n可以用sizeof(int)查看int类型的所占字节数\n\n\nchar&lt;int&lt;long int&lt;=float&lt;double\n\n\n\nprintf(\"%d\",sizeof(int));//4\nshort 2\nfloat 4\ndouble 8\n\n内存四大区：代码区，栈区(存放函数参数值，局部变量)，堆区（程序员分配），全局/静态区（放常量，全局变量）。\n 2. 数据类型\n以下环境为64位windows\n\n\n\n整型(默认向下取整)\n占位符\n字节\n\n\n\n\nshort\n%hd\n2\n\n\nint\n%d\n4\n\n\nlong\n%ld\n4\n\n\nlong long\n%lld\n8\n\n\n浮点型\n\n\n\n\nfloat 单精度浮点型\n%f\n4\n\n\ndouble 双精度浮点型\n%lf\n8\n\n\n字符型\n\n\n\n\nchar (内存中以ASCII码储存)\n%c\n1\n\n\n布尔型(C99以后)\n\n\n\n\nbool (需包含stdbool.h)\n%hhu\n1\n\n\n_Bool\n%hhu\n1\n\n\n常量\n\n\n\n\n\n\n除法3/2输出1，3.0/2输出1.5，(double)3/2输出1.500000\nbool可以赋值为true(1),false(0)。\n_Bool可以赋值为0或1。\n\n 整型四舍五入\nint a;\nfloat b=5.6;\na=b+0.5;\n\n 常见ascii码\n\n\n\n字符\nascii码\n\n\n\n\n0\n48\n\n\nA\n65\n\n\na\n97\n\n\n空格\n32\n\n\n.\n109\n\n\n!\n33\n\n\n\n\n\n\n\nchar c[]=\"hello world\";\nprintf(\"%s\",c);\n\n 3. 常量\n 1. 整数常量\nU 表示无符号整数（unsigned）\n0x 或 0X 表示十六进制\n0 表示八进制\nU 表示无符号整数（unsigned）\nL 表示长整数（long）\n212         /* 合法的 */\n215u        /* 合法的 */\n0xFeeL      /* 合法的 */\n078         /* 非法的：8 不是八进制的数字 */\n032UU       /* 非法的：不能重复后缀 */\n\n 2. 浮点常量\n3.14159       /* 合法的 */\n314159E-5L    /* 合法的 */\n1e-6       //表示1*(10^-6)\n    \n510E          /* 非法的：不完整的指数 */\n210f          /* 非法的：没有小数或指数 */\n.e55          /* 非法的：缺少整数或分数 */\n//e的前面不能没有数字，e的后面不能有小数。\n\n 3. 定义常量\n用define或const定义常量。\n#include&lt;stdio.h>\n#define WIDTH  5\n#define NEWLINE '\\n'\nint main()\n{\n   const int  LENGTH = 10;\n   int area;  \n   area = LENGTH * WIDTH;\n   printf(\"value of area : %d\", area);\n   printf(\"%c\", NEWLINE);\n   return 0;\n}\n\n 4. printf 格式化输出(重点)\n修饰词\n\n\n\n%hh\n限定输出格式为8位，即1个字节\n\n\n\n\n%h\n限定输出格式为16位，即2个字节\n\n\n%l\n限定输出格式为32位，即4个字节\n\n\n%ll\n限定输出格式为64位，即8个字节\n\n\n\n占位符\n空白符包括回车符\\r, 换行符 \\n, 制表符 \\t(Tab)。\n\n\n\n%g\n输出实数（f格式或e格式），系统根据数据占宽度m大小，自动选择占宽度较小的某种格式输出，不输出小数点后无意义的零，默认宽度为6。\n\n\n\n\n％d\n整型(int)输出\n\n\n％ld\n长整型(long)输出\n\n\n％s\n输出字符串(char数组)，遇’\\0’停止。输入时，遇空白字符停止。\n\n\n％c\nchar型，输出一个字符\n\n\n%p\n16进制打印指针的值\n\n\n％f\n单精度浮点型(float)，默认情况下保留小数点6位，如1.000000。\n\n\n%lf\n是双精度浮点型，默认情况下保留小数点6位，通常用来输出double型\n\n\n％e\n以指数形式输出实数\n\n\n％o\n以八进制数形式输出整数\n\n\n％x\n以十六进制数形式输出整数，或输出字符串的地址\n\n\n\n\n\n%10d右对齐，%-10d左对齐，默认空格填充，%05d有0标志用0填充。\n\n\n“%”与字母之间可以插入数字表示场宽，如%2d表示输出2位整型数，不够2位右对齐\n\n\n%.2f用来输出小数，保留两位小数，如1.00\n\n\n%g,%e,%f都会在精度的下一位四舍五入\n\n\n%g默认保留六位有效数字输出\n\n\nscanf(“%s”,s);这里不能有&amp;符号。\n\n\n%m.ns。输出占m列，但只取字符串中的左端n个字符，这n个字符输入输出在m列的右则，左则补空格。\n-%m.ns。n个字符输出在m列的左侧，右侧补空格。\n\n\n注意：%d与%u有无符号的数值范围，也就是极限的值，不然数值打印出来会有误\n#include &lt;stdio.h>\nint main(){\n    printf(\"%3s,%7.2s,%.4s,%-5.3s\\n\",\"china\",\"china\",\"china\",\"china\");\n    printf(\"%g,%g,%g\\n\",9.555555,123.55555,1234567.6666);\n\treturn 0;\n}\n//china,     ch,chin,chi\n//9.55556,123.556,1.23457e+006\n\n 5. 基本输入输出的方法（重点）\n 1. 详解\nint i;\nchar a[20]=‘hello world’;\nchar b;char c;char d[50];\n\n\n\nputs(a);\n输出一个字符串遇到\\0转换为\\n,并结束输出。\n\n\n\n\ngets(a);\n读入一个字符串，长度应该小于字符数组，可以输入空格。(C99后淘汰)\n\n\nprintf(“%d”,i);\n格式化输出\n\n\nscanf(“%d”,&amp;i);\n格式化输入，scanf(%s)输入空格结束。\n\n\nb=getchar();\n从输入缓冲区里面读取一个字符\n\n\nputchar(b);\n输出一个字符\n\n\nc=getch();\n暂停输出控制台，直到按下一个键为止，它不使用任何缓冲区来存储输入字符，输入的字符将立即返回，而无需等待回车键，输入的字符不会显示在控制台上。需要&lt;conio.h&gt;\n\n\nc=getc(stdin);\n从“流”中读入一个字符。stdin是标准输入流\n\n\nungetc(b,stdin);\n将b中字符复制到输入流，可以用getchar()从输入流取出。\n\n\nsprintf(d,“miku, %s\\n”,a);\n将格式化的数据写入字符串d中。\n\n\n\nscanf()返回值\nscanf(“%d %d”, &amp;a, &amp;b);\na,b都正确输入，返回2（正确输入了两个变量）;\na,b中正确输入了一个变量,返回1。\n0 表示用户的输入不匹配，无法正确输入任何值。\nEOF 这是在stdio.h里面定义的常量（通常值为-1，表示输入流已经结束， 遇到错误或者end of file）\n结束输入流的方法：ctrl+z，回车。\n#include &lt;stdio.h>\nint main(){\n    int a; \n    do {\n\t\tprintf(\"请输入一串正整数: \");\n\t\twhile (scanf(\"%d\", &amp;a) != 1) {//如果读取的不是整数(返回值不为1)\n\t\t\tprintf(\"请输入一串正整数: \");\n            /*\n%后面跟*表示跳过相应的输入程序\nscanf(\"%*d %d\",a);输入66 55只会把55赋值给a，而忽略%*d读取的66\n            */\n\t\t\tscanf(\"%*[^\\n]\");//清除输入流的非数字字符，这边除了换行符都清理了\n\t\t}\n\n\t} while (a&lt;=0);\n    printf(\"你输入的数字是%d \\n\",a);// \\n换行\n    return 0;\n}\n\n 2. 实际操作\n//连续读一串数字\n#include &lt;stdio.h>\nint main(){\n    int a; \n\t\twhile (scanf(\"%d\", &amp;a) != -1) {//如果输入流没结束(没按ctrl+z然后回车)\n            //注意，如果输入e，scanf会返回0，进入死循环，打印奇怪的内容。\n\t\t\tprintf(\"%d \",a);\n\t\t}\n    printf(\"\\n\");\n    return 0;\n}\n//输入1 2 3 4 5 \n\n//屏蔽操作\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\nint main(){\n    int a; \n    int sum=0;\n    char ch;\n\twhile (scanf(\"%d\", &amp;a) == 1) {//scanf正常接收输入\n\t\t\tsum+=a;\n            while((ch=getchar())==' ');//只屏蔽空格\n            if(ch=='\\n'){\n                break;//结束while循环\n            }\n            ungetc(ch,stdin);//将ch的值放回stdin输入流\n\t\t}\n    printf(\"总数:%d\\n\",sum);\n    return 0;\n}\n66 55 44 \n    //a第一次值为66，ch第一次为' '，然后ch为'5'，然后ch的值放回输入流,a第二次值为55\n总数:165\n\n//隐蔽输入\n#include &lt;stdio.h>\n#include&lt;conio.h>\nint main() {\n    char a = 'A';\n    char b[20] = \"hello  \\0world\";\n    char c;\n    int i=0;\n    char password[20] = { 0 };\n    while (1) {//visual studio 2022写法\n        c = _getch();//实现隐蔽输入\n        if (c == '\\r') {//遇回车键跳出循环\n            break;\n        }\n        password[i] = c;\n        i++;\n    }\n    putchar(a);//打印字符\n    puts(b);\n    puts(password);\n    _getch();//让程序停一下,敲一个回车就停\n    return 0;\n}\n\n 3. 指针的打印\n#include &lt;stdio.h>\nint main ()\n{\n   int  var = 20;   /* 实际变量的声明 */\n   int  *ip;        /* 指针变量的声明 */\n   ip = &amp;var;  /* 指针存储 var 的地址 */\n \n   printf(\"var变量的地址: %p\\n\", &amp;var  );\n   printf(\"指针的值,也就是var的地址: %p\\n\", ip );//输出指针的值，也就是var的地址\n   printf(\"指针指向的值，也就是var的值: %d\\n\", *ip );//指针解引用，输出指针指向的值。\n //指针的值是一个地址，这个地址对应的内存存放着数据。\n   return 0;\n}\n输出：\nvar变量的地址: 0000002267CFF8F4\n指针的值,也就是var的地址: 0000002267CFF8F4\n指针指向的值，也就是var的值: 20    \n\n 6. 强制类型转换\nint a=5;\ndouble b=a;\ndouble c=(double)a;\n\n#include&lt;stdlib.h&gt;\nint atoi(const char* str) //字符串转为整数\ndouble atof(const char* str)  //字符串转为浮点数\nlong int atol(const char* str)  //字符串转为长整型\n\n 7. math.h库常见函数\n#include&lt;math.h&gt;\ndouble pow(x, y)：x^y，x的y次幂\nfloat powf(float x,float y); 功能与pow一致，只是输入与输出皆为浮点数\ndouble modf(double value,double *iptr);拆分value值，返回它的小数部分，iptr指向整数部分。\ndouble sqrt(x)：x的平方根\ndouble exp(x)：指数函数 e^x，e ≈ 2.718\ndouble log(x)：自然对数函数 ln(x)，x &gt; 0\ndouble log10(x)：以10为底的对数log10(x)，x &gt; 0\n绝对值\nint abs(int i); 求整型的绝对值\ndouble fabs (double);求实型的绝对值\ndouble cabs(struct complex znum);求复数的绝对值\n\n取整，取余\ndouble ceil (double); 取上整，返回不比x小的最小整数\ndouble floor (double); 取下整，返回不比x大的最大整数\n\n三角函数\ndouble sin (double a); a的正弦值\ndouble cos (double a); a的余弦值\ndouble tan (double a); a的正切值\n\n 三.分支结构\n 1. if…else if…else\n#include&lt;stdio.h>\nint main()\n{\n\tint a;\n\tprintf(\"输入成绩(整数)：\");\n\tscanf(\"%d\",&amp;a);\n\tif(a&lt;60)\n\t{\n\t\tprintf(\"不及格\\n\");\n\t}else if(a&lt;80){\n\t\tprintf(\"良好\\n\");\n\t}else{\n\t\tprintf(\"优秀\\n\");\n\t}\n\treturn 0;\n}\n\n 2. switch\n\nc语言中很显然int, short, long, enum, char(包括无符号类型和long long)都可以作为switch变量\n在switch语句中每一个的case常量表达式的值不可以相同。\n常见问题7。\n\nchar a;\na=getc(stdin);//从输入流读入一个字符\nswitch(a){\n\tcase 'a':printf(\"a\");\n        \t\tbreak;\n\tcase 'b':\n\t\t\tprintf(\"b\");\n        \tbreak;\n    default: printf(\"no\");\n        return 0;\n}\n\n 四. 运算符与顺序问题\n\n逻辑运算符两侧运算对象的数据类型可以是任何类型的数据.\n\n&amp;&amp; 两边为真才是真\n|| 其中一边是真才是真\n 优先级顺序表\n\n\n\n优先级\n运算符\n名称或含义\n使用形式\n结合方向\n说明\n\n\n\n\n1\n[]\n数组下标\n数组名[常量表达式]\n左到右\n–\n\n\n()\n圆括号\n(表达式）/函数名(形参表)\n–\n\n\n\n\n.\n成员选择（对象）\n对象.成员名\n–\n\n\n\n\n-&gt;\n成员选择（指针）\n对象指针-&gt;成员名\n–\n\n\n\n\n\n\n\n\n\n\n\n\n2\n-\n负号\n-表达式\n右到左\n单目运算符\n\n\n~\n按位取反运算符\n~表达式\n\n\n\n\n\n++\n自增运算符\n变量名/变量名\n\n\n\n\n\n–\n自减运算符\n–变量名/变量名–\n\n\n\n\n\n*****\n取值运算符\n*指针变量\n\n\n\n\n\n&amp;\n取地址运算符\n&amp;变量名\n\n\n\n\n\n!\n逻辑非运算符\n!表达式\n\n\n\n\n\n(类型)\n强制类型转换\n(数据类型)表达式\n–\n\n\n\n\nsizeof\n长度运算符\nsizeof(表达式)\n–\n\n\n\n\n\n\n\n\n\n\n\n\n3\n/\n除\n表达式/表达式\n左到右\n双目运算符\n\n\n*****\n乘\n表达式*表达式\n\n\n\n\n\n%\n余数（取模）\n整型表达式%整型表达式\n\n\n\n\n\n4\n+\n加\n表达式+表达式\n左到右\n双目运算符\n\n\n-\n减\n表达式-表达式\n\n\n\n\n\n5\n&lt;&lt;\n左移\n变量&lt;&lt;表达式\n左到右\n双目运算符\n\n\n&gt;&gt;\n右移\n变量&gt;&gt;表达式\n\n\n\n\n\n\n\n\n\n\n\n\n\n6\n&gt;\n大于\n表达式&gt;表达式\n左到右\n双目运算符\n\n\n&gt;=\n大于等于\n表达式&gt;=表达式\n\n\n\n\n\n&lt;\n小于\n表达式&lt;表达式\n\n\n\n\n\n&lt;=\n小于等于\n表达式&lt;=表达式\n\n\n\n\n\n7\n==\n等于\n表达式==表达式\n左到右\n双目运算符\n\n\n！=\n不等于\n表达式!= 表达式\n\n\n\n\n\n\n\n\n\n\n\n\n\n8\n&amp;\n按位与\n表达式&amp;表达式\n左到右\n双目运算符\n\n\n9\n^\n按位异或\n表达式^表达式\n左到右\n双目运算符\n\n\n10\n|\n按位或\n表达式|表达式\n左到右\n双目运算符\n\n\n11\n&amp;&amp;\n逻辑与\n表达式&amp;&amp;表达式\n左到右\n双目运算符\n\n\n12\n||\n逻辑或\n表达式||表达式\n左到右\n双目运算符\n\n\n\n\n\n\n\n\n\n\n13\n?:\n条件运算符\n表达式1?  表达式2: 表达式3\n右到左\n三目运算符\n\n\n\n\n\n\n\n\n\n\n14\n=\n赋值运算符\n变量=表达式\n右到左\n–\n\n\n/=\n除后赋值\n变量/=表达式\n–\n\n\n\n\n*=\n乘后赋值\n变量*=表达式\n–\n\n\n\n\n%=\n取模后赋值\n变量%=表达式\n–\n\n\n\n\n+=\n加后赋值\n变量+=表达式\n–\n\n\n\n\n-=\n减后赋值\n变量-=表达式\n–\n\n\n\n\n&lt;&lt;=\n左移后赋值\n变量&lt;&lt;=表达式\n–\n\n\n\n\n&gt;&gt;=\n右移后赋值\n变量&gt;&gt;=表达式\n–\n\n\n\n\n&amp;=\n按位与后赋值\n变量&amp;=表达式\n–\n\n\n\n\n^=\n按位异或后赋值\n变量^=表达式\n–\n\n\n\n\n|=\n按位或后赋值\n变量|=表达式\n–\n\n\n\n\n\n\n\n\n\n\n\n\n15\n，\n逗号运算符\n表达式,表达式,…\n左到右\n–\n\n\n\nx&gt;y?x:y 若x&gt;y为真则返回x，否则返回y\n 赋值相关\n{\n int a=2,b=4,c=6,x,y;\n y=((x=a+b),(b+c));//这里的y才=10。 \n y=(x=a+b),(b+c);//这里的y就直接等于6了\n printf(\"y=%d,x=%d\",y,x);\n}\n//关于i++,i--赋值，是从右往左开始算的\n#include&lt;stdio.h>\nvoid main()\n{\n\tint i=0;\n\tprintf(\"%d %d %d %d %d %d %d %d\",i,++i,-i--,++i,i,i++,i,i++);\n}//i++好像没反应\n//输出\n    2 2 -1 1 0 0 0 0\n\n 五.循环语句\n 0. 单步调试方法\nF9插入断点开始调试\nF11（汇编跟踪到循环语句）一般黄箭头在c=max(a,b)这行时用，然后进入被调用的函数中\nF10常用的，运行下一步\n 1. while\nint i,sum=0;\nwhile(i&lt;=100){\n\tsum += i;\n    i++;\n}\n\n 2. do…while…\n\ndo-while循环中，根据情况可以省略while\n\n先执行再判断while真假\ndo\n{\n\ti++;\n}while(i&lt;=100);\n\n 3. for嵌套\n#先执行最内层for，这里因为内部嵌套每次只输出一个字符，所以可用putchar('A')代替printf(\"%c\",'*')\n#for(;;)相当于while(1)会一直循环\n#for(表达式1;表达式2;表达式3)\n/*\n1.先求解表达式1；\n2.求解表达式2,其值为真(非0),则执行for循环语句中的内嵌语句,然后执行第3步,其值为假,则结束循环,转到第五步.\n3.求解表达式3.\n4.转回上面第二步继续执行.\n5.循环结束，执行for语句下面一个语句\n*/\n在字符数组中’\\0’是占一个位置的！\n例如 定义char c[6]=“hello”，而在内存中字符数组 c 则是\"hello\\0\"；\n#include &lt;stdio.h>\n \nvoid main (){\nint b,a;\nfor(b=1;b&lt;7;b++){\n\tfor(a=0;a&lt;b;a++){\n        printf(\"*\");\n            \n    }\n\tprintf(\"\\n\");\n}\n}\n*\n**\n***\n****\n*****\n******  \n\n 5. break，continue\n\n\n\nbreak一次只跳出一层循环\n\n\nwhile,do while,for可以用break跳出循环,continue结束本次循环，然后进入下次循环\n\n\ngoto,if语句不能break,continue进行控制，也就是说if语句里面的break终止的是if外一层的循环(比如for，while啥的)\n\n\n\n#include &lt;conio.h>\nvoid main(){\n\tint i=0;\n\tchar c;\n    while(1){\n\tc='\\0';//变量赋初值\n\twhile(c!=13&amp;&amp;c!=27)//键盘接受字符直到按回车或者esc\n    {\n        c=getch();//，字符输入函数，不回显函数，无需按回车，要求头文件&lt;conio.h>\n        printf(\"%c\\n\",c);\n    }\n    if(c==27)\n        break;//判断若esc键则跳出循环\n    i++;//按下回键，i++\n    printf(\"The number is %d\\n\",i);\n\t}\n\tprintf(\"The end\");\n}\n\n 6.精度判断,算pi\n\n近似公式pi/4约等于1-1/3+1/5-1/7+…\n1e-6表示1*(10^-6)\n\n#include&lt;stdio.h>\n#include&lt;math.h>\nvoid main(){\n\tint s;float n,t,pi;\n\tt=1;pi=0;n=1.0;s=1;\n\twhile(fabs(t)>1e-6)\n    {\n        pi=pi+t;n+=2;s=-s;t=s/n;\n    }\n\tpi=pi*4;\n\tprintf(\"pi=%10.6f\\n\",pi);//如果输出的长度小于10则会在结果左端补充空格(右对齐)\n    /*float k=6.0;printf(\"%5.1f\\n\",k);左端空格为2个*/\n}\n\n 7.素数判断\n\n思路：让m被2到k整除，k=sqrt(m),for(i=2;i&lt;=k;i++),n%i==0\n\n 8.斐波那契\n\n思路：f1,f2覆盖过去就行了,比如f1=f1+f2\n\n 六.数组\n 1. 简介+string.h\n\n\n一维数组 类型说明符 数组名[常量表达式];\n整型数组int a[10];有十个元素，从a[0]到a[9],不存在a[10]\nvc中int 4字节，float 8字节\n对于同一个数组，其所有元素的数据类型都是相同的\n允许int a,b,c,d,k1[10],k2[20];\nC语言不允许对数组大小作动态定义（不能变量说明数组大小），即int n; scanf(“%d”,&amp;n);int a[n];是不允许的\nfloat a[0]没有意义\n合法的a[0]=a[2]+a[5]-a[2*3];引用中a[i+j];引用中a[i++]\n在c语言中只能逐个使用下标变量，不能一次性使用整个数组\n\n\n#string.h\nstrcmp(字符数组一，字符数组二)字符数组一比较字符串\nstrlen(字符数组)求字符串长度\nstrlwr(字符数组)大写换小写\nstrupr(字符数组)小写换大写\nstrcat(char* s1,char* s2)字符串2拼接到字符串1末尾，删掉字符数组1末尾的\\0\nstrcpy()\n将一个字符串复制到另一块空间地址中 的函数，‘\\0’是停止拷贝的终止条件，同时也会将 '\\0' 也复制到目标空间。\nstrstr()用于找到子串在一个字符串中第一次出现的位置\n#include &lt;stdlib.h>\natoi字符串转换为整型\natof字符串转换为浮点型\natol字符串转换为长整型\n    '2'-48=2\n\n#一维数组在内存的存放\nint mark[100];\n低地址 86 mark[0]\n      92 mark[1]\n      77 mark[2]\n      52 mark[3]\n      ...\n高地址 94 mark[99]\n86占四个字节（每个数据元素占用的字节数，就是基类型的字节数，一个元素占4个字节）\n\n 2. 数组赋值\nint i,a[0];\nfor(i=0;i&lt;=9;i++)\n{\n\tscanf(\"%d\",&amp;a[i]);//动态赋值,每输入一次要回车，赋值还可以a[i]=i;\n\n}\nfor(i=9;i>=0;i--)\n{\n\tprintf(\"%d\",a[i]);\n}\n\n 3. 初始化赋值\n\n字符数组中可以存放ASCII字符集中的任何字符\n字符数组的字符串可以整体输入、输出\n不可以用关系运算符对字符数组中的字符串进行比较\n假设有char a[10]=“abc”;则strlen(a)的值为3。\n\nint a[10]={1,2,3,4,5}//这时候a[8]=0\nint a[10];//这时候a[0]是乱码\nint a[]={1,2,3,4,5,6,7}//可以不指定数组长度\n\n//要防止越界问题字符串末尾默认是\\0\nchar s[6] = {\"ABCDE\"}; //这个系统可以自动添加\nchar s[6] = {’A’, 'B’, 'C’, 'D’, 'E’ ,'\\0'}; //这个需要自己手动添加。\n\n//下面两个，a的长度比b长\nchar a[ ]=\"ABCDEF\";\nchar b[ ]={'A', 'B', 'C', 'D', 'E', 'F'};\n\n 4. 数组求解斐波那契\n\n公式求解\n\n#include&lt;stdio.h>\nvoid main(){\n\tint i;\n    int a[20]={1,1};\n    for(i=2;i&lt;20;i++)\n    {\n        a[i]=a[i-2]+a[i-1];\n    }\n    for(i=0;i&lt;20;i++){\n        if(0==i%5){\n            printf(\"\\n\");\n        }\n        printf(\"%12d\",a[i]);\n    }\n    printf(\"\\n\");\n}\n\n 5. 冒泡排序\n\n相邻数比较,小的冒泡上排，大的沉底,\nn个数，进行n-1趟比较，第一趟比较进行n-1次两两比较，第j趟进行n-j次两两比较\n\n#include&lt;stdio.h>\nvoid main(){\n\tint a[10];\n    int i,j,t;\n    printf(\"input 10 number:\\n\");\n    for(i=0;i&lt;10;i++)\n    {\n        scanf(\"%d\",&amp;a[i]);//1.用户输入十个数\n    }\n    printf(\"\\n\");\n    for(j=0;j&lt;9;j++)\n    {\n        for(i=0;i&lt;9-j;i++)//n-j次两两比较\n        {\n            if(a[i]>a[i+1])\n            {\n                t=a[i];a[i]=a[i+1];a[i+1]=t;//两数替换\n                //这边可以加个flag=0;减少次数\n            }\n        }\n        \n    }\n\tprintf(\"the sorted number is:\\n\");\n        for(i=0;i&lt;10;i++)\n        {\n            printf(\"%d >>\",a[i]);\n            \n        }\n        printf(\"\\n\");\n}\n\n 6.二维数组\n\n类型说明符 数组名 [常量表达式] [常量表达式];\n在c语言中，二维数组是按照行排列的\n多维数组第一维的下标量变化最慢\n\na[3][4]//三行四列，第一个a[0][0]\n\n 1. 二维数组引用和初始化\nint a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\nint a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};\n也可以(第二维长度必须指定)\nint a[][4]={1,2,3,4,5,6,7,8,9,10,11,12};\n\nint a[3][4]={{1},{0,6},{0,0,11}};//a[0][0]=1;第二行第二个6;第三行第三个11\nint a[3][4]={{1},{5},{9}};//初始化的是每一行的第一个元素,其他初始化为0!!a[0][0]=1,a[1][0]=5,a[0][1]=0\nint a[3][4]={1,5,9};//初始化的是第一行的三个元素\n\n 2. getchar输入二维数组（重点）\n#include&lt;stdio.h>\n#include&lt;math.h>\n#include&lt;string.h>\nint main()\n{\n    int i=1,j=0,n;\n    char a[21][21],ch;\n\tscanf(\"%d\",&amp;n);\n\tgetchar();//吃一个回车\n    for(i=1;i&lt;=n;i++)\n\t{\t\t\n\t\t\n\t\twhile((ch=getchar())!='\\n')\n\t\t{\n\t\t\t//用ch避免数组吃回车\n\t\t\ta[i][j]=ch;\n\t\t\tj++;\n\t\t}\n\t\ta[i][j]='\\0';//数组末尾补0\t\n\t\tj=0;\n\t\t\n\t}\n\tfor(i=1;i&lt;=n;i++){\n\t\tputs(a[i]);//从a[1][0]开始打印第1行，遇到\\0结束\n\t}\n    return 0;\n}\n\n 7. 二分法查找\n\n有个数组从小到大排列,找其中的一个数\n选定区域查找,每次搜索范围缩小一半\n需要low,mid,high分别指向开始,中间,末尾\n\n#define M 10\n//宏定义,没分号\n#include &lt;stdio.h>\nvoid main()\n{\n\tstatic int a[M]={-12,0,6,16,23,56,80,100,110,115};//普通变量存放在栈区,static变量存放在data区\n    int n,low,high,mid,found;\n    low=0;high=M-1;found=0;\n    printf(\"input a number to be search:\");\n    scanf(\"%d\",&amp;n);//预处理步骤,\n    /*scanf可以改进一下\n    do\n    {\n    \tscanf(\"%d\",&amp;n);\n    \tgetchar();\n    }while(n&lt;a[0]||n>a[M-1]);\n    */\n    while(low&lt;=high)\n    {\n        mid=(low+high)/2;\n        if(n==a[mid])\n        {\n            found=1;break;\n        }//找到,结束循环\n        else if(n>a[mid])\n            low=mid+1;//若low=mid后面如果high=n,low在n前面一个元素,mid没法指到n\n        else\n            high=mid-1;\n    }\n    if(found==1)\n        printf(\"the index of %d is %d\",n,mid);\n    else\n        printf(\"there is no %d\",n);\n    \n}\n\n 8. 中文字符串（宽字符和多字节字符）\n\n用visual studio 2022\n\n#include &lt;stdio.h>\n#include &lt;string.h>\n#include &lt;stdlib.h>\n#include &lt;locale.h>\n#include &lt;wchar.h>\nint main()\n{\n\tsetlocale(LC_ALL,\"\");//utf-8一个中文占三字节\n\tint cont=0;\n//wchar_t *a=L\"春天\";\n\tchar *a=\"春天\";\nchar b[20];\nchar c[20]={\"你好再见\"};\n//cont=wcstombs(b,a,20);\nc[0]=*a;\n\tc[1]=*(a+1);\n\tc[2]=*(a+2);\nprintf(\"%s\",c);\n\n return 0;  \n}\n输出\n    春好再见\n\n#include &lt;stdio.h>\n#include &lt;string.h>\n#include &lt;stdlib.h>\n#include &lt;locale.h>\n#include &lt;wchar.h>\nint main()\n{\n\tsetlocale(LC_ALL,\"\");//软件运行时的语言环境\n    //utf-8一个中文占三字节\n\tint cont=0;\nwchar_t *a=L\"春天\";\nchar b[20];\nchar c[20]={\"你好再见\"};\ncont=wcstombs(b,a,20);//宽字符转化成多字节字符\nc[0]=b[0];\n\tc[1]=b[1];\n\tc[2]=b[2];\nprintf(\"%s\",c);\n return 0;  \n}\n输出\n    春好再见\n\n 七.函数\n 0. 概念\n\n\n\n所有函数是平行的，即在定义函数时是分别进行的，是相互独立的。\n\n\n函数不能嵌套定义，但可以嵌套调用\n\n\n函数可以相互调用，但不能调用main函数，main函数是系统调用的。\n\n\n程序从main函数开始，在main函数中调用其他函数，调用后流程回到main函数，在main函数中结束整个程序运行。\n\n\n用户角度函数有两种：标准函数（库函数），用户自定义函数。\n\n\n函数形式来看，函数分为两类：无参函数（主函数不向被调用函数传递数据，一般用来执行指定的一组操作），有参函数(主函数通过参数向被调用函数传递数据，执行被调用函数会得到一个函数值，供主函数使用)。\n\n\n在主函数中调用（不是声明）一个函数时，函数名后面的括弧中的参数（可以是一个表达式）称为实际参数（简称实参）。\n\n\n有参函数中定义函数时，函数名后面的括弧中的变量名称为形式参数（简称形参）。\n\n\nreturn后面的括弧中的值（）作为函数带回的值（简称函数返回值）。\n\n\n在不同函数间传递数据，可以使用的法：参数：通过形式参数和实际参数，返回值：用return语句返回计算结果。全局变量：外部变量。\n\n\n形参在未出现函数调用之前不占内存中的储存单元，并且在调用结束后形参所占的储存单元也被释放。\n\n\n实参可以是常量，变量或表达式（比如3，a+b,x&gt;y?x:y）但要有确定的值，在调用时将实参的值赋给形参。\n\n\n在被定义的函数中，必须指定形参的类型int x\n\n\n形参或实参的类型赋值兼容或相同\n\n\n内存中实参单元和形参单元是不同单元。实参对形参的数据传递是值传递（相当于copy，实参保留原值），单向传递，只能由实参传递给形参。\n\n\n一个函数的函数体一般包括参数和返回值\n\n\n如果在一个函数中的复合语句中定义了一个变量，则该变量只在该复合语句中有效\n\n\n在函数内定义的变量只在本函数范围内有效\n\n\n在不同函数中可以使用同名字的变量\n\n\n形式参数是局部变量\n\n\n下面函数调用语句含有实参的个数为2。\n(x1,x2)实际上只取了x2做参数，(x3,x4,x5)实际上只取了x5做参数；\nfunc((exp1, exp2), (exp3, exp4, exp5));\n\n\n如果形参与实参的类型不一致，以形参类型为准\n\n\n如果函数值的类型与返回值类型不一致，以函数值类型为准\n\n\n函数的实参可以是常量，变量或者表达式，但是函数形参不能是常量\n\n\n形参，实参可以为任意类型\n\n\nC语言规定，简单变量作为实参时，它和对应形参之间的数据传递方式是单向值传递。\n\n\n若使用一维数组名作为函数实参，则以下正确的说法是必须在主调函数中说明此数组的大小\n\n\nC语言规定，函数返回值的类型是由在定义该函数时所指定的函数类型所决定\n\n\n\n 1.定义函数\n//定义无参函数\nvoid pt(){\n    int a=10;//声明部分\n    printf(\"%d\\n\",a);//语句部分\n}\n//定义有参函数\ndouble square(double a){\n    char c[30]=\"square is used\";\n    printf(\"%s\",c);\n    return a*a;//返回值跟函数同一类型double\n}\n//定义空函数\ndummy(){}//相当于int dummy(){}\n\n 2.调用函数时数据的传递\n#include &lt;stdio.h>\nvoid main()\n{\n\tfloat max(float x,float y);//被调用函数的声明在主调函数之后，要对max函数的声明，里面是形参\n    float a,b,c;\n    scanf(\"%f,%f\",&amp;a,&amp;b);//例如输入11.2,13.9\n    c=max(a,b);//实参\n    printf(\"max is %f\\n\",c);\n}\nfloat max(float x,float y)\n{\n    float z;\n    z=x>y?x:y;\n    return(z);//函数返回值通过return语句获得\n}\n\n 3.函数返回值\n\n\nreturn z;等价于return (z);\n函数返回值应属于某一确定类型，在定义函数时指定函数的返回类型。\n在c语言中，凡是不加类型说明的函数，自动按整形处理。（c++所有函数要指定函数类型）\n对不带回值的函数，应该用void定义函数为无类型（空类型）。（此函数不带return）\n\n\n 4.函数的调用\n\n\n一般调用：函数名(实参表列)\nvc6，visual studio 2022对实参求值的顺序是自右向左调用\n_cdecl方法，stdcall方法都是自右向左调用\n\n\n//对于函数调用\nint i=2,p;\np=f(i,++i);\n//如果按自左向右求参的值，则函数调用相当于f(2,3)\n//如果按自右向左求参的值，则函数调用相当于f(3,3)\n#include &lt;stdio.h>\nvoid main()\n{\n\tint f(int a,int b);\n\tint i=2,p;\n\tp=f(i,++i);\n\tprintf(\"%d\\n\",p);\n}\nint f(int a,int b)\n{\n\tint c;\n\tif(a>b)c=1;\n\t\telse if(a==b)c=0;\n\t\t\telse c=-1;\n\treturn(c);\n}\n\n 5.函数调用方式\n//用函数语句\nprintstar();\n//函数表达式\nc=2*max(a,b);\n//函数参数，函数调用作为一个函数的实参\nm=max(a,max(b,c));//先运行里面那个\nprintf(\"%d\",max(a,b));\n\n 6.对被调用函数的声明和函数原型\n\n\n首先被调用的函数必须是已经存在的函数（是库函数或用户自己定义的函数）。\n如果使用库函数，在本文件开头用include语句把头文件包含进来\n如果使用用户自己定义的函数，而该函数的位置在调用它的函数（即主调函数）的后面(在同一个文件中)，应该在主调函数中对被调用函数作声明。\n声明（declaration）作用是把函数名，函数参数个数，参数类型等信息通知给编译系统，以便在遇到函数调用时，编译系统能正确识别函数并检查调用是否合法。（不占内存）\n函数定义是指对函数功能的确立（占内存）\n如果被调用函数的声明在主调函数之前，可以不必加以声明。\n\n\n#include &lt;stdio.h>\nint f(int a,int b)\n{\n\tint c;\n\tif(a>b)c=1;\n\t\telse if(a==b)c=0;\n\t\t\telse c=-1;\n\treturn(c);\n}\nvoid main()\n{\n\tint f(int a,int b);\n    //被调函数在主调函数前，上面一行可以不写\n\tint i=2,p;\n\tp=f(i,++i);\n\tprintf(\"%d\\n\",p);\n}\n\n 7.自敲pow函数\n#include&lt;stdio.h>\nvoid main(void)\n{\n    double power(double x,double y);\n    printf(\"%lf\",power(2,3));\n}\ndouble power(double x,double y)\n{\n    double z=1;\n    while(y)\n    {\n        z*=x;\n        --y;\n    }\n    return z;\n}\n\n 8.自敲sqrt函数(不好,只能整数部分)\n#include&lt;stdio.h>\n\nint sqrt_02(int question)\n{\n\tint temp=question/2;\n    while(temp--)\n    {\n        if((temp*temp)&lt;=question)\n        \treturn temp;\n    }\n    return -1;\n}\nvoid main(void)\n{\n\tint question=49,answer;\n    answer=sqrt_02(question);\n    if(answer&lt;0)\n        printf(\"error\");\n    else\n        printf(\"question is %d,and answer is %d\",question,answer);\n}\n\n 9.嵌套调用函数\n\n\nreturn返回上一层函数\n\n\n 计算s=(22)!+(32)!\n\n需要定义的函数\nfactorial计算阶乘\nsquare计算平方值\n\n#include &lt;stdio.h>\nlong square(int p);\nlong factorial(int q);//声明\nvoid main()\n{\n    int i;\n    long s = 0;\n    s = square(2) + square(3);\n    printf(\"%ld\\n\", s);\n}\n//定义square\nlong square(int p)\n{\n    int k;\n    long r;\n    k = p * p;\n    r = factorial(k);\n    return r;\n}\nlong factorial(int q)\n{\n    long c = 1;\n    int i;\n    for (i = 1; i &lt;= q; i++)\n    {\n        c *= i;//迭代\n    }\n    return c;\n}\n\n 10.递归调用（recursion）\n\n在调用一个函数的过程中，直接或者间接地又调用该函数本身，称为递归调用\n\n//计算n!\n//0!=1\n#include &lt;stdio.h>\nlong rc(int n);\nvoid main()\n{\n    int n; long result;\n    scanf(\"%d\", &amp;n);\n    result = rc(n);\n    printf(\"%d!=%ld\\n\", n, result);\n}\nlong rc(int n)\n{\n    long t;\n    if (n &lt; 0)\n        printf(\"n&lt;0,input error!\\n\");//结束递归\n    else if (n == 0 || n == 1)\n        t = 1;//结束递归\n    else\n        t = rc(n - 1) * n;//递归，调用这个调用函数\n    return t;\n}\n\n 取牌游戏\n游戏规则:\n桌面有12张牌，玩家和机器人轮流取牌，每次只能取走1~3张，玩家先取,取走最后一张牌的一方失败。请证明玩家必赢。\n\n#include &lt;stdio.h>\n#include &lt;stdbool.h>\nint x, z;//数组坐标\nint d = 0;//递归深度\nint b[15][20] = { 0 };\nbool canWin(int n) {\n    d++;//深度+1\n    if (n &lt;= 0) {\n        d--;\n        return true;//0张牌时，自己赢\n    }\n    int i;\n    for (i = 1; i &lt;= 3; i++) {  // 尝试取1~3张牌\n        if (!canWin(n - i)) { //存在子负己胜 (对方输，自己赢)\n            //if,()里面canwin的返回值是对方赢或者输\n            if (d % 2 == 1) {//人类赢，记录\n                b[x][d] = i;\n            }\n            else {//机器赢\n                b[x][d] = 0;//清空这一块\n            }\n            d--;//递归返回，深度-1\n            return true;\n        }\n    }\n    //不存在子负己胜==任意子胜己负\n    if (d % 2 == 0) {  //机器人输，记录\n        if (n == 1) {\n            b[x][d] = 1;//剩一张牌时，取1\n        }\n        else {\n            b[x][d] = (i==4?3:i);\n        }\n    }\n    else {//人类输\n        b[x][d] = 0;\n    }\n    d--;//递归返回，深度-1\n    return false;\n}\nvoid pt(int n) {\n    int i = 0, j = 1;\n    while (1) {\n        if (b[n][j] != 0) {\n            printf(\"%d \", b[n][j]);\n            j++;//列号++\n        }\n        else {\n            printf(\"\\n\");//换行\n            break;\n        }\n    }\n}\nint main() {\n    x = 0, z = 0;\n    int n;\n    for (n = 4; n &lt;= 12; n++) {\n        x = n;\n        if (canWin(n)) {\n            printf(\"剩下%d 张牌先手必赢  \\n\", n);\n            pt(x);\n        }\n    }\n    return 0;\n}\n\n 11.数组元素作为函数的实参\n//只要数组类型和函数的形参变量类型一致\nint a[10]={1,2,3,4,5,6};\nint i;\nfor(i=0;i&lt;10;i++)\n{\n    test(a[i]);\n}\nvoid test(int v)//这里形参可以不是数组\n{\n    if(v>0)\n    {\n        printf(\"%d\",v);\n    }\n}\n\n 12.数组名作为函数参数\n//形参和实参必须类型相同的数组\n//进行址传递（形参数组不被分配内存）\n//形参数组和实参数组指向同一段内存空间\n//数组名是第一个元素的地址\n#include&lt;stdio.h>\nvoid test(int b[10]);\nvoid main()\n{\n    int a[10]={1,2,3,4,5,6,7,8,9,10};\n    test(a);\n    putchar('\\n');\n}\nvoid test(int b[10])\n{\n    int i=0;\n    for(;i&lt;5;i++)\n    {\n        printf(\"%d\",b[i]);\n    }\n}\n\n 求平均成绩\n//一维数组score,10学生成绩,\n#include&lt;stdio.h>\ndouble average(double array[10]);\nvoid main()\n{\n    double score[10]={82,100,87.5,89,78,85,67.5,92.5,93,94},result;\n    result=average(score);\n    printf(\"average score is %5.2lf\\n\",result);\n    putchar('\\n');\n}\ndouble average(double array[10])\n{\n    double result=0;\n    int i=0;\n    for(i=0;i&lt;10;i++)\n    {\n        result+=array[i];\n    }\n    result/=10;\n    return result;\n}\n}\n\n 形参数组不定义长度\ndouble average(double array[])\n//形参array里面不写元素个数或者乱写都可以\n\n 13.局部变量（按变量的作用域来分）\n\n\n形参也相当于局部变量，只在该函数里有效\n主函数定义的变量也只在主函数里有效\n不同函数里可以使用相同名字的变量，他们代表不同的对象，互不干扰。\n在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为分程序或者程序块。（见下面1-2）\n\n\n 1-1\nfloat float(int a)//函数f1\n{\n    int b,c;//a,b,c有效\n}\nchar f2(int x,int y)//函数f2\n{\n    int i,j;//x,y,i,j有效\n}\nvoid main()//主函数\n{\n    int m,n;//m,n有效\n}\n\n 1-2\nvoid main()\n{\n    int a,b;//出了括号,这里c就无效了\n    {\n        int c;\n        c=a+b;//c在此范围内有效，a,b在此范围内有效\n    }\n}\n\n 14.全局变量\n\n\n在函数外部定义的变量为外部变量，也就是全局变量。（全程变量）\n全局变量可以为本文件中其他函数所共用。他的有效范围为从定义变量的位置开始到本源文件结束。\n全局变量在程序的全部执行过程中都占用储存单元，而不是仅在需要的时候才开辟单元。过多会降低程序清晰度。\n从一个文件复制函数到另一个文件时，全局变量也要移过去，很麻烦。\n\n\nint p,q;//全局有效\nfloat float(int a)//函数f1\n{\n    int b,c;//a,b,c,q,p有效\n}\nchar f2(int x,int y)//函数f2\n{\n    int i,j;//x,y,i,j,p,q有效\n}\nvoid main()//主函数\n{\n    int m,n;//m,n,p,q有效\n}\nint vs(int a,int b,int c)//比如这样用\n{\n    int v;\n    v=a*b*c;\n    p=a*b;\n    q=c*b;\n    return v;\n}\n\n 15.变量存储类别（变量值存在的时间来分）\n\n在c语言中每个变量和函数都有两属性：数据类型和数据的存储类别（数据在内存中的存储方式）。\n存储方式分为两大类：静态存储类和动态存储类。\n具体四种：自动(auto)，静态(static)，寄存器(register)，外部（extern）\n\n\n动态存储\n         (auto变量,形参，register变量）（本函数有效）\n\n\n\n静态存储\n（静态局部变量，函数内有效）\n（static外部变量，本文件有效）\n（外部变量，其他文件可用）\n\n\n\n动态存储方式\n动态存储方式是在程序运行期间根据需要进行动态的分配存储空间的方式\n静态存储方式\n静态存储方式是在程序运行开始由系统分配固定存储空间的方式\n 1. auto变量\n\n\n\n函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的栈，数据存储在动态存储区中。\n\n\n调用时分配存储空间，调用后释放存储空间。\n\n\n因此这类局部变量称为自动变量，用auto作为存储类别的声明。\n\n\n关键字auto可以省略，auto不写则隐含定为自动存储类别，属于动态存储方式。\n\n\n\nint f(int a)\n{\n    auto int b,c=3;//定义a，b为自动变量\n}\nauto int m相当于int m相当于auto m\n\n 2. 用static声明局部变量\n\n有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，即其所占的存储单元不释放，在下次该函数调用时，该变量已有值，就是上一次函数调用结束时的值。\n\n定义局部静态变量不赋入初值，则对静态局部变量来说，编译时自动赋初值为0（对数值型变量），或者空字符。\n而对于自动变量来说，如果不赋入初值则它的值是一个不确定的值。（每次调用后存储单元会释放）\n虽然静态局部变量在函数调用结束后任然存在，但是其他函数是不能引用它的。\n\n\n#include&lt;stdio.h>\nint f(int a)\n{\n    auto b=0;//相当于auto int b,\n    //上面局部变量存储在栈\n    static int c=3;//静态变量存储在数据区\n    b=b+1;\n    c=c+1;\n    return(a+b+c);\n}\nvoid main()\n{\n    int a=2,i;\n    for(i=0;i&lt;3;i++)\n    {\n        printf(\"%d\\n\",f(a));//a作为形参传到另一个函数里                                                         \n    }\n}\n\n 3. register(寄存器)变量\n\n如果有一些变量频繁地使用，每次循环都要引用某局部变量的值。对寄存器的存储速度远高于对内存的存储速度。\n\nregister所在子函数执行完毕立即释放。\n\n\n#include&lt;stdio.h>\nint fac(int n)\n{\n    register int i,f=1;\n\tfor(i=1;i&lt;n;i++)\n    {\n        f*=i;\n    }  \n    return f;\n}//计算阶乘\n\n 4. extern声明外部变量&amp;外部函数(重要)\n\n用来扩展程序文件中的作用域\n一般跟着全局变量用\n//如果在定义函数时省略extern,则隐含为外部函数。\n\n同一个项目下创建a.h,a.c\n//a.h\n#pragma once\n#ifndef _A_H_\n#define _A_H_\n#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h>\n#define N 8\nextern int m[N][N];//声明m为一个已定义的外部数组\nvoid pt(double a);\n#endif\n\n//a.c\n#define _CRT_SECURE_NO_WARNINGS\n#include\"a.h\"\n#include&lt;stdio.h>\nint m[N][N] = { 0 };\nvoid fill() {\n\tregister int i , j ;\n\tfor (i=0; i &lt; N; i++) {\n\t\tfor (j=0; j &lt; N; j++) {\n\t\t\t//防止数组越界，一般每行最后一位保证是0\n\t\t\tm[i][j] = i + j;\n\t\t\tprintf(\"%d \",m[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n\nvoid pt(double a) {\n\tprintf(\"%g\", a);\n}\n\n//主函数所在.c\n#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h>\nint main()\n{\n    double a = 10.56;\n    pt(a);\n    putchar('\\n');\n    fill();\n    return 0;\n}\n\n 5. static声明外部变量\n\n希望某些外部变量只限于被本文件引用，而不能被其他文件引用\nstatic int A;只属于该文件\n\n 6. 关于变量声明与定义\n\n\n定义性声明（要建立存储空间如int a）；引用性声明（不需建立存储空间如extern a）;\nint a既是声明又是定义；extern a只是声明不是定义；\n\n\n 八. C语言指针详解（重点）\n 0. 概念与选择题\n1.直接访问,例如a=5，把5保存到地址为2000的单元\n2.间接访问，例如scanf(“%d”,&amp;a);调用函数时，把变量a的地址传递给函数scanf,函数首先把该地址保存到一个单元中，然后把从键盘接收的数据通过所存储的地址保存到a变量中。//我觉得地址可以理解为单元的门牌，数据是里面住的人。\n3.指针作为特殊变量，存放地址。\n4.*取值操作符。&amp;取址操作符。\n5.当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。\nint **var;\n6.指针变量之差是两个指针之间的元素个数\n7.char *language[ ]=&#123;&quot;FORTRAN&quot;, &quot;BASIC&quot;, &quot;PASCAL&quot;, &quot;JAVA&quot;, &quot;C&quot;&#125;;其中*language[2]的值是字符P\n8.main函数的正确说明形式是int main(int abc, char **abv)\n9.若假设第一个printf语句输出的是ffca，则第二个printf语句的输出ffdc。\nvoid main(){\n\tshort int a[10] = {2,4,6,8,10,12,14,16,18,20},*p;\n\tp = a;\n\tprintf(\"%x\\n\", p);\n\tprintf(\"%x\\n\", p+9);\n}\n\n\n若有以下定义，则正确的程序段是( D )。\n\nint *p, *s, i, j;\nchar *q, ch;\nA) main() { *p = 100;  ...}//p为野指针，解引用出问题\nB) main() { p=&amp;ch; s=p; ...}//int指针把char当成int访问不必要内存\nC) main() { p=&amp;i; q=&amp;ch; p=q; ...}\nD) `main() { p=&amp;i; q=&amp;ch; *p=40; *q=*p; ...}`\n\n11.当main函数带有形参时，传给形参的值一般从命令行中得到\n12.若有函数max(a,b)，并且已使函数指针变量p指向函数max，当调用该函数时，正确的调用方法是 (*p)(a,b);\n13.若有以下定义和语句，则对a数组元素的正确引用为*(p[1]+1)  。\nint a[2][3], (*p)[3]\np=a;\n\n14.指针变量和它指向的变量之间的关系，可以用指针运算符“*”表示。\n15.这段代码是错误的，因为数组指针p的列没跟b的列一致。\nint b[3][5], (*p)[3], (*q)[5]; p=b; q=b;\n16.(不严谨)若有以下定义，且0&lt;=i&lt;4，则不正确的赋值语句是( B )。\nint b[4][6], *p, *q[4];\nA)q[i]=b[i];    \nB)p=b;    \nC)p=b[i];    \nD)q[i]=&amp;b[0][0];\n/*先右后左原则来看指针\nq本质是int*s[]，q[i]本质int*s\nb表示整个二维数组，本质int*s[]\nb[i]本质int*s，p本质int*s\n&amp;b[i][j]本质int*s\n单从类型对应角度选B\n*/\n\n 1. 指针常见形式详解（重要）\n32bit架构内存地址长度4字节，32bit程序中指针大小4字节。\n64bit架构内存地址长度8字节，64bit程序中指针大小8字节。\nint* a,b; 等价于 int *a；int b；而不等价于 int *a; int *b;\n\n//定义指针变量,用来存放整型变量i的地址\nint *i_pointer\n\n//间接存放i的值，可以先找到存放i的地址的变量i_pointer,从中取出i的地址(2000),然后取出i的值3    \nint i=2000;\nint *pointer;//1.这里*不是取值操作符，而是声明指针的特征(表示这是个指针变量，变量名为pointer)\ni_pointer=&amp;i;//2.&amp;取i的地址赋给i_pointer\nprintf(\"%d\\n\",*pointer);//3.这个是取值操作符，进行指针解引用\n\nvoid main()\n{\n    int *a,*b,c;\n\tc=5;\n\ta=&amp;c;//指针a所在地址单元存放c的地址\n\tb=a;\n    printf(\"%d   \",b);//指针b所在地址单元存放c的地址\n}\n/*&amp;c       \t\t\t*a      *b\n1703720    内容  1703720\t1703720\n\t\t   地址  1703728  1703724\n*/\n\n辨认准则：找到变量名(没有就看最内部结构)，先向右看(不跳过括号)，然后向左看(不跳过括号)，然后跳出一层括号，重复上述操作。\n//比如：int* a[5]; 首先向右看，它是一个5元素数组，然后向左看指向int类型，所以a是个有5个指向int类型指针的数组。\n\n\n\n\n\n含义\n\n\n\n\nint a[n]\nint数组\n\n\nint *p[n]\n指针数组p，由n个指向整型的指针元素构成\n\n\nint (*p)[n]\np为指向含n个元素的一维数组的指针变量\n\n\nint f()\nf为带回一个整型函数值的函数\n\n\nint *p()\np为带回一个指针的函数，该指针指向整形数据\n\n\nint (*p)()\np为指向函数的指针，该函数返回整型值\n\n\nint **p\np为指针变量（二级指针），存放一级指针地址，一级指针指向int变量\n\n\nint (*(*v)[])()\nv是一个指针，指向一个数组，数组元素是指针，每个指针指向一个int函数。\n\n\n\n*&amp;a等价于变量a\n&amp;*a等价于&amp;a\n#include&lt;stdio.h>\n#include&lt;string.h>\n#include &lt;malloc.h>\nvoid main()\n{\n\tchar *str=NULL;\n    int s=30;\n    str=fa(s);\n    printf(\"str=%s\\n\",str);//printf(%s)需要的是一个地址，然后从这个地址开始打印字符串遇到空格或\\0停止\n    free(str);//防止内存泄漏。free()只能释放指针所指向的那片内存。\n    str=NULL;//防止产生野指针\n    system(pause);\n}\nchar* fa(int x)//指针数组带回一个指针\n{\n    char *pstr=NULL;\n    x++;\n    pstr=fb(10);\n    return pstr;//指针变量pstr到这里结束\n    \n}\nchar* fb(int m)\n{\n    char *pa=\"123456\";//pa指针在栈区\n    //123456在堆区\n    char *p=NULL;\n    //指针变量在栈区分配4字节\n    {int i=30;}\n    p=(char *)malloc(100);\n    //malloc函数开辟一块堆区存储空间,\n    strcpy(p,\"wudunxiong 123456\");\n    //wudongxiong 123456在常量区\n    return p;//返回给主调函数fa()\n}\n\n\n 2. 野指针\n野指针是指程序员或操作者不能控制的指针。野指针不是NULL指针，而是指向“垃圾”的指针。\n造成“野指针”的原因主要有：\n1.指针变量没有初始化，任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指。在初始化的时候要么指向合法的指针，要么指向NULL。\n2.指针变量被free或delete之后，没有设置为NULL。它们只是把指针所指的内存给释放掉，但指针本身还有值。\n3.指针操作超越了变量的作用范围。 注意其生命周期。\n 3. 编写swap的注意\nint main()\n{  int a=10, b=20;\n   printf(\"a=%d,b=%d\\n\", a, b);\n   swap(&amp;a, &amp;b);\n   printf(\"a=%d,b=%d\\n\", a, b);\n   return 0;\n}\nvoid swap(int p, int q)\n{  int t;\n   t=p; p=q; q=t;\n}\n上面代码是错的，p，q不指向a，b，没法改值。\n修改后的swap函数可以是：\nvoid swap( int *p, int *q )\n{int t;\nt=*p; *p=*q; *q=t;\n}\n\n 4. 指针的使用\n//错误示范\n#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdlib.h>\n#include &lt;stdio.h>\ntypedef struct node {\n\tint data;\n\tstruct node* next;\n}node;\nvoid create(node *h){\n\th = (node*)malloc(sizeof(node));\n\t//此时h!=NULL,head==NULL\n\th->data = 10;\n}\nint main() {\n\tint i, j;\n\tnode* head=NULL;\n\tcreate(head);//值传递,h=head=NULL\n\tprintf(\"%d\", head->data);\n\t//报错，因为一级指针并没影响到head指针\n\treturn 0;\n}\n\n//更正方法1: 返回一级指针\nnode* create(node *h){\n\th = (node*)malloc(sizeof(node));\n\th->data = 10;\n\treturn h;\n}\nhead=create(head);\n//更正方法2: 用二级指针指向一级指针实现引用传递\nvoid create(node **h){\n\t*h = (node*)malloc(sizeof(node));\n\t(*h)->data = 10;\n}\ncreate(&amp;head);\n\n 2.指针变量定义\n\n\n变量的地址称为该变量的指针。（指针变量的值是一个地址）\n专门用来存放变量地址的变量，称为指针变量。\n定义一般形式：类型说明符 *变量名\n&amp;a表示a的地址\n如果将一个整数赋给一个指针变量，那么编译器会把该值当成一个地址来处理。\n\n\n//合法定义\nchar a='A';int *p=&amp;a;//&amp;a是a的地址(一个整数)\n//非法定义\ndouble b = 66.6; int* p = b; //b不是整数不能代表一段地址\n\n注意：(*pointer_1)相当于a，要打括号，因为从右往左结合\n 3.指针做函数参数\n#include&lt;stdio.h>\nvoid swap(int *p1,int *p2);\nvoid main()\n{\n    int a,b;\n\tint *pointer_1,*pointer_2;\n    scanf(\"%d%d\",&amp;a,&amp;b);\n    pointer_1=&amp;a;\n    pointer_2=&amp;b;\n\tif(a&lt;b)\n    {\n        swap(pointer_1,pointer_2);\n    }//此后p1指向b，p2指向a\n\n    printf(\"%d > %d\\n\",a,b);  \n    //这里也可以是*pointer_1,*pointer_2    \n}\nvoid swap(int *p1,int *p2)//*声明指针变量\n{\n    int temp;\n    printf(\"I'm swapping······\\n\");\n\ttemp=*p1;//用了取值操作符，所以temp=a;\n    *p1=*p2;\n    *p2=temp;\n}\n\n 4.数组与指针\n\n\n一个数组包含若干元素，每个数组元素都在内存中占用存储单元，但它们都有相应的地址。\n数组名翻译成数组第一个元素的地址。\n\n\np=&amp;a[0];\np=&amp;*(a+i);//比如p=&amp;*(a+1);\n*(p+i)\n\n 1. 数组名作函数参数\n\nf(int arr[],int n)编译时将arr按照指针处理（数组名代表数组首元素地址），相当于将函数f的首部写成f(int *arr,int n)\n\nreverse(a,10);//实参a是一个一维数组\nvoid reverse(int *x,int n)//形参x为指针变量\n{}\n\n 2. 多维数组和指针（重点）\n\n定义一个a[3] [4]，地址排列类似一维数组\n一维数组取出的值是二维数组的地址例如*(a+1)\n\n\n\n\n表现形式\n含义\n地址（例如）\n\n\n\n\na\n二维数组名，指向以维护组a[0],即0行首地址\n2000\n\n\na[0],*(a+0),*a\n0行0列元素地址\n2000\n\n\na+1,&amp;a[1]\n1行首地址\n2016\n\n\na[1],*(a+1)\n1行0列元素a[1] [0]的地址\n2016\n\n\na[1]+2,*(a+1)+2,&amp;a[1] [2]\n1行2列元素a[1] [2]的地址\n2024\n\n\n*(a[i]+2),*(*(a+1)+2),a[1] [2]\n一行二列元素a[1] [2]的值\n元素值为13\n\n\n\n 3. 指向二维数组的指针\n\n\n\n把二维数组a分解为一维数组a[0],a[1],a[2]之后，设p为指向二维数组的指针变量。\n\n\n可定义为:int (*p)[4]，他表示p是一个指针变量，指向包含4个元素的一维数组。\n\n\n若指向第一个一维数组a[0],其值等于a,a[0],或&amp;a[0] [0]等。\n\n\n二维数组指针变量说明的一般形式为：\n类型说明符 (*指针变量名)[长度]\n\n\n\n#include&lt;stdio.h>\nvoid main()\n{\n    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};\n    int (*p)[4];//p相当于有4个格子的窗格。\n    //本质是指向一个含有四个元素数组的指针\n    int i,j;\n    p=a;\n    for(i=0;i&lt;3;i++)\n    {\n        for(j=0;j&lt;4;j++)\n        {\n            printf(\"%2d \",*(*(p+i)+j));\n        }\n        printf(\"\\n\");\n    }\n}\n\n 5. 字符串与指针\n//声明字符串，放到常量存储区，字符串不可改变，字符串编译地址赋给*a\n//可以改变指针变量的值，让它指向不同常量的值\nchar *a=\"i love fishc.com!\";\nprintf(\"%s\\n\",a);\na+=4;\nprintf(\"%s\\n\",a);//输出ve fishc.com!\n\n 6. 关于使用字符指针变量和字符数组\n\n1.字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是字符串第一个字符的地址。\n\n对数组的初始化\n    char str[20]={\"i love fish\"};\n不等价于\n    char str[20];\nstr[]=\"i love fish\";//这个只能一个字符一个字符赋值\n\n//对于指针可以\nchar *a;\na=\"i love fish\";\n//等价于\nchar *a=\"i love fish\";\n\nchar str[10];\nscanf(\"%s\",str);\n//以上完全可以\n//以下危险（指针变量不赋初值会随机指向）\nchar *a;\nscanf(\"%s\",a);\n\n//用数组下标索引\nchar *a=\"i love fishc.com!\";\nprintf(\"%s\\n\",a);\na+=4;\nprintf(\"%s\\n\",a);//输出ve fishc.com!char \n\n 7. 指针函数与函数指针\n指针函数：返回指针的函数,本质函数\n函数指针：指向函数的指针\n#include&lt;stdio.h>\nint* han2(int* b);//han2在han下面，所以要声明\nvoid han(int* (*x1)(int*), int a, int* b) {//函数指针，注意*号不要漏了\n    int* p;\n    p = x1(&amp;a);\n    printf(\"a:%d b:%d\\n\", *p, *b);\n}\nint* han2(int* b) {//指针函数\n    int* p = b;//p和b都指向a的地址\n    return p;\n}\nint main() {\n    int a = 10, b = 20;\n    han(han2, a, &amp;b);\n    return 0;\n}\n\n 8. 函数指针实现多态\n\n每次调用实现不同功能\n\n#include &lt;stdio.h>\nint add(int a, int b)\n{\n    return a+b;\n}\nint sub(int a, int b)\n{\n    return a-b;\n}\nint mul(int a,int b)\n{\n    return a*b;\n}\nint process(int (*fun)(int,int), int a, int b)\n{\n    return fun(a,b);//也可以return (*fun)(a,b);\n}\nint main()\n{\n    int a,b,r;\n    printf(\"输入a、b两数：\\n\");\n    scanf(\"%d%d\",&amp;a,&amp;b);\n    printf(\"两数之和：%d\\n\", process(add,a,b));\n    printf(\"两数之差：%d\\n\", process(sub,a,b));\n    printf(\"两数之积：%d\\n\", process(mul,a,b));\n}\n\n 10. 指针数组和数组指针\n指针数组：存放指针的数组，本质数组。int* name[10]={&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4]};\n数组指针：指向数组的指针。int (*a)[5];//指向一个每列5个元素的int类型数组\n 11. main函数参数问题\n\n\n\n写完下面代码后编译，把生成的.exe文件(在debug文件夹里)放到一个文件夹里\n\n\n在文件夹里开cmd，\n\n\n输入 文件名.exe fish.com i love fish .com!\n例如.\\666.exe i love fishc.com? yess;\n\n\n\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\nvoid main(int argc,char *argv[])\n{\n    int i;\n    printf(\"the number of string is : %d\\n\",argc-1);//参数个数\n    for(i=1;i&lt;argc;i++)\n    {\n        printf(\"the string %d is : %s\\n\",i,argv[i]);//后面输入时，空格隔开当成一个参数\n    }\n    \n}\n\n 12. void指针与const指针\n\nvoid *p\n\n\n\n不指向一个确定的类型数据，仅仅存放一个地址\n\n\n如果将void指针的值赋给其他类型的指针，则需要进行强制的类型转换\n\n\n其他类型指针都可以直接给void指针赋值\n\n\n\nconst指针\n\nconst 在*号左边则不能改变值，在右边则不能改变指向。\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\nvoid main(int argc,char *argv[])\n{\n\tconst char *str=\"Welcome to Fishc.com!\\n\\n\";\n\t//指针str指向const char类型，不能改值，可以改指向。\n#if(0)\n    str[0]='w';//非法\n#endif\n    str=\"I love fishc.com!\\n\\n\";//合法\n    printf(\"\\n\\n%s\",str);\n}\n\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\nvoid main(int argc,char *argv[])\n{\n\tchar * const str=\"Welcome to Fishc.com!\\n\\n\";\n    //从右往左看，str先是一个常量，然后发现是const指针指向char\n    //所以str不可改指向，但是可以改指向的数据内容。(理论上)\n    str[0]='w';//合法（编译可过，但windows静止常量被重写）\n#if(0)\n    str=\"I love fishc.com!\\n\\n\";//非法\n#endif\n    \t\n    printf(\"\\n\\n%s\",str);\n}\n\n 13. 二级指针\n\n\nint *p,**p;//这是错误的，因为重名了。\n\n\n#include &lt;stdio.h>\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\tint *p = &amp;a;\n\tint** s = &amp;p;//二级指针所在地址存放一级指针的地址\n    printf(\"%d %d\",*s,p);//426767748 426767748c\n\t//指针一次解引用,*s类型int*\n\t*s = &amp;b;\n\t//指针二次解引用,**s类型int\n\t**s = 200;\n\treturn 0;\n}\n\n 14. 数组偏移与指针偏移（重要）\n\n数组偏移\n\n详见\nint a[10]={0};\n&amp;a 、a 、&amp;a[0] 表示的是同一个地址，但是级别是不一样的。\n&amp;a + 1 偏移了40字节，即声明数组空间的大小。\na + 1 ，&amp;a[0] + 1偏移了4字节，即数组中一个元素的空间大小。\n&amp;a指向整个数组的地址，是数组中的最高级别，而 a 和 &amp;a[0] 表示 &amp;a 代表地址的下一级别地址。\n\n指针偏移\n\nchar a[10] = “hello world”;\nchar* p = a;\np+1偏移一个字节(sizeof(char))。\nchar b[4][10] = &#123; 0 &#125;; \nchar (*p)[10] = b;\np + 1偏移10个字节。\n #include &lt;stdio.h>\nint main()\n{\n\t//普通变量\n\tint a1 = 1;\n\tint a2 = 1;\n\tint a3 = 1;\n\t//指针数组，本质数组\n\tint* p[3] = { &amp;a1,&amp;a2,&amp;a3 };//数组大小32\n\t//二级指针，本质指针\n\tint** s = p;\n\tprintf(\"%d %d \\n\", s, p);//s的值是数组的地址\n\tprintf(\"%d %d %d %d %d %d\", &amp;a1,*s, p[0], *s + 1, p[0] + 1,**s);\n\t//&amp;a1相当于1级指针，*s==&amp;a1==p[0]\n\t//*s+1和p[0]+1偏移4字节，因为int a1,a2,a3内存中连续存储\n\treturn 0;\n}\n\n 九.预处理\n 优点\n\n\n方便输出\n\n比如#define P printf\n#define D “%d\\n”\n#define F “%f\\n”\n使用时P(D F,a,b);\n\n 1. 无参宏定义\n\n#开头的均为预处理命令\ndefine为宏定义命令\n格式\n#define 标识符 字符串\n注意\n\n\n宏定义必须写在函数以外，作用域为宏定义命令开始到源程序结束，可以用#undef命令终止作用域\n比如#undef PI;\n\n\n末尾加分号则连分号一起置换\n\n\n宏名在源程序中若用引号括起来，则预处理程序不对其作宏代换。\n\n\n\n#define PI 3.1415926\nprintf(\"now the PI is %g\\n\",PI);\n\n 2. 宏定义\n\n\n\n宏定义允许嵌套，在宏定义的的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层代换。\n#define PI 3.1415926\n#define S PI*r*r\n\n\n宏定义是普通的字符串替换\n\n\n\n#define _quote(que) quote\n#define qwe _quote(que)\n//qwe表示quote\n\n//打印数字0-999\n#include&lt;stdio.h>\n#define A(x) x;x;x;x;x;x;x;x;x;x;\nint main(void)\n{\n    int n=0;\n    A(A(A(printf(\"%d\",n++))));\n    return 0;\n}\n\n 3. typedef\n\n对类型说明符重命名\n比如\n\ntypedef　char*　pStr1;\n#define　pStr2　char*　\npStr1　s1, s2;//等价于char *s1, *s2;\npStr2　s3, s4;//等价于char* s3, s4;\n//#define 只做简单的字符串替换\n\n 4. 带参宏定义\n\n\n\n带参宏定义中，宏名和形参表之间不能有空格出现。\n#define MAX (a,b) (a&gt;b)?a:b//不行\n#define MAX(a,b)  (a&gt;b)?a:b//行\n\n\n. 在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义。宏定义可以带有参数，宏调用时是以实参代换形参。而不是“值传送”。\n\n\n在宏定义中，字符串内的形参通常要用括号括起来以避免出错。\n#define SQ(y)   (y)*(y)  那么SQ(4)=16\n#define SQ(y)   y*y   那么SQ(3+1)=7   3+1乘3+1\n#define SQ(y)   (y)*(y)  那么160/SQ(3+1)=160 160/y乘y\n#define SQ(y)   ((y)*(y))  那么160/SQ(3+1)=10\n\n\n在宏定义中的形参是标识符，而宏调用中的实参可以是表达式。\n\n\n. 带参的宏和带参函数很相似，但有本质上的不同，除上面已谈到的各点外，把同一表达式用函数处理与用宏处理两者的结果有可能是不同的。\n#define SQ(y)   ((y)*(y))\nSQ(++i),如果i=1\n(++i)*(++i)=9\n\n\n宏定义也可用来定义多个语句，在宏调用时，把这些语句又代换到源程序内。\n\n\n\n#define M(y) y*y+3*y      /*宏定义*/\n       ……\n    k=M(5);                   /*宏调用*/\n\n 5. 文件包含\n\n\n\n一个include命令只能指定一个被包含文件，若有多个文件要包含，则需用多个include命令。\n\n\n文件包含允许嵌套，即在一个被包含的文件中又可以包含另一个文件。\n\n\n#include&quot;stdio.h&quot;\n#include&lt;math.h&gt;\n使用尖括号表示在包含文件目录中去查找(包含目录是由用户在设置环境时设置的)，而不在源文件目录去查找；\n使用双引号则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找\n\n\n\n 6. 条件编译\n#ifdef 标识符\n程序段1\n#else\n程序段2\n#endif\n1.如果标识符已被 #define命令定义过则对程序段1进行编译；否则对程序段2进行编译。没有程序段2，可以不写#else。\n\n2.不执行\n#if(0)\n程序段\n#endif\n\n 十. 结构体和共用体\n 1. 概述\n\n\n在定义结构时，不可以为成员设置默认值\n\n\n结构体中的成员可以与结构体变量同名\n\n\nC语言结构体类型变量在其生存期间所有成员一直驻留在内存中\n\n\n\ntypedef struct\n { int n;\n  struct {int y, m, d; } date;\n } PERSON;\n\n则下面定义结构体数组并赋值的语句中错误的是()。\nPERSON x[2]={{1},04,10,1,{2},04,12,30};\n```\n\n\n\n\n 5. \n   ```c\n   typedef struct REC\n   {\n   char c; int a[4];\n   }REC1;//**REC1，REC是结构体类型,不是变量**\n   ```\n\n 6. 结构体类型本身不占用内存空间，结构体变量占用内存空间。\n\n 7. 结构体成员的类型不一定是基本数据类型。\n\n 8. 共用体变量不可以进行初始化\n\n 9. 枚举类型中的元素都具有一个整型值。\n\n\n\n### 2. 结构体变量定义和赋值\n\n```c\n/*1.先声明结构体类型再定义变量名\n类型名struct 结构体名student 变量名student1\n定义student1和student2为struct student类型的变量，具有struct student 类型的结构\n在定义了结构体变量后，系统会为之分配内存单元。*/\nstruct student\n  {\n      int num;\n      char name[20];\n      char sex;\n      int age;\n      float score;\n      char addr[30];\n  };\nstruct student student1,student2;//有点像实例化对象\n\n//2.在声明类型的同时定义变量\nstruct student//结构体名\n{  int num;\n     char name[20];//成员表列\n     char sex;\n     int age;\n     float score;\n     char addr[30];\n}student1,student2;//变量名表列\n\n//3. 直接定义结构体类型变量,即不出现结构体名\nstruct{\n    int id;\n    char name[20];\n}student;\n```\n\n> 赋值\n\n```c\nstruct student\n{\n    int num;\n    char* name;\n    char sex;\n    float score;\n}boy1, boy2 = { 102, \"Jane\", 'M', 98.5 };//赋值方法1\nint main()\n{\n    boy1.num = 666;//赋值方法2\n    boy1=boy2;//赋值方法3\n    strcpy(boy1.name , \"Fishc\");//赋值方法4\n    return 0;\n}\n```\n\n\n\n### 3. 结构体引用与嵌套\n\n1. “.”是成员(分量)运算符\n\n2. 正确引用结构体变量中成员的方式为： 结构体变量名.成员名\n\n  3. 不能将一个结构体变量作为一个整体进行输入和输出。\n   4. 对结构体变量的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。\n\n```c\n/* 不能用student1.birthday来访问student1变量中的成员birthday,因为birthday本身是一个结构体变量。*/\n#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h>\nvoid main()\n{\n    struct date\n    {\n        int day;\n        int month;\n    };\n    struct\n    {\n        int num;\n        char name[20];\n        char sex;\n        struct date birthday;//把struct date看成是自定义类型。\n        float score;\n    } boy1, boy2;\n    printf(\"Please input birthday(MM:) \");\n    scanf(\"%d\", &amp;boy1.birthday.month);\n    printf(\"Please input birthday(DD:) \");\n    scanf(\"%d\", &amp;boy1.birthday.day);\n    printf(\"\\n\");\n    boy2 = boy1;\n    printf(\"boy1's birthday is %d-%d\\n\", boy1.birthday.month, boy1.birthday.day);\n    printf(\"boy2's birthday is %d-%d\\n\", boy2.birthday.month, boy2.birthday.day);\n}\n```\n\n \n\n### 5. 结构体数组\n\n```c\n//可以这样定义\nstruct student\n{\n\t\tint num;\n\t\tchar name[20];\n\t\tchar sex;\n\t\tint age;\n\t\tfloat score;\n\t\tchar addr[30];\n };\nstruct student student[3];\n//或者这样\nstruct student\n{\n\tint num;\n\tchar name[20];\n\tchar sex;\n\tint age;\n\tfloat score;c\n\tchar addr[30];\n }student[3];\n```\n\n### 6. 初始化数组\n\n```c\nstruct student\n{\n\tint num;\n\tchar name[20]； \n\tchar sex；     \n  \tint age； \n\tfloat score; \n\tchar addr[30]；\n}stu[2]＝ {{101,″LiLin″,′M′,18,87.5,″Beijing″},{102,″Zhang″,′F′,19,99,″Shanghai″}};　 \n或者\nstruct student　str[]={{…},{…},{…}}；\n&lt;/stdio.h>\n 7. 指向结构体类型的指针\n\n\n结构指针变量说明的一般形式为：\n \t\tstruct 结构名 *结构指针变量名\n \n \t    \t    \t    \t    \t    \t    \t    \t    \t    \t    \t    \t    \t    \t    \t    \t\tstruct stu *pstu;\n\n\n\n赋值是把结构变量的首地址赋予该指针变量，不能把结构名赋予该指针变量。\npstu=&amp;boy是正确的。\n \t  pstu=&amp;stu是错误的。\n\n \t **结构名**表示一个结构形式，编译系统并不对它分配内存空间。**结构体变量**有分配存储空间。\n\n\n\n访问方法\n(*pstu).num\npstu-&gt;num\n\n\n#include &lt;stdio.h>\n\nstruct stu\n{      \n      int num;     \n      char *name;      \n      char sex;      \n      float score;      \n} boy1 = {102, \"Fishc\", 'M', 78.5};\nvoid main()\n{\n      struct stu *pstu;\n      pstu = &amp;boy1;\n      \n      printf(\"Number = %d\\nName = %s\\n\", boy1.num, boy1.name);      \n      printf(\"Sex = %c\\nScore = %f\\n\\n\", boy1.sex, boy1.score);      \n\n      printf(\"Number = %d\\nName = %s\\n\", (*pstu).num, (*pstu).name);      \n      printf(\"Sex = %c\\nScore = %f\\n\\n\", (*pstu).sex, (*pstu).score);      \n\n      printf(\"Number = %d\\nName = %s\\n\", pstu->num, pstu->name);      \n      printf(\"Sex = %c\\nScore = %f\\n\\n\", pstu->sex, pstu->score);      \n}\n\n*(++p)->m这里->优先级比*高\n\n 8. 结构指针变量作函数参数\n将一个结构体变量的值传递给另一个函数，有3个方法:\n（1）用结构体变量的成员作参数\n（2）用结构体变量作实参\n（3）用指向结构体变量（或数组）的指针作实参，将结构体变量（或数组）的地址传给形参\n//用结构体变量作函数参数\n#include &lt;stdio.h>\n#include &lt;string.h>\nstruct student\n{\n      int num;\n      char *name;//或者char name[20];搭配下面第二种\n      float score[3];\n};\nvoid print( struct student stu )\n{\n      printf(\"\\tnum     : %d\\n\", stu.num);\n      printf(\"\\tname    : %s\\n\", stu.name);\n      printf(\"\\tscore_1 : %5.2f\\n\", stu.score[0]);\n      printf(\"\\n\");\n}\nvoid main()\n{\n      struct student stu;\n      stu.num = 8;\n      stu.name = \"Fishc.com!\";\n      stu.score[0] = 98.5;\n      print( stu );\n}\n\n\n//用结构体变量作实参\nvoid print( struct student *p )\n{\n      printf(\"\\tnum     : %d\\n\", p -> num);\n      printf(\"\\tname    : %s\\n\", p -> name);\n      printf(\"\\tscore_1 : %5.2f\\n\", p -> score[0]);\n      printf(\"\\n\");\n}\nvoid main()\n{\n      print( &amp;stu );\n}\n\n 9.动态存储分配（重点）\n#include&lt;stdlib.h&gt;\n\n\n\n分配内存空间函数 malloc、calloc\n\n\n修改已经分配内存函数realloc\n\n\n释放内存空间函数 free\n\n\n\n malloc函数\nvoid *malloc(unsigned int size);\n其作用是在内存的动态存储区中分配一个长度为size的连续空间（size是一个无符号数）。\n此函数的返回值是一个指向分配域起始地址的指针（类型为void）。\n失败则返回空指针(NULL)。\nint* a = (int *)malloc(5*sizeof(int));\n calloc函数\nvoid *calloc（unsigned n, unsigned size）;\n其作用是在内存的动态存储区中分配ｎ个长度为size的连续空间。\n函数返回一个指向分配域起始地址的指针；\n如果分配不成功，返回NULL。\nint* p=(int*)calloc(10,sizeof(int));\n realloc函数\nvoid* realloc(void* ptr,size_t size)\n修改已经分配的内存块大小。\nint* a = (int *)malloc(5*sizeof(int));\nint* p=(int *)realloc(a,20*sizeof(int));//返回指向新分配内存的指针\n\n free函数\n函数原型为void free（void *p）;\n其作用是释放由p指向的内存区，使这部分内存区能被其他变量使用。\np是最近一次调用calloc或malloc函数时返回的值。\nfree函数无返回值。\n 10 . typedef\n\n\ntypedef可以声明各种类型，但不能用来定义变量\n#define在预编译时处理，typedef在编译时处理\n\n\n//1. 给已有类型int取别名\ntypedef int INTEGER;\n//2. 给结构体取别名REC1\ntypedef struct REC{ \n    char c;  \n    int a[4];\n } REC1;\n //REC1是一个结构体定义\n     void main(){\n     REC1 data1;\n     data1.c='k';\n }\n//3. 声明NUM为整型数组类型\ntypedef int NUM[100];\nvoid main(){\n     NUM num={0};\n     printf(\"%d\",sizeof(num));\n }\n//声明STRING为字符指针类型\ntypedef char* STRING;\nvoid main(){\n     STRING p;\n     p=\"i love fishc.com\";\n     printf(\"%s\",p);\n }\n//声明POINTER为指向函数的指针类型\ntypedef void (*POINTER)();\nvoid fun(){\n    printf(\"i love fishc.com\");\n}\nvoid main(){\n    POINTER p1;//void (*p1)();\n    p1=fun;\n    p1();\n}\n\n 11. 链表（重点）\n链表是一种常见的重要的数据结构,是动态地进行存储分配的一种结构。\n链表的组成：\n头指针：存放一个地址，该地址指向第一个结点。\n结点：一个指向结构体变量(包含数据域和指针域)的指针。\n在数据结构中会详细介绍各种链表，这里只以单链表为例。\n 1. 单链表创建和打印\n#include &lt;stdio.h>\n#include&lt;stdlib.h>\ntypedef struct listnode{//结构体取别名LN\n    int val;//数据域\n    struct listnode * next;//指针域\n}LN;\nint main() {\n    //创建头节点\n    LN* head = NULL;\n\n    LN* n1 = (LN*)malloc(sizeof(LN));//创建第一个节点\n    n1->val = 1;\n    n1->next = NULL;\n    head = n1;//头节点目前相当于n1\n\n    LN* n2 = (LN*)malloc(sizeof(LN));//创建第2个节点\n    n2->val = 2;\n    n2->next = NULL;\n    n1->next = n2;//n1->next指向n2地址\n\n    //打印链表的值\n    LN* current = head;//current相当于n1\n    while (current != NULL) {\n        printf(\"%d \", current->val);\n        current = current->next;//指向下一个结点\n    }\n    printf(\"\\n\");\n    //释放内存\n    current = head;\n    while (current != NULL) {\n        LN* temp = current->next;\n        free(current);\n        current = temp;\n    }\n    return 0;\n}\n\n 2. 单链表的前插(头插)\n链表L在值为i的第一个结点前插入一个值为j的结点\nLN* preInsert(LN* head, int i, int j) {\n    LN* p = head;\n    if (p == NULL) {\n        printf(\"空链表\");\n        return head;\n    }\n    while (p != NULL) {//单链表至少包含两个结点(包含头结点)\n        if (p->val == i) {//在头节点前插入\n            LN* m = (LN*)malloc( sizeof(LN));\n            //单链表没有连续的内存块，不能重新分配(realloc)一块内存块\n            m->next = p;//指向旧的头结点\n            m->val = j;\n            head = m;//新的头结点\n            return head;//返回\n        }\n        else if (p->next->val == i) {\n            LN* m = (LN*)malloc(sizeof(LN));\n            m->next = p->next;//新节点先连接后面\n            p->next = m;//再连接前面\n            m->val = j;\n            return head;\n        }\n        p = p->next;\n    }\n    printf(\"找不到元素\");\n    return head;\n}\n\n 3. 单链表的后插(尾插)\n链表L在值为i的第一个结点后插入一个值为j的结点\nLN* tailInsert(LN* head, int i, int j) {\n    LN* p = head;\n    if (p == NULL) {\n        printf(\"空链表\");\n        return head;\n    }\n    while (p != NULL) {//单链表至少包含两个结点(包含头结点)\n        if (p->next==NULL&amp;&amp;p->val==i) {//在尾结点后插入\n            LN* m = (LN*)malloc(sizeof(LN));\n            p->next=m;\n            m->next=NULL;\n            m->val=j;\n            return head;\n        }\n        else if (p->val == i) {\n            LN* m = (LN*)malloc( sizeof(LN));\n            m->next=p->next;//先连后面\n            p->next=m;//再连前面\n            m->val=j;\n            return head;//返回\n        }\n        \n        p = p->next;\n    }\n    printf(\"找不到元素\");\n    return head;\n}\n\n 4. 单链表的删除\n删除值为i的结点，要用m保存结点，再释放内存\nLN* deleteNode(LN* head, int i) {\n    LN* p = head;\n    if (p == NULL) {\n        printf(\"空链表\");\n        return head;\n    }\n    while (p != NULL) {//单链表至少包含两个结点(包含头结点)\n        if (p->val == i) {//删除n1，头结点指向n2\n            LN* m = (LN*)malloc(sizeof(LN));\n            m = head;\n            head = head->next;\n            free(m);\n            return head;//返回\n        }\n        else if (p->next->val == i) {\n            LN* m = (LN*)malloc(sizeof(LN));\n            m = p->next;\n            p->next = m->next;\n            free(m);\n            return head;\n        }\n        p = p->next;\n    }\n    printf(\"找不到元素\");\n    return head;\n}\n\n 12. 共用体\n\n几个不同变量共用一段内存的结构\n\nunion data\n{\n\tint i;\n    char ch;\n}a,b,c;\n或者\nunion data\n{\n\tint i;\n    char ch;\n};\nunion data a,b,c;\n\n 13. 枚举\n#include&lt;stdio.h> \n/* 定义枚举类型 */\nenum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN };\n \nvoid main()\n{\n    /* 使用基本数据类型声明变量，然后对变量赋值 */\n    int x, y, z;   \n    x = 10;\n    y = 20;\n    z = 30;\n    \n    /* 使用枚举类型声明变量，再对枚举型变量赋值 */\n    enum DAY yesterday, today, tomorrow;  \n    yesterday = MON;\n    today     = TUE;\n    tomorrow  = WED;\n printf(\"%d %d %d \\n\", yesterday, today, tomorrow);\n}\n或者\n    /* 使用枚举类型声明变量同时对枚举型变量赋初值 */\n    enum DAY yesterday = MON, \n             today = TUE,\n             tomorrow = WED;\n或者\n    /* 定义枚举类型，同时声明该类型的三个变量，并赋初值。它们都为全局变量 */\nenum DAY\n{\n    MON=1, TUE,WED,THU,FRI,SAT,SUN\n}yesterday = MON, today = TUE, tomorrow = WED;\n\n\n 十一.文件操作\n 1.概念\n\n\n\n“文件”是指一组相关数据的有序集合\n\n\n特殊文件(标准输入输出文件或标准设备文件),普通文件(磁盘文件)\n\n\n输入文件：终端键盘,输出文件：显示屏和打印机\n\n\nASCII文件(文本文件):每一个字节放一个ASCII代码\n二进制文件:把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放。\n\n\n文件的读函数是从输入文件中读取信息，并存放在内存中。\n\n\n不能用&quot;r&quot;方式打开一个并不存在的文本文件。\n\n\n若执行fopen函数时发生错误，则函数的返回值是0。\n\n\nfclose成功0，失败EOF(-1)\n\n\n设fp是指向某个文件的指针，且已读到文件末尾，则库函数feof(fp)的返回值是非0值\n\n\n若要用fopen函数打开一个新的二进制文件，该文件既要能读也要能写，则文件方式字符串应是(  “wb+”)。\n\n\n若要指定打开c盘上子目录myfile下的二进制文件test.bin，在调用函数fopen时，第一个参数的正确格式是(&quot;c:\\\\myfile\\\\test.bin&quot;)。\n\n\n设有一个名为file1C源程序，且已知命令行为：FILE1 CHINA BEIJING SHANGHAI，则可得以以下运行结果的C源程序为(  )。\nCHINA\nBEIJING\nSHANGHAI\n\n\n main(int argc, char *argv[ ])\n  { while(argc-->1)                           printf(\"%s\\n\", *++argv);\n  }\n\n13. 下面程序段的运行结果是( a+=b,a=11,b=10  )。\n                                                                                                                \n   char *format=&quot;%s,a=%d,b=%d\\n&quot;;\n\nint a=1,b=10;\na+=b;\nprintf(format,“a+=b”,a,b);\n\n以下程序有错，错误原因是(q虽然指向了具体的存储单元，但该单元中没有确定的值，所以不能执行语句*p=*q;  )。\n\nmain()\n{ int *p, i; char *q, ch;\n p = &amp;i;\n                                                                                                                \n                         q = &amp;ch;\n                                                                                                                \n                         *p = 40;\n                                                                                                                \n                         *p = *q;\n                                                                                                                \n                         ......\n\n}\n\n文件名不一定要包含后缀名。\ngetchar只针对标准输入流stdin，即使对stdin重定向，getchar针对的也只是stdin。f 系列（比如fwrite）的输入输出函数都是作用于所有流的\n\n\n C语言对文件的处理方法\n\n\n\n缓冲文件系统：系统自动地在内存区为每一个正在使用的文件开辟一个缓冲区。用缓冲文件系统进行的输入输出又称为高级磁盘输入输出。\n\n\n非缓冲文件系统：系统不自动开辟确定大小的缓冲区，而由程序为每个文件设定缓冲区。用非缓冲文件系统进行的输入输出又称为低级输入输出系统。\n\n\n在UNIX系统下,用缓冲文件系统来处理文本文件，用非缓冲文件系统来处理二进制文件。\nANSI C 标准只采用缓冲文件系统来处理文本文件和二进制文件。\n\n\n\n 2.文件读写详解\n 1. 详解\n\n修饰符\n\nt 以文本模式打开文件(默认)，可省略(w等价于wt)\nb 以二进制模式打开文件\n\n模式\n\n\n\n\nr\n以只读的形式打开文本文件，文件必须已存在\n\n\n\n\nw\n以只写的形式打开文本文件(若不存在则新建，存在则清空文件内容)\n\n\na\n以追加的形式打开文本文件(若不存在，则新建；反之，在原文件后追加)\n\n\nrb\n以二进制只读的形式打开二进制文件\n\n\nwb\n以二进制只写的形式打开二进制文件\n\n\nab\n以二进制追加的形式打开一个文件\n\n\nr+\n以读写的形式打开文件(文件必须已存在)\n\n\nw+\n读写方式打开文件。文件不存在，则建立一个新文件。若文件存在，则删除文件内容。\n\n\na+\n读写方式打开文件。如果文件存在，数据会被写入到文件末尾。如果文件不存在，则创建新文件。\n\n\nrb+\n以二进制读写的形式打开文件。文件必须已存在。(r+b)\n\n\nwb+\n以二进制读写的形式打开文件。文件存在则清空文件内容，不存在则创建新文件。(w+b)\n\n\nab+\n以二进制读写的形式打开文件。文件存在，则在尾部追加数据。不存在则创建文件。\n\n\n\n\n读写相关函数\n\nint num=100,a[10];\nFILE *fp1=fopen(“.//user.txt”,“r”);//定义文件指针\nFILE *fp2=fopen(“.//user.txt”,“rb”);//二进制打开文件\nchar str[100],ch;\nconst char* str2=“hello”;\n\n\n\n读写相关函数\n解释\n\n\n\n\nfopen\n打开文件\n\n\nfclose(fp);\n删除文件\n\n\nch=fgetc(fp);\n读取一个字符\n\n\nfgets(str,sizeof(str),fp);\n读取一行字符串\n\n\nfputc(ch,fp);\n向文件写入一个字符\n\n\nfputs(str2,fp);\n向文件写入一个字符串\n\n\nfscanf(fp,“%d”,&amp;num);\n格式化读取数据\n\n\nfprintf(fp,“it is %d”,num);\n向文件格式化输出数据\n\n\nfread(a,sizeof(int),10,fp);\n(重要)二进制读取10个大小为sizeof(int)的元素\n\n\nfwrite(a,sizeof(int),10,fp);\n(重要)二进制写入\n\n\nnum=getw(fp);\n二进制读取一个整数\n\n\nputw(num,fp);\n二进制写入一个整数\n\n\n\n\n文件内部指针相关函数\n\n起始点\n文件开头      SEEK_SET   0\n文件当前位置   SEEK_CUR   1\n文件末尾      SEEK_END   2\n\n\n\n函数\n作用\n返回值\n\n\n\n\nlong offset=ftell(fp);\n得到流式文件中的当前位置。\n成功返回当前文件位置指针相对于文件起始位置的偏移量。错误返回-1。\n\n\nfseek(fp,100L,0);\n改变文件内部位置指针，fseek(文件指针，偏移量，起始点)\n成功0，失败非0。\n\n\nfeof(fp)\n判断是否到达文件结尾\n达到文件末尾，返回非0，否则返回0\n\n\nrewind(fp);\n将文件位置指针重新设置到文件起始位置\n无\n\n\nferror(fp)\n检查文件流错误标志是否被设置\n如果被设置，返回非0，否则返回0\n\n\nclearerr(fp);\n清除文件错误标志和文件结束标志(并不会把指针重置到文件开头)\n无\n\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h>\nint main() {\n    FILE* fp = fopen(\".//test1.txt\", \"a+\");\n    int a = 10;\n    char b[50];\n    fprintf(fp, \"num:%d\\n\", a);\n    rewind(fp);//文件指针重新指向开头，fseek(fp,0,0);\n    fscanf(fp, \"%s\", b);//一般读取一行\n    printf(\"%s\", b);\n    fclose(fp);\n    return 0;\n}\n\n 2. 流的概念\n 【维生素C语言】第十六章 - 文件操作（上）_柠檬叶子C的博客-CSDN博客\n\n 注意\n\n应注意文件指针和文件内部的位置指针不是一回事。\n文件指针是指向整个文件的，须在程序中定义说明，只要不重新赋值，文件指针的值是不变的。\n文件内部的位置指针用以指示文件内部的当前读写位置，每读写一次，该指针均向后移动，它不需在程序中定义说明，而是由系统自动设置的。\n\n 3. 刷题\n 1. 查询\n数据\nxuebi,da,345,6.00  //雪碧，规格，数量，单价\nxianchengduo,zhong,5,4.00 //鲜橙多\nxuebi,xiao,4567,2.00\nxuebi,da,456,6.00\n解题代码\n#include &lt;stdio.h>\n#include &lt;string.h>\nstruct good\n{\n\tchar name[20];\n\tchar type[12];\n\tint number;\n\tfloat price;\n};//用结构体接收二进制文件\n\nint main(void)\n{\n\tint i = 0, n, flag;\n\tchar str[20];\n\tstruct good goods[100];//结构体类型的数组\n\tFILE *fp;\n\tfp = fopen(\"sp.dat\", \"rb\"); //二进制读取\n\twhile (!feof(fp))//到文件尾结束\n\t{\n\t\tfread(&amp;goods[i], sizeof(struct good), 1, fp);//1的意思是1个sizeof()大小\n\t\ti++;\n\t}\n\tn = i;\n\tflag = 0;\n\tprintf(\"Please input shang pin pin ming:\");\n\tscanf(\"%s\", str);//商品名\n\tprintf(\"Output:\\ncha zhao qing kuang:\\n\");\n\tfor (i = 0; i &lt; n; i++)\n\t{\n\t\tif (strcmp(goods[i].name, str)==0)  \n\t\t{\n\t\t\tprintf(\"%s,%s,%d,%.2f\\n\", goods[i].name, goods[i].type,\n\t\t\t\tgoods[i].number, goods[i].price);\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (flag == 0)\n\t{\n\t\tprintf(\"mei you shang pin %s\\n\", str);\n\t}\n\treturn 0;\n}\n\n 2. 读取\n数据\nlb8103a.txt\nabcdefghijklmnopqrstuvwxyz\nlb8103b.txt\nzyxwvutsrqponmlkjihgfedcba\n解题代码\n#include &lt;stdio.h>\n#include &lt;string.h>\nint main(void)\n{\n\tint n,i=0;\n\tchar str[80]={\"C:\\\\Users\\\\21609\\\\Desktop\\\\Cprogramm\\\\\"};\n\tchar ch,a[20];\n\tFILE *fp;\n\tprintf(\"Input filename:\");//输入文件名\n\tscanf(\"%s\",a);\n\tprintf(\"Input n:\");//读取多少个\n\tscanf(\"%d\", &amp;n);\n\tstrcat(str,a);//a拼接到str末尾\n\tfp = fopen(str, \"r\");\n\tprintf(\"Output:\\n\");\n\tif (fp == NULL)\n\t{\n\t\tprintf(\"Open Error!\\n\");\n\t\treturn 0;\n\t}\n\tch=fgetc(fp);\n\twhile(!feof(fp)&amp;&amp;(i&lt;n)){\n\t\tputchar(ch);\n\t\tch=fgetc(fp);\n\t\ti++;\n\t}\nfclose(fp);\n\treturn 0;\n}\n\n","categories":["大一"],"tags":[]},{"title":"python常用库","url":"/2023/08/24/python%E5%B8%B8%E7%94%A8%E5%BA%93/","content":" 常见模块解析\n 1. math库\n 数学函数\n\n\n\n函数\n返回值 ( 描述 )\n\n\n\n\nabs(x)\n返回数字的绝对值，如abs(-10) 返回 10\n\n\nceil(x)\n返回数字的上入整数，如math.ceil(4.1) 返回 5\n\n\ncmp(x, y)\n如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 **Python 3 已废弃，使用 (x&gt;y)-(x。\n\n\nexp(x)\n返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045\n\n\nfabs(x)\n返回数字的绝对值，如math.fabs(-10) 返回10.0\n\n\nfloor(x)\n返回数字的下舍整数，如math.floor(4.9)返回 4\n\n\nlog(x)\n如math.log(math.e)返回1.0,math.log(100,10)返回2.0\n\n\nlog10(x)\n返回以10为基数的x的对数，如math.log10(100)返回 2.0\n\n\nmax(x1, x2,…)\n返回给定参数的最大值，参数可以为序列。\n\n\nmin(x1, x2,…)\n返回给定参数的最小值，参数可以为序列。\n\n\nmodf(x)\n返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。\n\n\npow(x, y)\nx**y 运算后的值。\n\n\nround(x [,n])\n返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。\n\n\nsqrt(x)\n返回数字x的平方根。\n\n\n\n\n 三角函数\nPython的math库包括以下三角函数：(比如：math.sin(math.pi/2))\n\n\n\n函数\n描述\n\n\n\n\nacos(x)\n返回x的反余弦弧度值。\n\n\nasin(x)\n返回x的反正弦弧度值。\n\n\natan(x)\n返回x的反正切弧度值。\n\n\natan2(y, x)\n返回给定的 X 及 Y 坐标值的反正切值。\n\n\ncos(x)\n返回x的弧度的余弦值。\n\n\nhypot(x, y)\n返回欧几里德范数 sqrt(xx + yy)。\n\n\nsin(x)\n返回的x弧度的正弦值。\n\n\ntan(x)\n返回x弧度的正切值。\n\n\ndegrees(x)\n将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0\n\n\nradians(x)\n将角度转换为弧度\n\n\n\n\n 数学常量\n\n\n\n常量\n描述\n\n\n\n\nmath.pi\n数学常量 pi（圆周率，一般以π来表示）\n\n\nmath.e\n数学常量 e，e即自然常数（自然常数）。\n\n\n\n 2. random库\nPython的random库包含以下常用随机数函数：\nimport random\n# 生成一个 [0, 1) 范围内的随机小数\nprint(random.random())\n\n# 生成一个 [1, 10] 范围内的随机整数\nprint(random.randint(1, 10))\n\n# 生成一个 [0, 1] 范围内的随机小数\nprint(random.uniform(0, 1))\n\n# 从序列中随机选择一个元素\nseq = ['apple', 'banana', 'orange']\nprint(random.choice(seq))\n\n# 将序列中的元素随机打乱（shuffle洗牌）\nseq = [1, 2, 3, 4, 5]\nrandom.shuffle(seq)\nprint(seq)\n\n 3. re 模块\n 1. 常用正则表达式\n\n\n\n模式\n描述\n\n\n\n\n\\w\n匹配字母数字及下划线\n\n\n\\W\n匹配非字母数字下划线\n\n\n\\s\n匹配任意空白字符，等价于[\\t,\\n,\\r,\\f]\n\n\n\\S\n匹配任意非空字符\n\n\n\\d\n匹配任意数字，等价于[0-9]\n\n\n\\D\n匹配任意非数字\n\n\n\\A\n匹配以xx字符串开始\n\n\n\\Z\n匹配xx字符串结束，如果是存在换行，只匹配到换行前的结束字符串\n\n\n\\z\n匹配xx字符串结束\n\n\n\\G\n匹配最后匹配完成的位置\n\n\n\\n\n匹配一个换行符\n\n\n\\t\n匹配一个制表符\n\n\n^\n匹配字符串的开头\n\n\n$\n匹配字符串的末尾\n\n\n.\n匹配任意字符, 除了换行符, 当 re.DOTALL 标记被指定时, 则可以匹配包括换行符的任意字符\n\n\n[…]\n用来表示一组字符， 单独列出：[amk] 匹配 ‘a’，‘m’ 或 ‘k’\n\n\n[^…]\n不在 [ ] 中的字符：[^abc] 匹配除了a， b， c之外的字符\n\n\n*\n匹配0个或多个的表达式\n\n\n+\n匹配1个或多个的表达式\n\n\n?\n匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式\n\n\n{n}\n精确匹配n个前面表达式。\n\n\n{n，m}\n匹配n到m次由前面的正则表达式定义的片段，贪婪方式\n\n\nalb\n匹配a或b\n\n\n()\n匹配括号内的表达式，也表示一个组\n\n\n\n注意：[ ]所有的特殊字符在字符集中都失去其原有的特殊含义,在字符集中如果要使用]、-或^，可以在前面加上反斜杠，或把]、-放在第一个字符，把^放在非第一个字符\n 2. 常用函数\n\n\n\n函数\n说明\n\n\n\n\nre.match( )\n从字符串的起始位置匹配, 匹配成功, 返回一个匹配的对象, 否则返回None\n\n\nre.search( )\n扫描整个字符串并返回第一个成功的匹配\n\n\nre.findall( )\n在字符串中找到正则表达式所匹配的所有子串, 并返回一个列表, 如果没有找到匹配的, 则返回空列表\n\n\nre.split( )\n将一个字符串按照正则表达式匹配结果进行分割, 返回列表类型\n\n\nre.finditer( )\n在字符串中找到正则表达式所匹配的所有子串, 并把它们作为一个迭代器返回\n\n\nre.sub( )\n把字符串中所有匹配正则表达式的地方替换成新的字符串\n\n\nre.complie( )\n将正则表达式传入, 返回一个匹配对象, 一般与其他方法组合使用\n\n\n\n 3. 正则匹配使用示例\nprint(\"hello\".replace(\"llo\",\"ooo\"))  # heooo\nprint(\"hello\".find(\"abcd\"))  # -1 (找不到返回 -1)\nprint(\"hello\".find(\"he\"))    # 0\n\nimport re\nprint(re.findall(\"\\w\",\"ab* 12$ _\"))  # ['a', 'b', '1', '2', '_']\nprint(re.findall(\"\\s\",\"ab* 12$ _ \"))  # [' ', ' ', ' ']\nprint(re.findall(\"\\Aab\",\"ab* 12$ _\"))  # ['ab']\nprint(re.findall(\"\\Aaa\",\"ab* 12$ _\"))  # [] 没匹配到为空\nprint(re.findall(\"_\\Z\",\"ab* 12$ _\"))   # ['_']\nprint(re.findall(\"0\\Z\",\"ab* 12$ _\"))   # [] 没匹配到为空\nprint(re.findall(\"\\t\",\"ab* 12$ \\t_\"))    # ['\\t']\n#\"\\s\" 可以匹配\"\\t\"和\"\\n\"\nprint(re.findall(\"^ab\",\"ab* 12$ _\"))   # ['ab']\nprint(re.findall(\"_$\",\"ab* 12$ _\\n\"))  # ['_']\n\n重复匹配\n#.匹配任意一个字符\nimport re\nprint(re.findall(\"a.b\",\"a\\tb\")) # ['a\\tb']\nprint(re.findall(\"a.b\",\"a\\nb\")) # [] (换行符匹配不到,匹配为空)\nprint(re.findall(\"a.b\",\"a b a*b abb a_b\")) # ['a b', 'a*b', 'abb', 'a_b']\nprint(re.findall(\"a.b\",\"a\\nb\",re.S))     # ['a\\nb'] (加入参数, 包含换行)\nprint(re.findall(\"a.b\",\"a\\nb\",re.DOTALL))   # ['a\\nb'] (同上效果一样)\n\n#* 匹配前面那个字符0个或者n个\nprint(re.findall(\"a*\",\"aaaa aa\"))# ['aaaa', '', 'aa', ''] (零个或多个a)\nprint(re.findall(\"ab*\",\"abab aa\"))# ['ab', 'ab', 'a', 'a'] (一个a零个或多个b)\nprint(re.findall(\"a*b\",\"ababaaaba aa\")) # ['ab', 'ab', 'aaab'] (零个或多个a一个b)\nprint(re.findall(\"ab*\",\"bbbbbbbb\"))  # [] (没有匹配到一个a零个或多个b)\n\n#? 匹配前面那个字符0个或者1个\nprint(re.findall(\"ab?\",\"a\"))     # ['a']，匹配1个a，0个b\nprint(re.findall(\"ab?\",\"abbb\"))  # ['ab']\n\n#{n,m} 匹配n~m个\nprint(re.findall(\"a{2}\",\"aaaa\"))     # ['aa', 'aa']\nprint(re.findall(\"ab{2,6}\",\"abbb\"))  # ['abbb'] (一个a,2~6个b)\nprint(re.findall(\"ab{1,}\",\"abbb\"))   # ['abbb'] (相当于 ab+)\nprint(re.findall(\"ab{0,}\",\"abbb\"))   # ['abbb'] (相当于 ab*)\n\n#[ ]逐个匹配\nprint(re.findall(\"a[*1_c-]b\",\"a*ba1b a_baaba-b\")) # ['a*b', 'a1b', 'a_b', 'a-b']\nprint(re.findall(\"a[^a-zA-Z0-9]b\",\"a*banb aPbaa7b\"))  # ['a*b'] (非a~z,A~Z,0~9)\n\n#( )分组\nprint(re.findall('ab+','ababab123')) # ['ab', 'ab', 'ab']\nprint(re.findall('(ab)+123','ababab123')) # ['ab']，匹配到末尾的 ab123 中的 ab\nprint(re.findall('(?:ab)+123','ababab123')) \n#['ababab123']， findall的结果不是匹配的全部内容，而是组内的内容, ?: 可以让结果为匹配的全部内容,详见非捕获匹配\nprint(re.findall('href=\"(.*?)\"','&lt;a href=\"http://www.baidu.com\">点击&lt;/a>'))# ['http://www.baidu.com']\nprint(re.findall('href=\"(?:.*?)\"','&lt;a href=\"http://www.baidu.com\">点击&lt;/a>&lt;a href=\"http://www.aiqiyi.com\">点击2&lt;/a>'))\n# ['href=\"http://www.baidu.com\"', 'href=\"http://www.aiqiyi.com\"']\n\n\nprint(re.findall(\"a\\.b\",\"a1b a.b\"))  # ['a.b']\nprint(re.findall(\"shawn|song\",\"shawn is man song is shawn\"))  # ['shawn', 'song', 'shawn']\nprint(re.findall(\"A(?:abc|cba)A\",\"AabcA\"))  # ['AabcA']\nprint(re.findall(\"com(?:puter|e)\",\"come on! Here is a computer \"))  # ['come', 'computer']\n\n#匹配所有数字\nprint(re.findall(\"\\d+\\.?\\d*\",\"12as3.45qw2k7\"))  # ['12', '3.45', '2', '7']\n\n贪婪匹配.*与懒惰匹配.*?\nprint(re.findall(\"a.*b\",\"a11b22222b33\"))  # ['a11b22222b']\nprint(re.findall(\"a.*?b\",\"a11b22222b3\"))  # ['a11b']\n\n 4. 方法示例\n#re.findall(pattern,string)\n\t#在字符串中找到正则表达式所匹配的所有子串, 并返回一个列表, 如果没有找到匹配的, 则返回空列表\nprint(re.findall(\"(ab)+(cd)+\",\"ababcdcd abcd\"))\n\t#[('ab', 'cd'), ('ab', 'cd')]，返回元组列表\n\n#re.search()\n\t匹配整个字符串, 只到找到第一个匹配然后返回一个包含匹配信息的对象(re.Match对象)\n\t该对象可以通过调用 group()方法得到匹配的字符串,如果字符串没有匹配，则返回None\n\t如果没有匹配到值就调用 group() 方法, 抛出异常\nprint(re.search(\"abc\",\"112abc333abc\"))  \n\t# &lt;re.Match object; span=(3, 6), match='abc'>\nprint(re.search(\"abc\",\"112abc333abc\").group())  # abc\n\nprint(re.search(\"abcd\",\"12abc333abc\"))          # None\nprint(re.search(\"abcd\",\"12abc333abc\").group()) \n\t# 报错 \"AttributeError\" 因为没拿到这个对象,所以没有group()属性\n\n#re.match()\n\t与 re.search 功能相同, 但必须匹配起始位置, 不然返回 None\nprint(re.match(\"abc\",\"abc22abc\"))  \n\t# &lt;re.Match object; span=(0, 3), match='abc'>\nprint(re.match(\"abc\",\"abc22abc\").group())  # abc\nprint(re.match(\"abc\",\"1abc22abc\"))  # None\n\n#re.split()\n\t以规定字符作为分隔符对字符串进行切分, 切分结果放入列表, 没匹配到返回原字符串列表\n    将规定字符放入 [ ] 则是逐个匹配\nprint(re.split(\"ab\",\"abcoababcoabc\"))  #['', 'co', '', 'co', 'c']\nprint(re.split(\"a\",\"nbc\")) #['nbc']，返回原字符串\nprint(re.split(\"[ob]\",\"abcoabcoabc\"))  # ['a', 'c', 'a', 'c', 'a', 'c']\n\n#re.sub()和re.subn()\n\t匹配字符, 并将其该成指定字符, 返回改变后的字符串, 后面可跟个数参数, 不指定默认替换所有\n\tre.subn( ) 返回一个元组, 第二个元素返回的是替换的个数\nprint(re.sub(\"a\",\"AA\",\"i am a man\"))  # i AAm AA mAAn\nprint(re.sub(\"a\",\"AA\",\"i am a man\",100))  # i AAm AA mAAn，不报错\nprint(re.subn(\"a\",\"A\",\"i am a man\"))  # ('i Am A mAn', 3) (显示替换的个数)\n\n#re.compile()  \t返回一个对象\nobj=re.compile(\"\\d{2}\")\nprint(obj) # re.compile('\\\\d{2}')\nprint(obj.findall(\"ab123bc123\")) #['12', '12']\nprint(obj.search(\"ab123bc123\").group())\t# 12\nprint(obj.match(\"123ab123bc123\").group())\t# 12\n\nsubstitude 替换\n 5. 非捕获匹配?: ?! ?=\n\n# ?:\n\t(?:)非捕获分组，只会进行单纯的模式匹配并不会将匹配到的值进行保存，与()区分\nprint(re.findall(\"jk(loli)+\",\"jkloli\")) # ['loli']\nprint(re.findall(\"jk(?:loli)+\",\"jkloli\")) # ['jkloli']\n\n# ?!\t正向否定预查\n\t1.在没匹配到字符串的前提下，再进行后续的正则，后续匹配仍然从被匹配字符串的头开始\nres = re.match(\"(?![\\d]+$)(?![a-zA-Z]+$)[\\da-zA-Z]{6}$\",passwd)\n\t#匹配6位数字与字母组合，不能纯数字或字母\n    2.匹配位置 后面 不能跟着指定表达式。\nprint(re.findall(\"19(?!99)\",\"1999\"))\nprint(re.findall(\"\\d{2}(?!99)\",\"1999 1988\"))#['99', '19', '88']\n\t#先尝试匹配\"1999\"，再'999 '(成功)，再\"9 19\"，再\" 198\"，再\"1988\"(成功)，再\"88\",理解下匹配的窗格移动\n    \n# ?=  正向肯定预查\n\t1.在匹配到字符串的前提下，再进行后续的正则，后续匹配仍然从被匹配字符串的头开始\nres = re.search(\"(?=.*[\\d])(?=.*[a-z])(?=.*[A-Z])(?=.*)(?=.*[!@#%&amp;])^([\\da-zA-Z!@#%&amp;]{7,})$\",passwd)\n\t#至少七位密码，包含大小写，数字，特殊字符(!,@,#,%,&amp;)\n    \n    2.匹配位置 后面 必须跟着指定表达式。\nr\"foo(?=bar)\"可以匹配foobar中的foo，不能匹配foobaz中的foo\n    \n\n# ?&lt;=\n\t匹配位置 前面 必须跟着指定表达式。\nprint(re.findall(\"(?&lt;=jk).*?(?=li)\",\"mcjli jkloli liejk\"))   #['lo']\n\n# ?&lt;!\n\t匹配位置 前面 不能跟着指定表达式。\n\tprint(re.findall(\"\\\\B(?&lt;!18)\\d{2}\\\\b\",\"1988  1899\")) #['88']\n\t\n\n 6. 边界匹配问题\n\\b表示单词边界，\\B表示非单词边界\n\n一般空格、换行、标点符号或者特殊符号来表示边界\n\n\n或者说非数字、字母、下滑线、unicode汉字表示边界\n\n\n中文字符串为边界的话要用re.A编码模式\n\nprint(re.findall(\"\\\\b19(?:[^9]{2})\\\\b\",\"1999  1988\")) #['1988']\n\nprint(re.findall(\"\\\\b19(?:[^9]{2})\\\\b\",\"你也玩1999?1988带我一个\",re.A))\n\t# ['1988']\n\n 4. request模块\n吐槽：b站王道的计算机网络好水。\n 5. time库\n","categories":["计算机语言基础"],"tags":["python"]},{"title":"测试","url":"/2023/08/24/%E6%B5%8B%E8%AF%95/","content":" 测试\nhello world!\n","categories":["测试"],"tags":[]},{"title":"数据库原理mysql版","url":"/2023/08/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86mysql%E7%89%88/","content":" 数据库原理\nBy：jkloli\n参考资料：\nmysql_note/README.md at main · Buildings-Lei/mysql_note · GitHub\nMySQL - 智云知识 (dhc.pythonanywhere.com)\nhttp://t.csdn.cn/jM0hE  CiCi喜之郎\nhttp://t.csdn.cn/XolDf 粉红色的Pig\n…\n 0. 问题解决\n\n\nmysql命令行不要忘了;\n\n\nmysql命令行注释-- \n\n\nzerofill要在not null前面\n\n\nmysql中``用于引用数据库对象，防止歧义。''用于引用字符串对象。\n\n\n''空串不是null\n\n\n给字符类型赋值，右侧一定要打双引号或单引号\n\n\n同一个数据库中表名不能重复。\n\n\n条件判断时逻辑判断\n\n\n-- 不等于其中一个就行\nselect sno from s where  s.sno!=any(select sc.sno  from sc)  order by sno asc;\n-- 不等于任何一个\nselect sno from s where  s.sno!=all(select sc.sno  from sc)  order by sno asc;\nselect sno from s where not s.sno=any(select sc.sno  from sc)  order by sno asc;\nselect sno from s where  s.sno not in (select sc.sno  from sc)  order by sno asc;\n\n\nmysql数据库备份记得用cmd，而不是power shell\ncmd记得chcp 65001，防止中文字符串乱码\n\n 1. 环境配置\n0 系统是win11\n1 先安装navicat，mysql。(知乎，csdn教程)\n2 配置用户和系统环境变量（mysql.exe路径），直接置顶\n\n3 windows以管理员方式开终端\nnet stop MySQL80 \n#停止服务\nnet start MySQL80 \n#开启服务\nchcp 65001 \n#临时改命令行编码为utf-8\nmysql -h \"127.0.0.1\" -uroot -p  \n#登录MYSQL\nmysql>ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';\n#修改用户密码为123456\nmysql> exit \n#退出mysql\nnet stop MySQL80 \n#停止服务\n\n 2. 概述\n 1. 一些概念\n 比较细碎的1\n从数据管理角度分析，数据库的发展可以分为三个阶段：\n\n人工管理阶段 20世纪50年代中期之前\n\n\n文件系统阶段 20世纪50年代中期到60年代中期\n\n\n数据库系统阶段 20世纪60年代后期\n\n数据(Data)：描述事物的符号记录。数据与语义是分不可开的。\n数据库(DataBase)：是长期存储在计算机内，有组织，可共享的大量数据的集合。\n​\t特点：较小的冗杂度，较高的数据独立性和多扩展性。\n数据库管理系统（DataBase Management System，DBMS）：位于用户应用与操作系统之间的一层数据管理软件。\n数据库系统（DBS）：是由数据库，数据库管理系统（及应用开发工具），应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统。\n​\t特点：1. 数据结构化 2. 数据的共享性高，冗余度低且易扩充 3. 数据独立性高 4. 数据由数据库管理系统统一管理和控制。\n 信息世界基本概念\n实体（行/记录/元组）：是客观存在并可以相互区别的事物，对应数据表中的一行“记录”。如：“张三”。\n属性（列/字段）：是事物本身固有的性质，对应数据表中的“字段”或“列”。如：“姓名”。\n码(key)：唯一标识实体的属性集。主键也叫主码。如：学生(学号(主键),姓名,班级)。\n实体型：用实体名及其属性名集来抽象和刻画同类实体。如：学生(学号,姓名)\n实体集：同一类型实体的集合。如：全体同学。\n联系：一对一，一对多，多对多。\n 数据模型\n数据模型：分为概念模型(层次模型)，逻辑模型，物理模型。\n​\t逻辑模型：按计算机系统的观点对数据建模，用于DBMS实现。\n​    物理模型：描述数据在系统内(磁盘上)的表达方式和存储方式。\n数据模型的组成要素：数据结构，数据操作，数据的完整性约束条件。\n数据独立性：物理独立性，逻辑独立性。\n​\t物理独立性：用户的应用程序与数据库中数据的物理存储是独立的。比如内模式。\n​\t逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。比如外模式。\n第一代数据模型：层次模型(树状结构)，网状模型(网状)\n第二代数据模型：关系模型\n 比较细碎的2\n关系模型：建立在集合代数基础上的数据模型。\n​\t术语：\n\n\n\n\n\n\n\n\n\n\n关系名(表名)\n关系模式(表头)\n关系(二维表)\n\n\n元组(记录/行)\n属性(列)\n属性名(列名)\n\n\n属性值(列值)\n分值(一条记录中的一个列值)\n非规范关系(表中有表)\n\n\n\n关系的完整性约束条件:实体完整性，参照完整性，用户定义完整性。\n​\t实体完整性：主码非空且不重复。\n​\t参照完整性：外键不为空(或均为空值)。\n​\t用户定义完整性：用户定义的完整性约束条件。\n三级模式结构：外模式，模式，内模式。\n​\t外模式可以多个，模式和内模式只能一个。\n数据表与数据库\n数据表就是记录的集合 。\n数据库就是数据表、数据库关系和数据库关系对象的集合。\n在数据库连接中，默认的数据库：\ninformation_schema：提供了访问数据库元数据的方式。\nmysql：是mysql的核心数据库。\nperformance_schema ：主要用于收集数据库服务器性能参数。\ntest ： mysql创建的测试库。\n笛卡尔乘积\n\n 2. E-R图\nE-R图，也称为实体关系图，用于显示实体集之间的关系。\n实体： 用矩形框表示，将实体名写在框内。\n属性： 用椭圆框表示，将属性名写在框内，用连线将实体与属性连接。\n联系： 用菱形框表示，将联系名写在框内，用连线将相关的实体连接，并在连线旁标注联系类型(一 0 对 一 “1：1”、一对多 “1：n”、多对多 “n：m”)。\n\n 3. 数据库类型\n在文件中读写数据速度相对较慢，所以现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。\n数据库可以分为关系型数据库和非关系型数据库。\n所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。\nRDBMS即关系数据库管理系统(Relational Database Management System)的缩写。\n特点：\n\n\n· 数据以表格的形式出现\n\n\n· 每行为各种记录名称\n\n\n· 每列为记录名称所对应的数据域\n\n\n· 许多的行和列组成一张表\n\n\n· 若干的表组成database\n\n\n关系型数据库：表与表之间存在对应关系。\n非关系型数据库：表之间不存在关系，数据独立，随便存。\n 4. 常见的数据库管理系统\noracle:在全球范围内市场份额占据32%\nsql server: 在我国，.net平台和sql server数据库应用也极其广泛\nSybase: 广泛应用于我国的大中型应用软件中\nIBM/DB2:在OS/2和windows系统中应用广泛\nmysql:简单，开源，功能强大\n 5. MySQL介绍\n​\tMySQL是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n\nMysql是开源的，所以你不需要支付额外的费用。\n\n\nMysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n\n\nMySQL使用标准的SQL数据语言形式。\n\n\nMysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。\n\n\nMySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。\n\n\n 6. SQL概述\nSQL(Structured Query Language),即结构化查询语言，是高级的非过程化编程语言。SQL是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系型数据库系统。\nSQL分类：\n数据查询语言（Data Query Language） DQL\n数据操纵语言（Manipulation）DML\n数据定义语言（Definition）DDL\n数据控制语言（Control）DCL\n实际上不同数据库系统之间的SQL不能完全相互通用。\n 2. navicat基础操作\n 1. 使用navicat创建数据库\n1.先在命令行启动服务net start MySQL80   (一般已经启动了)\n2.然后开navicat，连接测试，然后点确定。\n\n3.右键连接名，选新建数据库（或命令行界面）\n\n4.选阉割版的utf-8字符集，下面那个选大小写不敏感。\n\nutf8mb3 ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。\nutf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。\n\n在utf8mb4下，英文占1个字符，中文3个，特殊符号4个.\n\n 2. 修改字段属性\n\n右键点击需要修改的表，选择「设计表」，然后在右侧编辑字段属性\n 3. 添加数据\n打开表后在左下角有加号。\n快捷键：insert添加记录，ctrl+s保存记录。\n 4. 查询表\n\n 5. 备份和还原数据库\n\n\n选中要备份的数据库—&gt;右键—&gt;转储SQL文件—&gt;结构和数据：\n\n\n成功则可以生成一个sql文件，然后在另一个空的数据库-&gt;右键\n\n\n-&gt;运行SQL文件。\n\n数据库右键-&gt;刷新。\n\n 3. 数据类型\n 1. 数字类型\n整数类型\n二进制,有符号数,首位为1的是负数,首位为0的是正数。\n\n\n\n数据类型\n字节数\n无符号数的取值范围\n有符号数的取值范围\n\n\n\n\nTINYINT\n1\n0~255(2^8-1)\n- 128 ~ 127\n\n\nSMALLINT\n2\n0~65 535\n- 32 768 ~ 32 767\n\n\nMEDIUMINT\n3\n0~16 777 215\n- 8 388 608 ~ 8 388 607\n\n\nINT\n4\n0~4 294 967 295\n- 2 147 483 648 ~ 2 147 483 647\n\n\nBIGINT\n8\n0 ~ 18 446 744 073 709 551 615\n- 9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807\n\n\n\n浮点数\n比如：price double(5,2)可以表示-222.22\n\n\n\n数据类型\n字节数\n负数的取值范围\n非负数的取值范围\n\n\n\n\nFLOAT\n4\n－3.402 823 466E + 38 ～－1.175 494 351E－38\n0 和 1.175 494 351E－38～3.402 823 466E+38\n\n\nDOUBLE\n8\n－1.797 693 134 862 315 7E + 308 ~ －2. 225 073 858 507 201 4E－308\n0 和 2.225 073 858 507 201 4E－308～1.797 693 134 862 315 7E + 308\n\n\n\n定点数类型\n包括decimal和numeric。\nDECIMAL(M,D) 设置精度（总位数）和标度（小数点后位数）。\n其中，M表示数字总位数（不包括“.”和“-”)，最大值为65，默认值为10；D最大值为30，默认值为0。\n例如，DECIMAL(5，2) 表示的取值范围是 －999.99～999.99。\n\n\n若小数部分超出范围，会进行四舍五入，并出现 Data truncated(数据截断) 警告。\n\n\n若整数部分超出范围，会报错。\n\n\n 2. 事件和日期类型\n\n\n\n数据类型\n取值范围\n日期格式\n零 值\n\n\n\n\nYEAR\n1901 ~ 2155\nYYYY\n0000\n\n\nDATE\n1000-01-01 ~ 9999-12-3\nYYYY-MM-DD\n0000-00-00\n\n\nTIME\n－838:59:59 ~ 838:59:59\nHH:MM:SS\n00:00:00\n\n\nDATETIME\n1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n0000-00-00 00:00:00\n\n\nTIMESTAMP\n1970-01-01 00:00:01 ~ 2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n0000-00-00 00:00:00\n\n\n\n如果插入的数值不合法，系统会自动将对应的零值插入数据库中。\n\n\n用1901或&quot;1901&quot;表示1901年\n\n\n若是YY表示年，其中'00'~'69' 的值会被转换为2000~2069的值，70'~'99' 的值会被转换为 1970~1999 的值\n\n\n当使用 YEAR 类型时，一定要区分 '0' 和 0。因为字符串格式的 '0' 表示的 YEAR 值是 2000，而数字格式的 0表示的 YEAR 值是 0000 。\n\n\n 3. 字符串类型\n文本字符串\n\n\n\n数据类型\n类型说明\n储存需求\n\n\n\n\nCHAR(M)\n固定长度字符串\nM个字符，M区间[0,255]\n\n\nVARCHAR(M)\n可变长度字符串\nL+1个字节。M取值与字符集有关，不超过65535字节\n\n\nTINYTEXT\n非常小的\nL+1字节，L&lt;2^8\n\n\nTEXT\n小的非二进制字符串\nL+2字节，L&lt;2^16\n\n\nMEDIUMTEXT\n中等大小的\nL+3字节，L&lt;2^24\n\n\nLONGTEXT\n非常大的\nL+4字节，L&lt;2^32\n\n\nENUM(‘value1’,‘v2’)\n枚举类型\n1或2个字节，取决于枚举值的个数（&lt;=65535）\n\n\nSET(‘v1’,‘v2’)\n一个集合，字符串对象可以有零个或多个集合成员\n1,2,3,4或8个字节，取决于set成员数目(最多64)\n\n\n\nvarchar\n\nvarchar(10)插入超出10个会报错。\nvarchar(4)可以插入&quot;abcd&quot;\n需要额外的1个或2个字节记录字符串的长度，字符串长度小于255字节使用1个字节，否则使用2个。\n\n当定义一个字段类型为 varchar(10)，插入的值为&quot;abc&quot;这一字符串时，那么实际存储大小为3个字节，除此之外，varchar还需要使用1个额外字节（因为‘abc’字节数＜255）来记录字符串的长度。\nchar\n\n长度不够时内部储存用空格填充。\nname char(3)可以存放&quot;abc&quot;\nchar(3)超过三个字符会报错。\n\n另外\n\n在创建表时，char和varchar需要指定长度，但是text，tinytext，mediumtext，longtext数据类型不需要指定长度。\n\n二进制字符串\n\n\n\n数据类型\n说明\n储存需求\n\n\n\n\nBIT(M)\n位数据类型\n(M+7)/8字节，M区间[1,64]\n\n\nBINARY(M)\n固定长度的二进制字符串\nM字节\n\n\nVARBINARY(M)\n可变长度的二进制字符串\nM+1字节\n\n\nTINYBLOB(M)\n非常小的\nL+1字节，L&lt;2^8\n\n\nBLOB(M)\n二进制大对象（Binary Large Object）\nL+2字节，L&lt;2^16\n\n\nMEDIUMBLOB(M)\n中等大小的\nL+3字节，L&lt;2^24\n\n\nLONGBLOB(M)\n非常大的\nL+4字节，L&lt;2^32\n\n\n\nBLOB一般用来存图片。\n 4. JSON数据类型\n略。\n 4. SQL分类详解\n 1. DDL 数据定义语言\n 1. 数据库操作\n#查看数据库\nmysql>show databases;\n\n#创建数据库db1\ncreate database db1;\n#创建数据库并设置编码格式\ncreate database db9 character set gb2312;\n#删除数据库db1\ndrop database db1;\n\n/*使用名为mysql数据库*/\nuse mysql;\n\nselect database();    -- 显示当前所使用的数据库\nshow create database 数据库名;   -- 查看这个数据库的建库语句；\n\n\n 2. 表操作（重要）\n注意：\n\n创建表名不超过64字符，不重名(mysql表名不区分大小写)。\n表名为mysql关键字时需要用反引号，比如create\n同一表中不能有重名字段。\n\n显示当前数据库内所有的表名\nshow tables;\n查看建表语句\nshow create table 表名;\n查看user数据表的结构（主要看类型）\ndesc user;\n创建新表\ncreate table 表名( \n字段名 类型(长度),\n字段名 类型(长度)\n);\n添加字段：\nALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];\n修改数据类型：\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n修改字段名和字段类型：\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];\n删除字段：\nALTER TABLE 表名 DROP 字段名;\n修改表名：\nALTER TABLE 表名 RENAME TO 新表名\n删除表：\nDROP TABLE [IF EXISTS] 表名;\n删除表，并重新创建该表：\nTRUNCATE TABLE 表名;\n实际操作\n\n-- 创建新表\ncreate table teacher(\nid int(10) primary key auto_increment comment \"编号\", -- 编号 类型 主键 自增 注释表名 注释\nname varchar(10) unique,-- 不重复\nage int(10) zerofill not null  ,-- 宽度不够则左侧补0,非空\nclassId int(10) unsigned default 1 -- 这里不要打逗号，默认1\n)engine=innodb,charset=utf8;\ndrop table teacher; -- 删除新表\n\nint(3)表示最大宽度（显示宽度）为3，比如666，-666。\n\n\n若数值的位数小于显示宽度，会填充空格，若大于显示宽度，则不影响显示结果。\n\n\n设置零填充后，字段自动设为无符号类型，这是因为负数不能使用负填充。\n\n\nzerofill要在not null前面\n\n\nalter table test2 add id int(10);\nalter table test2 modify name varchar(20);\nalter table test2 change id age int(10);\nalter table test2 drop age;\nalter table test2 rename to test3;\ntruncate table test3;\ndrop table if exists test3;\n\n\n注意如果已经存了char数据，修改成int参数类型会报错。\nint类型储存的int数据可以转换成char类型。\n\n 2. DML（数据操作语言）\n 1. 添加数据 insert\n指定字段：\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);\n全部字段：\nINSERT INTO 表名 VALUES (值1, 值2, ...);\n批量添加数据：\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);\nINSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);\n 注意事项\n\n字符串和日期类型数据应该包含在引号中\n插入的数据大小应该在字段的规定范围内\n\n 2. 更新和删除数据update,delete\n修改数据：\nUPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];\n删除数据：\nDELETE FROM 表名 [ WHERE 条件 ];\ninsert into teacher value(1,\"gg\",56,3);\ninsert into teacher value(2,\"bfb\",56,3);\ndelete from teacher where id=2;\nupdate teacher set name = 'mom' WHERE id = 1;\n-- 给字符类型赋值，右侧一定要打双引号或单引号。\nselect * from teacher;\n\n\n 3. DQL（数据查询语言）\n关键字书写顺序\nSELECT 字段列表\nFROM 表名字段\nWHERE 条件列表\nGROUP BY 分组字段列表\nHAVING 分组后的条件列表\nORDER BY 排序字段列表\nLIMIT 分页参数\n\n关键字执行顺序\nFROM&gt; WHERE &gt; GROUP BY &gt;having&gt; SELECT &gt; ORDER BY &gt;limit\n 1. 基础查询 select\n查询多个字段：\nSELECT 字段1, 字段2, 字段3, ... FROM 表名;\nSELECT * FROM 表名;\n设置别名：\nselect `name` as '名字' from teacher; -- 名字是别名\nselect `name`  '名字' from teacher; -- 只改变显示，不改字段名\n\n去除重复记录：\nSELECT DISTINCT 字段列表 FROM 表名;\n转义：\nSELECT * FROM 表名 WHERE name LIKE '\\_张三' ESCAPE '\\'\n\\ 之后的_不作为通配符\nselect distinct age from teacher;\n-- 可以匹配_xx\nselect name from user where name like '\\_%' ;\n\n 2. 条件查询 where\n语法：\nSELECT 字段列表 FROM 表名 WHERE 条件列表;\n条件：\n> >= &lt; &lt;= = \n&lt;>或!=\nbetween ... and ... -- 比如between 10 and 20,在[10,20]区间内\nin(...) -- 多选一,比如in(20,35,40)\nlike 占位符 -- 模糊匹配\nis null -- 是空\nis not null -- 非空\n&amp;&amp; 或 and -- 且\n|| 或 or -- 或\n! 或 not -- 非\n\nmysql常用通配符\n\n\n%表示任何字符出现任意次数（包括0次）\n\n\n_表示匹配一个字符。\n\n\n-- 可以匹配abc,ABC(忽略大小写)\nSELECT * from test1 where name like '%B%';\n-- 可以匹配ABC(加了binary不忽略大小写)\nSELECT * from test1 where binary name like '%B%';\n-- 不匹配a\nSELECT * from test1 where binary name like 'a_';\n\n 3. 聚合查询count,avg…\n常见聚合函数：\n\n\n\n函数\n功能\n\n\n\n\ncount()\n统计数量\n\n\nmax()\n最大值\n\n\nmin()\n最小值\n\n\navg()\n平均值\n\n\nsum()\n求和\n\n\n\n例：\nselect count(*)id from test1 where age between 1 and 5 having id>3;-- count(*)id等价于count(id)\n\n 4. 分组查询group by\n相关函数：avg平均,count计数,sum总和,max最大,min最小\ngroup by分组之后可能出现一个单元格有多个值并报错。比如分组后name为aa的一行中，id同时有1和2。一般需要用聚合函数或group_concat解决。\n语法：\nSELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];\n例如：\nselect group_concat(`name`),`age` from test1 group by `age`;\n\nwhere 和 having 的区别：\n\n执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。\n判断条件不同：where不能对聚合函数进行判断，而having可以。\n\nselect s.sno as \"学号\",s.sn as \"姓名\",avg(sc.score) as \"平均成绩\" from s,sc,c  where  sc.sno=s.sno    group by sc.sno having avg(sc.score)>80 order by s.sno asc;\n\n 5. 排序查询order by\n语法：\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;\n排序方式：\n\nASC: 升序（默认）\nDESC: 降序\n\n注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n 6. 分页查询limit\n语法：\nSELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;\n例子：\n-- 查询第一页数据，展示10条\nSELECT * FROM employee LIMIT 0, 10;\n\n 注意事项\n\n起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数\n分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT\n如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 100\n\n 实际操作\n\n\n\n\n\n 4. DCL\n 1. 管理用户\n查询用户：\nUSE mysql;SELECT * FROM user;\n\n创建用户:\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n修改用户密码：\nALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';\n删除用户：\nDROP USER '用户名'@'主机名';\n\n主机名可以使用 % 通配\n\n-- 只能主机localhost访问\ncreate user 'user2'@'localhost' identified by '123456';\n-- 任意主机访问\ncreate user 'user3'@'%' identified by '123456';\ncreate user 'user4' identified by '123456';\n-- 修改密码\nalter user 'user2'@'localhost' identified with mysql_native_password by '123';\n-- 删除用户\ndrop user 'user2'@'localhost';\n\n 2. 权限控制\n常用权限：\n\n\n\n权限\n说明\n\n\n\n\nALL, ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库/表/视图\n\n\nCREATE\n创建数据库/表\n\n\nUSAGE\n不优先\n\n\n\n查询权限：\nshow grants for '用户名'@'主机名';\n授予权限：\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\n撤销权限：\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n\n多个权限用逗号分隔\n授权时，数据库名和表名可以用 * 进行通配，代表所有\n\nshow grants for 'user2'@'localhost';\nGRANT SELECT, INSERT ON db1.test1 TO 'user2'@'localhost'; \nGRANT USAGE ON *.* TO `user2`@`localhost`;\nrevoke select,insert on db1.test1 from `user2`@`localhost`;\n\n 5. mysql正则表达式\n\n\n\na{5}\na只能出现5次\n\n\n\n\na{1,3}\na取值范围[1,3]\n\n\n[charlist]\n字符列中的任何单一字符\n\n\n[^charlist] 或 [!charlist]\n不在字符列中的任何单一字符\n\n\n[1]\n以charlist开头的列\n\n\nX$\n表示以字母 X 结尾的字符串。\n\n\n.\n匹配任何一个字符，包括回车、换行等\n\n\nx*\nx{0,}。星号匹配 0 个或多个字符，在它之前必须有内容。\n\n\nx?\nx{0,1}。问号匹配 0 次或 1 次。('baa?na’匹配一个a或者0个a)\n\n\nx+\nx{1,}加号匹配 1 个或多个字符，在它之前也必须有内容。\n\n\n(abc)*\n匹配任意多个abc（包括空串)\n\n\n*?\n(懒惰)重复任意次，但尽可能少重复\n\n\n.*\n(贪婪)尽可能多匹配\n\n\n下面在mysql里需要两条反斜杠（大小写敏感）\n\n\n\n\\w\n匹配字母或数字或下划线或汉字\n\n\n\\s\n匹配任意的空白符\n\n\n\\d\n匹配数字\n\n\n\\b\n匹配单词的开始或结束（\\blove\\b匹配&quot;i love you&quot;中的love）\n\n\n\\W\n匹配任意不是字母，数字，下划线，汉字的字符\n\n\n\\S\n匹配任意不是空白符的字符\n\n\n\\D\n匹配任意非数字的字符\n\n\n\\B\n匹配不是单词开头或结束的位置\n\n\n\n\n\nMySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。(regular-expression)\n\n\n正则表达式默认不区分大小写。\n\n\n-- 查询找到所有名称以元音开始和 ok 结束的:\nSELECT name FROM tb1 WHERE name REGEXP '^[aeiou]|ok$';\n-- 匹配元素是1-3个a，可以匹配a,aa,aaa\nSELECT name FROM test1 WHERE name REGEXP '^a{1,3}$';\n-- 匹配元素含有1-3个a，可以匹配aaaa\nSELECT name FROM test1 WHERE name REGEXP 'a{1,3}';\n\n 6.函数\n 1. 字符串函数\n-- 拼接,HelloWorld\nSELECT CONCAT('Hello', 'World');\n-- 小写,hello\nSELECT LOWER('Hello');\n-- 大写,HELLO\nSELECT UPPER('Hello');\n-- 左填充,---01\nSELECT LPAD('01', 5, '-');\n-- 右填充,01---\nSELECT RPAD('01', 5, '-');\n-- 去除两边空格,Hello World\nSELECT TRIM(' Hello World ');\n-- 切片（起始索引为1）,Hello\nSELECT SUBSTRING('Hello World', 1, 5);\n-- 替换，结果是http:www.google.com.cn\nSELECT REPLACE('http://www.google.com.cn/','/','');\n-- 类型转换 下面浮点数转字符串\ncast(3.14 as char(4))\nconvert(3.14,char(4))\n\n 2. 数值函数\n\n\n\n函数\n功能\n\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x, y)\n返回x/y的模\n\n\nRAND()\n返回0~1内的随机数\n\n\nROUND(x, y)\n求参数x的四舍五入值，保留y位小数\n\n\n\n 3. 日期函数\n\n\n\n函数\n功能\n\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n获取指定date的年份\n\n\nMONTH(date)\n获取指定date的月份\n\n\nDAY(date)\n获取指定date的日期\n\n\nDATE_ADD(date, INTERVAL expr type)\n返回一个日期/时间值加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1, date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n\n 4. 系统信息函数\n\n\n\n\n功能\n\n\n\n\ncharset(str)\n返回str字符集\n\n\ncurrent_user()session_user()user()system_user()\n返回当前用户名称\n\n\nconnection_id()\n当前用户连接id\n\n\nschema()\n当前数据库名\n\n\nversion()\n数据库版本号\n\n\n\n 5. 流程函数\n\n\n\nif(value, t, f)\n如果value为true，则返回t，否则返回f\n\n\n\n\nifnull(value1, value2)\n如果value1不为空，返回value1，否则返回value2\n\n\nif…then…elseif…then…else…end if;\n\n\n\ncase when…then…when…then…else…end\n\n\n\ncase…when…then…when…then…else…end\n类似c语言switch\n\n\n\nselect if(true, 'Ok', 'Error'); -- OK\n-- ''空串不是null,返回''空串\nselect ifnull('', 'Default');\n-- 返回Default\nselect ifnull(null, 'Default');\n\nselect name,\n       (case when '北京' then '一线城市' when '深圳' then '一线城市' else '二线城市' end) as '城市级别'\nfrom tb_employ;\nselect name,\n       (case math when 100 then '满分' when 0 then '鸭蛋' else '不完美的战士也是战士' end) as '评价'\nfrom tb_score;\n\n\nupdate tb_Salary set sex=if(sex=\"f\",\"m\",\"f\") ;\nSELECT sno,CASE sex\n    WHEN '男' THEN 'M'\n    WHEN '女' THEN 'F'\n    END AS sex FROM s;\n\n 7. 约束\n 1. 常见约束\n\n\n\n约束\n描述\n关键字\n\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT NULL\n\n\n唯一约束\n保证该字段的所有数据都是唯一、不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且不重复,每张表最多一个\nPRIMARY KEY\n\n\n默认约束\n保存数据时，如果未指定该字段的值，则采用默认值\nDEFAULT\n\n\n检查约束（8.0.1版本后）\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来让两张图的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n自增\n详见下面\nAUTO_INCREMENT\n\n\n\n# 列级约束\n字段名 数据类型 PRIMARY KEY\n#表级约束\nPRIMARY KEY（字段名1,字段名2,…）\n\ncreate table tb4(\n    id int primary key auto_increment,\n    name varchar(10) not null unique,\n    age int check(age > 0 and age &lt; 120),\n    status char(1) default '1',\n    gender char(1)\n);\n\n 2. 外键约束foreign key\n候选键（Candidate Key）：一个属性或属性组的值能唯一标识一个元组，而子集不能。\n比如，想要知道某位学生的某门课程的成绩Grade，那我们必须要知道该学生的学号Sno以及课程号Cno。此时X[Sno,Cno]称为S的一个候选码。\n主键：当有多个候选键时，可以选定一个作为主键，选定的候选键称为主键（主码）。\n外键：一个表（从表，参照表）的字段引用主表（被参照表）的主键或者唯一键。\n前提：\n1、创建外键的表和列存在\n2、组成外键的列存在索引\n3、必须指定数据表的引擎为InnoDB\n4、外键字段和关联字段，数据类型和长度必须一致\n5、引用字段的值必须存在于被引用表中。\n6、定义外键约束名称(如FK_ID)时，不能加单引号和双引号，可以反引号。\n\n\n\n行为\n说明\n\n\n\n\nno action\n当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）\n\n\nrestrict\n与no action一致\n\n\ncascade\n当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录\n\n\nset null\n当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）\n\n\nset default\n父表有变更时，子表将外键设为一个默认值（Innodb不支持）\n\n\n\n 1. 创建外键\ncreate table father(\n\tcid varchar(10) unique,\n    classname char(4)\n);\ncreate table child(\n\tid int(10) primary key auto_increment,\n    name char(4) ,\n    classid varchar(10),\n    constraint 外键约束名 foreign key (classid) references father(cid) on delete restrict on update cascade  \n);-- 外键约束名不加引号\n\ninsert into father values(1,'一班');\ninsert into father values(2,'二班');\ninsert into father values(3,'三班');\n-- 报错，因为父表没有为5的cid\ninsert into child values(1,'张三',5);\n-- 子表插入记录成功\ninsert into child values(1,'张三',3);\n\n//使用alter table创建外键\nALTER TABLE mydb.employees\nADD CONSTRAINT FK_ID FOREIGN KEY (dept_id) REFERENCES department (id) \nON DELETE RESTRICT ON UPDATE CASCADE;\n\n 2. 查看外键\nmysql> desc db1.child classid;\n+---------+-------------+------+-----+---------+-------+\n| Field   | Type        | Null | Key | Default | Extra |\n+---------+-------------+------+-----+---------+-------+\n| classid | varchar(10) | YES  | MUL | NULL    |       |\n+---------+-------------+------+-----+---------+-------+\n1 row in set (0.11 sec)\n\n添加了外键约束的classid 字段的 Key(索引) 值为MUL，表示非唯一性索引(MUL TIPLE KEY)，值可以重复。\n 3. 修改和删除外键\n-- 修改外键\nALTER TABLE child DROP FOREIGN KEY 外键约束名,add constraint 外键名 foreign key (classid) references father(cid) on delete cascade on update cascade;\n-- 删除外键\nALTER TABLE child DROP FOREIGN KEY 外键名;\n\n 4. 启用或禁用外键\n-- 禁用约束\nALTER TABLE 表名 DISABLE CONSTRAINT 约束名;\n-- 启用约束\nALTER TABLE 表名 ENABLE CONSTRAINT 约束名;\n\n 3. 自动增长\n\n\n一个表中只能有一个自动增长字段，该字段的数据类型是整数类型，且必须定义为键，如 UNIQUE KEY 、PRIMARY KEY\n\n\n若为自动增长字段插入 NULL、0、DEFAULT 或在插入时省略该字段，则该字段就会使用自动增长值；若插入的是一个具体值，则不会使用自动增长值。\n\n\n自动增长值从 1 开始自增，每次加 1。若插入的值大于自动增长的值，则下次插入的自动增长值会自动使用最大值加 1；若插入的值小于自动增长值，则不会对自动增长值产生影响。\n\n\n使用 DELETE 删除记录时，自动增长值不会减小或填补空缺。\n\n\n-- 自增初值为100，每次自增1\nalter table test1 auto_increment=100;\n-- 添加自动增长\nALTER TABLE 表名 MODIFY 字段名 字段类型 [字段属性] AUTO_INCREMENT;\n-- 删除自动增长\nALTER TABLE 数据库名 MODIFY 字段名 字段类型 [字段属性];\n\n 8. 多表查询\n 1. 多表关系\n\n一对多\n\n比如一个部门对应多个员工，一个员工对应一个部门\n实现：在多的一方建立外键，指向一的一方的主键\n\n多对多\n\n比如一个学生可以选多门课程，一门课程也可以供多个学生选修\n实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n\n一对一\n\n关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为unique。\n 2. 合并查询\n\n合并查询（笛卡尔积，会展示所有组合结果）：\n\nselect * from child,teacher,father;\n\n笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）\n\n消除无效笛卡尔乘积\n\nselect * from child,teacher,father where teacher.id=child.id;\n\n 3. 内连接查询\n内连接查询的是两张表交集的部分\n隐式内连接：\nSELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;\n显式内连接：\nSELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;\nselect e.name, d.name from employee as e, dept as d where e.dept = d.id;\nselect * from test2 inner join teacher on test2.id=teacher.id;\n\n 4. 外连接查询\n左外连接：\n查询左表所有数据，以及两张表交集部分数据\nSELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;\n相当于查询表1的所有数据，包含表1和表2交集部分数据,outer可以省略\n右外连接：\n查询右表所有数据，以及两张表交集部分数据\nSELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;\n相当于查询表2的所有数据，包含表1和表2交集部分数据\n-- 左\nselect e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;-- e是别名\nselect d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样\n-- 右\nselect d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;\n\n 5. 自连接查询\n当前表与自身的连接查询，自连接必须使用表别名。\n语法：\nSELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;\n自连接查询，可以是内连接查询，也可以是外连接查询。\n-- 查询员工及其所属领导的名字,输出时a.name替换成员工名字\nselect a.name as 员工名字, b.name as 所属领导名字 from employee a, employee b where a.managerid = b.id;\n-- 没有领导的也查询出来\nselect a.name, b.name from employee a left join employee b on a.managerid = b.id;\n\n在连接查询时，若数据表连接的字段同名，则连接时的匹配条件可以使用 USING 代替ON，多个同名的连接字段之间用逗号分隔。\n 6. 联合查询union，union all\n把多次查询的结果合并，形成一个新的查询集。\nunion会对结果进行并集操作，去除重复行。\nunion all 将查询结果合并，保留重复行。\n-- 不去重，升序排序\nselect money from test2 union all select money from test3 order by money ASC;\n-- 去重\nselect money from test2 union  select money from test3 order by money ASC;\n\n\n联合查询比使用or效率高，不会使索引失效\n\n 7. 子查询(嵌套查询)\nSQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。\nSELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);\n子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个\n根据子查询结果可以分为：\n\n标量子查询（子查询结果为单个值）\n列子查询（子查询结果为一列）\n行子查询（子查询结果为一行）\n表子查询（子查询结果为多行多列）\n\n根据子查询位置可分为：\n\nWHERE 之后\nFROM 之后\nSELECT 之后\n\n 1. 标量子查询\n-- 查询在张三入职时间后公司新来同事\nselect * from employee where entrydate > (select entrydate from employee where name = '张三');\n\n 2. 列子查询\n常用操作符：\n\n\n\n操作符\n描述\n\n\n\n\nIN\n在指定的集合范围内，多选一\n\n\nNOT IN\n不在指定的集合范围内\n\n\nANY\n子查询返回列表中，有任意一个满足即可\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\n\nselect money from test3 where money in (select money from test2 ); \nselect money from test3 where money>any(select money from test2 ); -- 大于其中之一\nselect money from test3 where money>all(select money from test2 ); -- 大于全部\n\n 3. 行子查询\nselect * from test3 where (id,money) in (select id,money from test2 where id=6);\n\n 4. 表子查询\nselect * from test3 where (id,money) in (select id,money from test2);\n\n 9. 视图与索引\n 1. 视图\n视图是在一个、多个基本表或视图基础上，通过查询语句定义的虚拟表格。\n\n\n视图可用于SELECT语句中进行查询\n\n\n视图只存储定义语句，不存储其数据\n\n\n当使用视图进行查询时，视图包含的数据才会临时生成。\n\n\n视图作用：提升数据操作的便携性，提升了数据的安全性，提升了数据的逻辑独立性，视图可用于数据集成。\n视图的工作机制：视图中的内容总是与基本表中数据保持一致，即当基本表中数据发生变化时，相关视图的数据也随之变化。\n 1. 视图创建\nCREATE [OR REPLACE ] [ALGORITHM={ UNDEFINED | MERGE | TEMPTABLE}]\n[DEFINER = { user | CURRENT_USER }]\nVIEW 视图名[(视图字段列表)]\nAS 查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\n添加OR REPLACE可选参数表明可以在创建视图时替换数据库已有8同名视图。\n\n\nALGORITHM表示视图的使用方法。其中，UNDEFINE表示由MySQL自行决定使用方法。\n\n\nWITH CHECK OPTION表示更新、修改和插入视图数据时，只有满足检查条件操作才会执行。\n\n\n-- 创建视图\ncreate or replace view s_view as select * from s where dept='信息学院';\n-- 多张基本表上创建视图\ncreate or replace view ts_view(name,age) as select tb_score.name,age from teacher,tb_score where teacher.id=tb_score.id;\n-- 在视图上创建视图\nCREATE VIEW s_maj_view AS SELECT * FROM s_view WHERE maj='计算机';\n\n不能在SELECT语句中包含系统、用户变量以及处理语句参数，同时不能在FROM子句中包含子查询\n删除视图依赖的基本表后，视图使用会报错，可通过“CHECK TABLE 表名”检查基本表状态。\n不能为临时表创建视图。\n创建视图时，ALGORITHM参数指定对部分查询结果具有影响。\n 2. 视图管理\n-- 查看视图\ndescribe ts_view;-- 查看定义(字段之类)\nshow create view ts_view;-- 查看结构\n-- 删除视图\ndrop view if exists ts_view;\n-- 更新视图的数据(其实更新的是对应的基本表数据)\nINSERT INTO s_update_view VALUES('s10','韩义','男',19,'计算机','信息学院');\nUPDATE s_update_view SET age = 20　WHERE sno = 's10';\nDELETE FROM s_update_view WHERE sno = 's10';\n\n 2. 索引\n优点：\n–提高查询执行的速度。\n–强制实施数据的唯一性。\n–提高表之间联接的速度。\n缺点\n–存储索引要占用磁盘空间。\n–数据修改需要更长的时间，因为索引也要更新。\n–创建索引要花时间。\n按索引特征：普通索引、唯一索引(unique)、主键索引、全文索引(fulltext)和空间索引(spatial)。\n根据索引存储方式进行分类：B-Tree索引、Hash索引\n根据索引与数据物理存储关系：聚集型索引、非聚集型索引\n根据索引涉及列数进行：单列索引、复合索引\n复合索引需要遵循最左匹配原则。\n 1. 索引创建\nCREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX 索引名称\nON 表名称(字段名称[(索引字符长度) [ASC | DESC]][,...]);\n\n当字段名称[(索引字符长度) [ASC | DESC]]只有一项时，将建立单列索引。当字段名称[(索引字符长度) [ASC | DESC]]有多项时，将建立复合索引。\ncreate index t_name_index on teacher(name(3) desc);\n-- 为teacher创建普通索引，针对name的前三个字符降序排列\ncreate unique index c_cn_ct_index on c(cn,ct);\n-- 为课程表c的课程名（cn）和学时（ct）字段建立复合唯一索引\n\ncreate table classroom(\n    cid INT AUTO_INCREMENT,\n\tcrno VARCHAR(10) NOT NULL,-- 教室编号\n\tcbn VARCHAR(10) NOT NULL,-- 教学楼编号\n\tPRIMARY KEY(cid),\n\tunique index nb_index(crno, cbn)\n);-- 建表时创建索引\n\n-- 为已有表创建索引\nalter table teacher add index t_name_index(name(3) desc);\n\n 2. 索引管理\n\n查看索引\n\nshow index from teacher;\n\n\n使用索引\n\nalter table teacher add fulltext index t_name_index(name);\nselect * from teacher where MATCH(name) against('aaa');-- 全文索引使用\n-- 普通索引跟平常用select没区别\n\n\n删除索引\n\nalter table teacher drop index t_name_index;\ndrop index t_name_index on teacher;\n\n 10. 数据库安全管理\n安全控制的一般方法：用户登录，安全审计，权限管理，文件权限，数据加密。\n 1. 添加用户\n\ncreate user if not exists 'student'@'localhost' identified by 'student123';\n#用户为student，密码student123，只允许在mysql所在服务器上登陆\n\n 2. 用户管理\n\n重命名\n\nrename user 'student'@'localhost' to stu@'%';\n-- 更名为stu,%表示任意位置\n\n\n修改密码\n\n\nmysqladmin -u stu -p password;\n\n\n修改用户\n\n\nalter user stu@'%' identified by 'student123';\n\n\n删除用户\n\ndrop user stu@'%';\ndelete from mysql.user where user='stu' and host='%';\n\n 3. 权限管理\n\n权限授予\n\n\ngrant all on *.* to 'teacher1'@'localhost' with grant option;\n#为teacher10用户赋予数据库服务器的所有使用权限（ALL），并允许权限由teacher10授予其他用户。\n\nGRANT SELECT, INSERT, UPDATE \nON *.* TO 'teacher6'@'localhost';\n#为teacher6用户赋予数据库服务器级别的查找、插入和更新数据权限（SELECT、INSERT、UPDATE），并且不允许二次授权。\n\nGRANT SELECT(tno, tn)\nON teaching.t TO 'teacher2'@'192.168.1.23';\n#为teacher2用户赋予teaching数据库中教师表t上tno字段和tn字段的查找数据权限SELECT，并不允许权限由teacher2授予其他用户。\n\n\n\n权限查看\n\nshow grants for 'student'@'localhost';\nSHOW GRANTS FOR CURRENT_USER;\n\n\n权限回收\n\nrevoke select,delete on *.* from 'student'@'localhost';\n\n\n权限转移\n\ngrant all on *.* to 'teacher1'@'localhost' with grant option;\n#允许teacher1将权限转移给其它用户\n\n 4. 角色管理\n角色（Role）是对权限集中管理的一种机制，通常根据特定需要，将一系列权限集中在一起构成角色。\n一个用户可以分配多个角色，也允许一个角色分配给多个用户\n\n角色创建\n\n#创建可在任意主机上使用的教师角色和管理员角色。\ncreate role 'teacher','administrator';\n#创建可在本地主机上使用的开发者角色。\nCREATE ROLE 'developer'@'localhost';\n\n\n角色授权\n\ngrant all privileges on *.* to administrator;\n#为管理员角色administrator授予服务器级别全局权限。\nGRANT SELECT, INSERT, UPDATE, DELETE ON teaching.sc\nTO 'teacher';\n#为教师角色teacher授予teaching.sc表级别的查找SELECT、插入数据INSERT、更新数据UPDATE和删除数据DELETE权限。\n\n\n角色激活\n\n#为用户teacher2分配角色\ngrant 'teacher' to 'teacher2';\n#角色激活\nset default role 'teacher' to 'teacher2';\n-- 使用户teacher2上的teacher角色生效。\nSET DEFAULT ROLE ALL TO 'teacher3';\n-- 使用户teacher3上的所有角色生效。\n\n\n角色查看\n\nselect current_role();\n-- 查询当前用户生效的角色。\n\n\n角色注销\n\nrevoke 'teacher' from 'teacher2';\n-- 回收用户teacher2的角色teacher。\ndrop role 'teacher';\n-- 删除角色teacher。\n\n 11. 数据库并发控制与封锁\n\n 1. 数据库并发性的含义\n数据库最大的特点是数据共享，允许同一时间供多个用户根据自己的需要来操作数据库。\n串行：一个用户在运行程序时，其他用户程序必须等到这个用户程序结束才能对数据库进行存取。\n并行：最大限度地利用数据库，多个用户并行执行数据库。\n数据库的并发性及并发控制机制是衡量数据库系统性能的重要标准。\n在 MySQL 中，会话（session）是指客户端与服务器之间的交互过程，包括连接、执行 SQL 语句、获取结果等。\n 2. 事务及其性质\n事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n用户看到的数据总能保持一致性。\n 1. Mysql支持4种事务模式\n\n\n自动提交模式：每执行一条SQL就提交\n\n\n显式模式：有明确的事务开始和结束语句\n\n\n隐式模式：没有事务开始语句，但有结束语句\n\n\n分布式模式：适合多服务器系统\n\n\nstart transaction;-- 开启事务\ncommit; -- 提交所执行的所有操作，标志事务的结束\nrollback;\n/*回滚语句，当事务运行过程中发生故障时，事务不能继续执行，此时回滚操作撤销了事务所做的修改，并结束当前这个事务*/\n\n 2. 事务的性质（四大特性ACID）\n\n原子性(atomicity)：事务是不可分割的最小操作单元，操作要么都执行，要么都不执行\n一致性：数据库始终保持一致性。事务完成时，必须使所有数据都保持一致状态。\n隔离性：并发执行的事务之间不会相互影响。\n持久性(durability)：一个事务被提交后，对数据库中数据的改变是永久性的。\n\n注意：commit没执行，虽然真表的内容没变，但是假表的内容变了，需要回滚假表。(select可以查到假表,navicat双击数据表看到真表)\n 3. 用户定义的模式\n隐式模式：\n-- 查看事务提交方式\nSELECT @@AUTOCOMMIT;\n\n-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效\nSET @@AUTOCOMMIT = 0;\n-- 改为0，则需要在操作完后commit才会修改数据表\n\nupdate account set money = money - 1000 where name = '张三';\n因为这一行发生错误，所以下面commit不会执行,假表内容被改变了，需要rollback事务\nupdate account set money = money + 1000 where name = '李四'; \ncommit;\n\n显式模式：\nstart transaction;-- 开启事务,也可begin transaction\nselect * from account where name = '张三';\nupdate account set money=money-1000 where name='张三';\nupdate account set money=money+1000 where name='李四';\ncommit;-- 全部执行成功后，提交事务\n\n 3. 并发控制与数据的不一致性\n​\t能够合理调度并发事务，避免并发事务之间的互相干扰造成数据不一致性的技术称为数据库管理系统的并发控制技术。\n数据不一致性的种类：\n\n1.丢失更新\n\n​\t一个事务把另一个对数据的已修改结果覆盖，导致这些修改好像丢失了一样\n\n\n2.读取脏数据(脏读)\n\n​\t一个事务读取了另一个事务未提交的数据，会造成两个事务得到的数据不一致\n\n\n3.不可重复读\n\n​\t一个事务对同一数据的读取结果前后不一致，这是由于读取了另一个事务已修改提交的数据。当其中一个事务需要校验或再确认数据时，出现再读数据与之前读的数据值不相同。(侧重读-读)\n\n\n4.幻象读(Phantom Read)(幻读)\n\n读到的数据是不真实的。比如select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。(侧重读-写)\n原因：其他事务修改、插入、删除了数据。\n\n 4. 事务的隔离级别\n产生上述四种数据不一致性问题的主要原因是并发的事务操作破坏了事务的隔离性。\n为了防止数据库的并发操作导致的数据库不一致性问题，SQL标准定义了4种隔离级别：\n\nSELECT @@transaction_isolation;\n-- MySQL数据库支持所有的隔离级别，查询当前事务隔离级别的语句\n\n-- 设置当前事务的隔离级别(两种方式)\nSET [global | session] transaction isolation level 隔离级别名称;\n\t#global隔离级用于所有用户，session隔离级只用于当前对话和连接\nSET transaction_isolation=’隔离级别名称’;\n\n\n\n\n读取未提交事务\n\n\nREAD UNCOMMITTED是最低事务隔离级别，无法避免读取脏数据、不可重复读和幻象读。\n-- 设置当前会话隔离级别\nset session transaction isolation level read uncommitted;\n\n\n\n读取提交的事务\n\n\nread committed可以避免读取脏数据，但不可避免不可重复读和幻象读。\n\n\n可重复读\n\n\nREPEATABLE READ是MySQL默认的隔离级别，确保同一事务内执行相同的查询语句时，读取的结果是一致的。如果事务T2对多行数据进行增加，那么将会出现幻象读的问题。\n\n\n串行化\n\n\nSERIALIZABL通过强制事务排序，使事务之间不可能相互冲突。用户之间一个接一个顺序地执行当前事务，从而解决幻象读问题，但是可能导致大量的等待现象。\n 5. 事务隔离性的实现\n按照其对可能重读的操作采取的不同策略可以分为乐观并发控制和悲观并发控制两大类。\n乐观并发控制：对于并发执行可能冲突的操作，假定其不会真的冲突，允许并发执行，直到真正发生冲突时才去解决冲突，比如让事务回滚。\n悲观并发控制：对于并发执行可能冲突的操作，假定其必定发生冲突。\n 6. 封锁及封锁协议\n封锁是一种用来防止多个事务同时访问数据而产生问题的机制。\n封锁可以防止用户读取正在由其他用户修改的数据，并可以防止多个用户同时更改相同数据。\n事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。加锁后事务T对该数据对象就有了一定的控制，在事务T释放它的锁之前，其他事务不能更新该数据。\n 1. 封锁粒度\n封锁粒度：封锁的数据库对象的大小。锁定的数据量越少，发生锁争用的可能就越小。在mysql中，封锁粒度分为行级锁和表级锁。\n\n 2. 封锁类型\n封锁分为排它锁和共享锁两种。\n排它锁(eXclusive lock)，简称X锁，又称独占锁或写锁。\n排它锁确保不会同时对同一资源进行多重更新。\n共享锁(shared lock)，简称S锁，又称读锁。\n共享锁允许并发事务读取同一个资源。资源上存在共享锁时，任何其他事务都不能修改数据。除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享锁，那么一旦读取数据，便立即释放资源上的共享锁。\n\n\n 3. 封锁协议\n在封锁时约定的一些规则，例如何时申请封锁、申请何种锁、持锁时间、何时释放等，被称为封锁协议（Locking Protocol）。\n\n一级封锁协议：\n\n​\t事务T在修改数据A时必须先对其加X锁，直到事务结束才能释放锁。\n​\t防止丢失更新。\n\n二级封锁协议：\n\n在一级封锁协议的基础上，加上事务T在读取数据R之前必须先对其加S锁，读完后释放S锁。\n​\t防止丢失更新，读脏数据。\n\n三级封锁协议：\n\n​\t在一级封锁协议的基础上，加上事务T在读取数据R之前必须先对其加S锁，读完后并不释放S锁，而直到事务T结束才释放。\n​\t防止丢失更新，读脏数据，不可重复读。\n 4. 死锁和活锁\n死锁（Dead Lock）是指两个或更多的事务同时处于等待状态，每个事务都在等待其中另一个事务解除封锁，它才能继续执行下去，结果造成任何一个事务都无法继续执行。\n\n\n\n时  间\n事务T1\n事务T2\n\n\n\n\nt0\n封锁学生表\n\n\n\nt1\n\n封锁成绩表\n\n\nt2\n要求封锁成绩表，等待\n\n\n\nt3\n\n要求封锁学生表，等待\n\n\nt4\n等待\n等待\n\n\n\n\n\n活锁（Live Lock）是指由于其他事务的封锁操作使某个事务永远处于等待状态，得不到继续操作的机会。\n​\t活锁避免的方法就是采用先来先服务的策略，按照请求封锁的次序对事务进行排队。\n 12. 存储过程与函数\n是一组完成特定功能的SQL语言代码段，经编译后存储在数据库中，可被触发器、其他存储过程、程序设计语言所调用。\n 1. 定界符与语句块\n​\tmysql默认定界符;，可用delimiter命令新建定界符\nDELIMITER $$\n#表示新的定界符为“$$”，自此开始，直到遇到下一个“$$”，MySQL才会整体执行这段语句代码。\n\n​\t语句块是由若干条语句构成的程序代码单元，在逻辑上被当作一个整体，语句块中的语句要么被执行，要么整体都不被执行。\n#用begin...end定义一个语句块\n\n 2. 变量定义与使用\n变量具有变量名，变量值，数据类型。\n变量分为用户会话变量，局部变量，系统变量。\n\n用户会话变量@\n\n默认值为NULL，无需给出数据类型\nset @a=100,@b=200;\nset @c:=100,@d:=200;\nselect @e:=100,@f:=200;\nselect max(score),min(score) into @a,@b from sc;\n\n\n局部变量\n\n在一个语句块内部定义的变量。\n定义存储过程时，所有局部变量的声明一定要放在存储过程体的开始\ndeclare total_num int default 0;\ndeclare x,y int default 0;\ndeclare myname char(10);\n\n\n系统变量@@\n\n分为全局变量和会话变量\n#查询所有全局变量\nshow global variables;\n#查询所有会话变量\nshow session variables;\nshow variables;\n#查询某个系统变量的取值\nselect @@global.wait_timeout;-- 全局变量wait_timeout\nselect @@session.version;-- 会话变量version\nselect @@version;-- 优先查会话变量，再查全局变量\n#修改会话变量的值\n\n 3. 存储过程的创建和调用\n 1. 创建\nCREATE\n    [DEFINER = { user | CURRENT_USER }]  #定义DEFINER,默认为当前用户\nPROCEDURE 存储过程名\n    [SQL SECURITY { DEFINER | INVOKER } | …]#指定DEFINER或INVOKER权限\nBEGIN\n   ...\nEND\n\n\n创建存储过程，计算阶乘\n\n#记得要声明分隔符\ndrop procedure if exists p1;\ndelimiter $$\ncreate procedure p1() #无参构造\nbegin\ndeclare n,m int;#\"局部变量\"\nset n=1;\nset m=1;\nwhile n&lt;=10 do \nset m=m*n;\nset n=n+1;\nend while;\nselect m;\nend$$\ndelimiter ; #恢复默认分隔符\n#调用存储过程\ncall p1();\n\n\n存储过程的形参\n\nin 表示输入参数，调用时必须传入一个确定的值或有确定值的变量。不会影响传入的外部变量(不能被返回)。\nout 表示输出参数，调用时必须传入一个用户会话变量，会影响传入的外部变量\ninout 表示输入输出参数，调用时必须传入一个有确定值的用户会话变量，会影响传入的外部变量\n注意：out，inout不接受系统变量作为实参。\nmysql> delimiter $$\ncreate procedure p1(out a char(10))\nbegin\nset @a=40; #用户会话变量\nset a=80; #存储过程局部变量\nselect @a,a;\nend$$\nmysql> delimiter ;\nmysql> set @a=50,@b=30;\nmysql> call p1(@b);#调用存储过程，传入实参\nmysql> select @a,@b;\n#此时@a=40,@b=80\n\n 2. 查看，修改特性，删除\n#查看存储过程的定义\nshow create procedure p1;\n\n#查看存储过程的状态特征\nshow procedure status like \"p%\";\n\n#只能修改存储过程的特性\nalter procedure p1  comment '改名了';\nalter procedure p1 sql security invoker;\n\n#删除\ndrop procedure if exists p1;\n\n 4. 存储过程相关函数\n\n\n\ncase when…then…when…then…else…end case;\n\n\n\n\n\nwhile…do…end while;\n\n\n\n[label:] loop…end loop [label];\n一直循环直到执行leave [label];\n\n\n[label:] repeat…until…end repeat [label];\n类似do-while\n\n\n\nDELIMITER //\nCREATE PROCEDURE test_loop()\nBEGIN \n\tDECLARE id INT DEFAULT 0;\n\tadd_loop:LOOP\n\t\tIF id &lt; 10 THEN SET id = id + 1;\n\t\tELSE\n\t\t   LEAVE add_loop;\n\t\tEND IF;\n\tEND LOOP add_loop;\n\tSELECT id;\nEND //\nDELIMITER ;\nCALL test_loop();\n\n 5. 用户自定义函数\n#因为开启了二进制日志，所以得设一下下面这个变量\nset global log_bin_trust_function_creators=1;\ndelimiter //\ncreate function `pt1`()\nreturns int\nbegin\nreturn 1;\nend//\ndelimiter ;\nselect pt1();#调用函数\n\n#查看状态特征\nshow function status;\nshow function status like \"pt1\";\n\n#查看函数代码\nshow create function pt1;\n\n#修改特征信息\nalter function pt1 sql security invoker;\n\n#删除函数\ndrop function pt1;\n\n 6. 游标 cursor\n游标实际上是一种能从包括多条数据记录的结果集中逐条访问这些记录的机制。\n游标主要包括结果集和游标位置。\nMySQL游标只能用于存储过程和函数。\n#游标声明\nDECLARE emp_c CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;\n\n#打开游标\nopen emp_c;\n\n#提取数据\n#fetch取出一条记录，游标指针自动向后移动并指向下一条记录。\nFETCH emp_c INTO cursor_salary;\n\n#关闭游标\nclose emp_c;\n\n 13. 数据库备份还原和日志管理\n 1. 简介\n\n数据库备份分类\n\n\n\nmysql常用数据库备份工具\n\nmysqldump 逻辑备份工具\nmysqlhotcopy 仅支持MyISAM\n 2. mysqldump命令备份\n注意：要用cmd，而不是power shell，不然导入不了。\n\nchcp 65001\n#登录用户主机为本地，将数据库db1中的teacher表备份到back_file1.sql下\nmysqldump -u root -h 127.0.0.1 -proot db1 teacher > C:\\databasestudy\\back_file1.sql\n\n#备份所有表\nmysqldump -u root -h 127.0.0.1 -proot db1  > C:\\databasestudy\\back_file2.sql\n\n#备份表结构\nmysqldump -u root -h 127.0.0.1 -proot --opt --no-data db1 teacher  > C:\\databasestudy\\back_file3.sql\n\n#备份多个表\nmysqldump -u root -h 127.0.0.1 -proot  db1 teacher student  > C:\\databasestudy\\back_file4.sql\n\n#备份数据库db1,db2\nmysqldump -u root -h 127.0.0.1 -proot --databases db1 db2  > C:\\databasestudy\\back_file5.sql\n\n#备份所有数据库\nmysqldump -u root -h 127.0.0.1 -proot --all-databases   > C:\\databasestudy\\back_file6.sql\n\n#备份数据库结构\nmysqldump -u root -h 127.0.0.1 -proot --opt --no-data  db1  > C:\\databasestudy\\back_file7.sql\n\n#备份数据库数据\nmysqldump -u root -h 127.0.0.1 -proot --opt --no-create-info  db1  > C:\\databasestudy\\back_file8.sql\n\n#备份部分数据\nmysqldump -u root -h 127.0.0.1 -proot db1 test1 --where=\"age&lt;11\"  > C:\\databasestudy\\back_file9.sql\n\n 3. 备份还原\n\n未登录服务器用mysql命令还原\n\nmysqldump -u root -h 127.0.0.1 -proot  db1 test2 > C:\\databasestudy\\back_file11.sql\n\nmysql -u root  -p db2 &lt;C:\\databasestudy\\back_file11.sql -- 还原\n/*navicat有延时，需要过一段时间再刷新才能看到\n据说是本地缓存机制\n在cmd登录数据库查看没这个问题*/\n\n\n登陆服务器用source命令还原\n\nmysqldump -u root -h 127.0.0.1 -proot  db1 test2 > C:\\databasestudy\\back_file11.sql\nmysql -u root -p\nuse db2;\nsource  C:\\databasestudy\\back_file11.sql #这里不能有;号\n\n 4. mysql日志管理\n注意：cmd里chcp 65001\n​\t日志文件中记录着MySQL数据库运行期间发生的变化；也就是说用来记录MySQL数据库的客户端连接状况、SQL语句的执行情况和错误信息等。\n日志文件分为：错误日志，二进制日志，通用查询日志，慢查询日志。\n\n 1. 错误日志\n默认开启，不能禁止。文件名格式为hostname.err。\nmy.ini中：\nlog-err定义错误日志的存储位置\nlog-warnings定义是否将警告信息写入错误日志。\n#查看错误日志所在目录及文件名\nshow variables like '%log_error%';\n\n#删除错误日志(重新加载日志)\nmysqladmin -u root -p flush-logs\n\n 2. 二进制日志\n#查看是否开启\nshow variables like '%log_bin%';\n#通过my.ini文件中的log-bin选项可以开启二进制日志\nlog-bin [=path/[filename]] #路径\nexpire_logs_days=10 #保留时间\nmax_binlog_size=100M #单个文件大小限制\n\n#登陆后查看有哪些二进制日志\nshow binary logs;\n#查看日志\nmysqlbinlog d:/log/DESKTOP-O5KMGM8-bin.000013 \n\n#删除二进制日志\nPURGE BINARY LOGS BEFORE '2008-04-02 22:46:26';\n\t#删除到某个时间前所有日志\nPURGE BINARY LOGS TO 'mysql-bin.010';\n\t#删除到某个日志前(不包括指定日志)\n\n#使用mysqlbinlog恢复数据库到某一时刻的状态\nmysqlbinlog --stop-datetime=”2021-03-10 10:00:00” C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\DESKTOP-TKC62RP-bin.000005 | mysql -u root -p\n-- 必须是编号小的先还原\n\nstart-datetime、stop-datetime表示恢复数据库的起始时间点和结束时间点。 start-position和stop-position表示恢复数据的开始位置和结束位置。\n 3. 慢查询日志\n慢查询日志在MySQL中默认是关闭的，可以通过配置文件my.ini或者my.cnf中的slow_query_log选项打开。\nslow_query_log_file[=path/[filename]]  路径，默认hostname-slow.log\nlong_query_time=n 查询时间超过n则记录，默认10秒\n#可以在登陆后开启\nset global slow_query_log=on;或\nset global slow_query_log=1;\n\n#查看慢查询定义的时间值\nshow global variables like 'long_query_time';\n#查看慢查询日志相关变量\nshow global variables like '%slow_query_log%';\n\n#删除慢查询日志\nmysqladmin -u root -p flush-logs;\n\n 4. 通用日志管理\n默认关闭，可修改my.ini开启，log[=path/[filename]]\n也可在登陆后在set global general_log=on/1;\nshow variables like ‘general%’;\nwindows用记事本打开查看。\nmysqladmin -u root -p flush-logs; #重设日志\nflush logs; #登陆后重设日志\n\n 中英对照\ncascade 级联 n.  [kæˈskeɪd]\nconstraint 约束 n.   [kənˈstreɪnt]\ndelimiter 定界符 n. [dɪ’lɪmɪtə]\nexclusive 排斥的，专有的 adj. [ɪkˈskluːsɪv]\nphantom 幽灵,幻影 n. [ˈfæntəm]\nprivilege 特权 n. [ˈprɪvəlɪdʒ]\nprocedure 程序，步骤 n. [prəˈsiːdʒə®]\nprotocol 协议 n. [ˈprəʊtəkɒl]\n\n\n\ncharlist ↩︎\n\n\n\n","categories":["大二"],"tags":[]},{"title":"python学习笔记","url":"/2023/07/14/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":" python3 学习笔记\n 1. 基础\n多行语句：\\用反斜杠后换行，在 [], {}, 或 () 中的多行语句，不需要使用反斜杠，直接换\n#导入模块格式\nfrom somemodule import firstfunc, secondfunc, thirdfunc\nfrom somemodule import *\t#导入模块中的所有函数\nimport somemodule\nfrom sys import argv,path  #  导入特定的成员\nprint('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path\n\n\n\n 输出方法\n\nchr()   ascii码转为string，chr(65)表示A\nord()   字符串转int类型的ascii码,ord(“0”)表示48\nrange(5,10)  区间左闭右开\n\n#coding:utf-8 #设置编码为utf-8\n#print()自带换行\nif __name__ == '__main__':\n    name = 'jay zhou'\n    age = 29\n    print(\"hello world!\");print(\"yes\"\\\n                                r\"\\n\")\n    '''\n    同一行两句代码分号隔开\n    第一个\\表示代码换行继续写\n    加r表示不转义\\n\n    '''\n    print(\"\"\"我的年龄是 \"\"\"+str(age), end=\" \" )# 不换行输出\n    print(f\"大家好，我是{name},今年{age}岁\")\n    print(\"大家好，我是{0},今年{1}岁\".format(name, age))\n    print(\"大家好，我是%s,今年%d岁\" % (name, age))\n    w = {\"who\":8,\"am\":5,\"i\":7}\n    print(f'{w[\"who\"]} {w[\"am\"]} {w[\"i\"]} ',666)#8 5 7 666\n    #不同数据类型逗号隔开\n\n\n 输入方法\n#coding:utf-8\nname = input(\"请输入一个名字: \\n\")\nprint (name,end='')#表示不换行\nprint()#表示换行\nprint(type(name))\n\n 2. 数据类型\n数字，字符串，布尔类型，列表，元组，集合，字典。\n不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n变量都具有三个基本要素：分别是 id，type，value。\n赋值方法\n#同时为多个变量赋值,id相同\na = b = c = 1\n\n#为多个对象指定多个变量。例如：\na, b, c = 1, 2, \"runoob\"\n\n变量命名规则：\n\n\n变量名必须以字母或下划线字符开头\n变量名不能以数字开头\n变量名称只能包含字母数字字符和下划线\n变量名区分大小写\n不能与关键字重复\n\n\n关键字\n\n\n\nand\nexec\nnot\nassert\nfinally\nor\n\n\n\n\nbreak\nfor\npass\nclass\nfrom\nprint\n\n\ncontinue\nglobal\nraise\ndef\nif\nreturn\n\n\ndel\nimport\ntry\nelif\nin\nwhile\n\n\nelse\nis\nwith\nexcept\nlambda\nyield\n\n\n\n 数据处理的一些函数\nenumerate()函数用于将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标\n格式:  enumerate(sequence, [start=0]) #start参数可以不填\nseasons = ['Spring', 'Summer', 'Fall', 'Winter']\nlist(enumerate(seasons,start=1))\n# 输出\n[(1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n\nmap()函数\ndef f(x):\n\treturn x * x\nr = map(f, [1,2,3,4,5,6,7,8,9])\nprint(list(r))\n\t#[1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nfilter()函数\n#filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。\n#filter()也接收一个函数和一个序列。\n# 在一个list中，删掉偶数，只保留奇数\ndef is_odd(n):\n\treturn n % 2 == 1\nprint(list(filter(is_odd,[1,2,3,4,5,6,7,8,9])))\n\t#[1, 3, 5, 7, 9]\n\n 强制类型转换\nx = float(1)     # x 输出结果为 1.0\ncomplex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。\ncomplex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n\nint(s1)#强制转为int类型\nfloat(s1)#强制转为float类型\nstr(s1)#转为string\nl1=list(s1)#转为列表\ns3=set([1,2,3,4])#转为集合\nord() #转数字\nchr() #转字符\nbin() #转二进制\nhex()\t#转16进制\nbytes() #转为字节数组，比如bytes('我喜欢python',encoding='utf-8')\n\n Number数字\n支持 int、float、bool、complex（复数）\na=3.14\nprint(True==1)#TRUE,bool在一定情况被解释成整数\nprint(True+1)#2\nprint(0 is False)#is来判断变量id是否一致\ndel a;print(a) #del语句删除对象引用a,不会输出东西\n\nfrom decimal import Decimal#防止浮点数存储不精确\nprint(Decimal('1.1')+Decimal('2.2'))#3.3\n\n#布尔值为False情况\nbool(False)#False\nbool(0)#False\nbool(0.0)#False\nprint('')#False\nbool(\"\")#False\nbool([])#False空列表\nbool(list())#False空列表\nbool(())#False空元组\nbool(tuple())#False空元组\nbool({})#空字典\nbool(dict())#空字典\nbool(set())#空集合\n\n\"\"\"\n复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型\n\"\"\"\n\n70.2E-12表示[70.2*（10**-12）]\n\ntype() 函数用来查询变量所指的对象类型。\nprint(type(a), type(b), type(c), type(d))\n&lt;class 'int'> &lt;class 'float'> &lt;class 'bool'> &lt;class 'complex'>\ntype()不会认为子类是一种父类类型。\nisinstance()会认为子类是一种父类类型。\n\n 常见运算符\n算术运算&gt;位运算&gt;比较运算&gt;布尔运算&gt;赋值运算\n\n\n\n运算符\n描述（由上至下对应优先级由高到低）\n\n\n\n\n**\n幂运算\n\n\n~ + -\n取反、正号、负号\n\n\n* / % //\n乘、除、取模、取整除\n\n\n+ -\n加法、减法\n\n\n&gt;&gt; &lt;&lt;\n右移、左移\n\n\n&amp;\n与\n\n\n^ |\n异或、或\n\n\n&lt;= &lt; &gt; &gt;= == !=\n比较运算符(默认从右往左)\n\n\n= %= /= //= -= += *= **=\n赋值运算符\n\n\nis is not\n身份运算符\n\n\nin not in\n成员运算符\n\n\nnot and or\n逻辑运算符\n\n\n\n%\t取余\n**\t乘方\n/\t除法\n//\t整除\n%= \t比如c%=a相当于c=c%a\n\n#注意is比较id的情况\na=1;b=1;print(a is b)\t#True\nc=1.0;d=1.0;print(c is d) #True\ne=\"abc\";f=\"abc\";print(e is f)\t#True\ng= (1,2,3);h=(1,2,3);print(g is h);print(f\"{id(g)} {id(h)}\")\t#元组True\ni=[1,2,3];j=[1,2,3];print(i is j);print(f\"{id(i)} {id(j)}\")\t#列表False\nscore1={'张三':100,'李四':98,'王五':45}\nscore2={'张三':100,'李四':98,'王五':45}\nprint(score1 is score2)#字典False\nm1={100,'李四','王五'}\nm2={100,'李四','王五'}\nprint(m1 is m2)#集合False\n\n String字符串\n\n\n以单引号 '、双引号&quot;、三引号 ''' 或 &quot;&quot;&quot;括起来的文本\n\n\n单引号，双引号完全相同。\n\n\n字符串有两种索引方式，从左往右以0开始，从右往左以-1开始\n\n\npython字符串格式化符号:\n\n\n\n符  号\n描述\n\n\n\n\n%c\n格式化字符及其ASCII码\n\n\n%s\n格式化字符串\n\n\n%d\n格式化整数\n\n\n%u\n格式化无符号整型\n\n\n%o\n格式化无符号八进制数\n\n\n%x\n格式化无符号十六进制数\n\n\n%X\n格式化无符号十六进制数（大写）\n\n\n%f\n格式化浮点数字，可指定小数点后的精度\n\n\n%e\n用科学计数法格式化浮点数\n\n\n%E\n作用同%e，用科学计数法格式化浮点数\n\n\n%g\n%f和%e的简写\n\n\n%G\n%f 和 %E 的简写\n\n\n%p\n用十六进制数格式化变量的地址\n\n\n\n格式化操作符辅助指令:\n\n\n\n符号\n功能\n\n\n\n\n*\n定义宽度或者小数点精度\n\n\n-\n用做左对齐\n\n\n+\n在正数前面显示加号( + )\n\n\n\n在正数前面显示空格\n\n\n#\n在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)\n\n\n0\n显示的数字前面填充’0’而不是默认的空格\n\n\n%\n‘%%‘输出一个单一的’%’\n\n\n(var)\n映射变量(字典参数)\n\n\nm.n.\nm 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)\n\n\n\n字符串截取：\n\n使用三引号(‘’’ 或 “”&quot;)可以指定一个多行字符串。\nPython 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始，区间左闭右开\nPython 中的字符串不能改变。\nPython 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n字符串的截取的语法格式如下：变量[头下标:尾下标:步长]\n\na=\"abcdef\"\nprint(a[-1::-1])\t\t\t#fedcba\nprint(a[:])\t#abcdef\nprint(a)\t#abcdef\nprint(a[0:-1])           # 输出第一个到倒数第二个的所有字符,abcde\nprint(a[0])              # 输出字符串第一个字符，a\nprint(a[2:5])            # 输出从第三个开始到第五个的字符，cde\nprint(a[2:])             # 输出从第三个开始后的所有字符,cdef\nprint(a[:2])\t\t\t#ab\nprint(a[1:5:2])          # bd\nprint(a * 2)             # 输出字符串两次,abcdefabcdef\nprint(a + '你好')         # 连接字符串\nprint(\"this\"\"is\"\"string\")\t#thisisstring\nprint(a[-2:])\t\t\t#ef\nprint('{0:.3}'.format(3.1415926))#输出3.14表示一共输出3位数\nprint('{0:.3f}'.format(3.1415926))#输出3.142输出三位小数\n\nvar1[a:b]\n#如果a>=b, 默认输出为空。\nprint(var1[3: 3]);\nprint(var1[3: 2]);\n\n# \\r后面的内容移到字符串开头，并逐一替换开头部分的字符，\nm=\"jkloli\\rdj\"\nprint(m[0:])#dj\n\nprint(m[-1::-1])#倒序打印\n\n字符串增删改查\n#字符串的查询操作\n\ns='hello,hello'\n#index()查询字串第一次出现的位置，若不存在则抛出ValueError\nprint(s.index('lo'))#3\n#find()查询字串第一次出现的位置，若不存在则返回-1\nprint(s.find('lo'))#3\n#rindex()查询字串最后一次出现的位置，若不存在则抛出ValueError\nprint(s.rindex('lo'))#9\n#rfind()查询字串最后一次出现的位置，若不存在则返回-1\nprint(s.rfind('lo'))#9\n\n#大小写转换操作\nname=\"i love you\"\nprint(name.title())#首字母大写I Love You\nprint(name.upper())#I LOVE YOU\nprint(name.lower())#i love you\nprint(name.capitalize())#I love you\nname=name.title();print(name.swapcase())#i lOVE yOU\n\n#对齐操作\ns='i love you'\nprint(s.center(15,'*'))#居中对齐，若第二个参数不指定填充符，默认为空格，指定小于原字符串则返回原字符串,***i love you**\nprint(s.ljust(15,'*'))#左对齐,i love you*****\nprint(s.rjust(15,'*'))#右对齐,*****i love you\nprint(s.zfill(15))#右对齐，左侧用0对齐,00000i love you\nprint('-8910'.zfill(8))#-0008910\n\n#拆分操作\na=\"i got a smoke\"\nl=a.split()\t#['i', 'got', 'a', 'smoke']\nb=\"i#got#you#all#my#mind\"\nl2=b.split(\"#\")\n\t#['i', 'got', 'you', 'all', 'my', 'mind']\nl3=b.split(sep=\"#\",maxsplit=2)\n\t#设置最大分割次数，['i', 'got', 'you#all#my#mind']\nl4=b.rsplit(sep=\"#\",maxsplit=2)\n\t#['i#got#you#all', 'my', 'mind']\n\n#字符串判断相关\ns='hello,python'\nprint(s.isidentifier())#False,判断是否是合法的标识符字符串\nprint('\\t'.isspace())#True,判断是否是全部由空白字符组成（回车、换行、水平制表符）\nprint('abc张三'.isalpha())#True,判断是否全部由字符组成\nprint('123'.isdecimal())#True,判断是否全部是十进制数字\nprint('123四Ⅳ'.isnumeric())#True,判断是否全由数字组成\nprint('abc1'.isalnum())#True,是否全部由字母和数字组成\n\n#合并成一个字符串，join函数\n 'sep'.join(seq)\n  \tsep：分隔符。可以为空\n\tseq：要连接的元素列表、字符串、元组、字典\n    \nd = {'hello':1,'good':2,'boy':3,'doiido':4}\nprint (':'.join(d)) #boy:good:doiido:hello\ns = \"hello good boy doiido\"\nprint(':'.join(s))  #h:e:l:l:o: :g:o:o:d: :b:o:y: :d:o:i:i:d:o\nt=('aa','bb','cc','dd')\nprint(\":\".join(t)) #aa:bb:cc:dd\n\n#编码转换\ns='海上生明月'\n#编码\nprint(s.encode(encoding='GBK'))#在GBK这种编码格式中，一个中文占两个字节\nprint(s.encode(encoding='UTF-8'))#一个中文占三个字节\n \n#解码\nbyte=s.encode(encoding='GBK')\nprint(byte.decode(encoding='GBK'))\n#编码格式和解码格式要相同\n\n字符串驻留机制(不重要)\n\n字符串驻留机制的定义：仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串的驻留池中。python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量。需\n\n前提：\n\n要在控制台进入python(交互模式)\n字符串的长度为0或1时\n符合标识符（只含有数字、字母、下划线，不能以数字开头，不能以关键字重名）的字符串\n字符串只在编译时进行驻留，而非运行时(join函数只在运行时才会输出结果)\n[-5,256]之间的整数数字\n\n特点:\n\n拼接字符串和修改字符串是会比较影响性能的。(用join方法解决)\n\n强行驻留:\n>>> b='1abc'\n>>> import sys\n>>> a=sys.intern(b)\n>>> a is b\nTrue\n\n\n对于长字符串使用“==”比较时可能会出现意外的结果，应该使用“is”进行比较。\n+++\n\\000空    \\a响铃 \\n换行\n List列表\n有序的可变序列\n根据需要动态分配和回收内存\n任意数据类型混存\n列表是写在方括号 [] 之间、用逗号分隔开的元素列表。\n和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。\n列表创建\nl1=[1,2,3,4,5]\nl2=list([1,2,3,'abc',4,5])\nl3=[i*i for i in range(1,10)]\n\n列表截取\nlist = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]\nGenshin=[1,2,3]\nprint (list[1:3])       # 从第二个开始输出到第三个元素\nprint (list * 2)    # 输出两次列表\nprint (list + Genshin) # 连接列表\nprint(list[-1:-3:-1])  #步长可以为负  \na[2:5] = []   # 将对应的元素值设置为空\n\n列表增删改查\n# 从第二位开始（包含）截取到倒数第二位（不包含）\nprint (\"list[1:-2]: \", list[1:-2])\n\n# 查询操作\nl=['a','b','c','d','a']\nprint(l.index('a')) #0,index查索引(第一次出现位置)\nprint(l.index('a',0,5)) #0,从第一个元素查到第五个元素\n\nprint(l.count('a')) #2，a元素出现两次\n#添加操作1\nlist1 = ['G', 'R', 'T']\nlist1.append('B') #末尾加B元素\n\nl[len(l):] = [1,2,3] #l末尾加上三个元素\nl.extend(list1) #末尾依次加上list1的全部元素\n\nk=['q','w','e','r']\nk.insert(1,80) #在第二个元素前插入一个元素\n\t#['q', 80, 'w', 'e', 'r']\n\nsquares = [1, 2,3]\nsquares += [4,5,6]\nprint(squares) # [1, 2, 3, 4, 5, 6]\nb=squares.copy() #相当于b=squares[:]\n\n#添加操作2（列表被当成一个元素）\nl.append(list1) #末尾加元素list1(有括号括起来)\n\t#['a', 'b', 'c', 'd', 'a', ['G', 'R', 'T', 'B']]\nprint(l[5][2])\t#T\n\nk=['q','w','e','r']\nk[1]=[1,2] #['q', [1, 2], 'e', 'r']\nk.insert(0,[1,2]) #[[1, 2], 'q', [1, 2], 'e', 'r']\n\na = ['a', 'b', 'c']\nn = [1, 2, 3]\nx = [a, n]\nprint(x) #嵌套成二维数组 [['a', 'b', 'c'], [1, 2, 3]]\n\n#删除表中元素\nl=[1,['a',2],3,'a']\ndel l[0] #删除第一个元素\nl.remove('a') #删除表内第一个值为'a'的元素\nprint(l) #[['a', 2], 3]\n\nl[:]=[] #列表置空\nl.pop() #删除表最后一个元素\nl.pop(2) #删除表第三个元素\nl.clear() #删除表中所有元素\ndel l #删除列表对象l\n\n#修改操作\nl=[1,2,3,4,5]\nl[1:3]=[8,9,7,6]\t#覆盖第二个元素到第三个元素，并在后面补上没覆盖的元素\nl[0]=0\t\nprint(l)\t#[0, 8, 9, 7, 6, 4, 5]\n\nl.sort() #升序排序\nl.sort(reverse=True) #降序排序\nm=sorted(l) #升序排序\nm=sorted(l,reverse=True) #降序排序\n\nl.reverse() #倒排列表中的元素。\n#列表比较需要引入 operator 模块的 eq 方法\n\n Tuple元组\n\n有序不可变序列\n\n\ntuple(iterable)将可迭代系列转换为元组。\n\n元组创建\nt = tuple((x for x in range(1,10)))\nt2=tuple(('a',1,2,3))\nt3=(10,) #只包含一个元素的元组要加逗号,不然当成数字\nt4=('py',1,2,3)\nt5=() \t#空元组\n\n元组操作\n#查询\nprint(len(t))\nprint(max(t)) #打印元组中的最大值\nprint(min(t)) #打印元组中的最小值\nprint(t[0])\n#元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组\ndel tup\n#元组中元素不能被修改，我们要用重新赋值的方式操作\n\n#与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。\n\n虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。\nlen(tuple) 计算元组元素个数。\n Set集合\n无序不重复数据集合\n注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。\n集合创建\ns = {x for x in 'abracadabra' if x not in 'abc'}\ns1={2, 3, 4, 5, 5, 6, 7, 7}#集合中元素不允许重复\nprint(s)\t#{2, 3, 4, 5, 6, 7}\ns2=set(range(5)) #{0, 1, 2, 3, 4}\ns3=set([1,2,3,4,5,5,5]) #转为集合,{1, 2, 3, 4, 5}\ns4=set()\t#生成空集合\ns= {''} #生成集合{''}\n\n集合增删改查\n#添加方法\ns= set((\"a\",'b','c'))\ns.add(\"d\") #集合添加一个d\ns.update((1,2,3))\ns.update([1,4],[5,6])\n\t#无序，大概长这样{'b', 1, 2, 3, 4, 5, 6, 'd', 'a', 'c'}\n#删除方法\ns.remove(1) 删除集合中的元素1\ns.discard(1)\na=s.pop() #随机删除一个元素，数字为0的概率比较高\nprint(a)\t#展示被删除的删除元素\ns.clear()\t#清空集合\n#查询方法\na=len(s)\n\n集合关系与运算\n#集合关系\ns1 = {10, 20, 30, 40, 50, 60}\ns2 = {10, 20, 30, 40}\nprint(s2.issubset(s1))#True，s2是s1的子集\nprint(s1.issuperset(s2))#True，s1是s2的超集\n#两个集合是否含有交集\nprint(s2.isdisjoint(s1))#False 有交集为False\n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\nprint(a)\nprint(a - b)     # a 和 b 的差集，a.difference(b)\nprint(a | b)     # a 和 b 的并集，a.union(b)\nprint(a &amp; b)     # a 和 b 的交集，a.intersection(b)\nprint(a ^ b)  # a 和 b 中不同时存在的元素，a.symmetric_difference(b)\n\n\n\n Dictionary字典\n\n\n字典是无序的key-value集合。(python3.6以前)\n\n\n字典当中的元素是通过键来存取的，而不是通过偏移存取。\n\n\n键(key)必须使用不可变类型。\n\n\n在同一个字典中，键(key)必须是唯一的。\n\n\nprint(d[‘one’])不存在抛出异常，print(d.get(“one”))不存在输出None\n\n\n zip函数\nzip()函数返回的是一个tuple的迭代器,需要强制转换成list()或dict()对象\nnames = ['John', 'Amy', 'Jack']\nscores = [98, 100, 85]  \ndata = list(zip(names, scores)) \n\t#元组列表[('John', 98), ('Amy', 100), ('Jack', 85)]\ndata2= dict(zip(names,scores))\n\t#{'John': 98, 'Amy': 100, 'Jack': 85}\nif __name__=='__main__':\n    dict_one = dict(a=1, b=2, c='jack')\n    dict_two = dict([(1, \"yi\"), (2, \"er\"), ('one', 1)])\n    for (k1, v1), (k2, v2) in zip(dict_one.items(),dict_two.items()):\n        print(k1, '->', v1)\n        print(k2, '->', v2)\na -> 1\n1 -> yi\nb -> 2\n2 -> er\nc -> jack\none -> 1\n\n\n字典创建\nd={};d[1]=\"666\";d[2]=\"888\" #先创建空字典对象，再赋值\nd1={1:'yi',2:'er',3:'san','one':1}\nd2=dict(a=1,b=2,c='jack')\nd3=dict([(1,\"yi\"),(2,\"er\"),('one',1)])\n\nkey=[\"ABC\",\"MN\",\"K\"]\nvalue=[\"1\",\"2\",\"3\"]\nd4={k.lower():v for k,v in zip(key,value)}\n\t#{'abc': '1', 'mn': '2', 'k': '3'}\nd5 = {k:len(k) for k in key}\n\t#{'ABC': 3, 'MN': 2, 'K': 1}\nd6={x: x**2 for x in (2, 4, 6)}\n\t#{2: 4, 4: 16, 6: 36}\n\n字典增删改查\n#查询操作\nd={1:'yi',2:'er',3:'san','one':1}\nprint (d['one'])       # 输出键为 'one' 的值\nprint (d[2])           # 输出键为 2 的值\nprint (d)          # 输出完整的字典\nprint(str(d))\t\t#当成字符串，输出完整字典字典\nprint (d.keys())   # 输出所有键dict_keys([1, 2, 3, 'one'])\nprint (d.values()) # 输出所有值dict_values(['yi', 'er', 'san', 1])\nprint(d.items())\t#获取所有键值对\n\t#dict_items([(1, 'yi'), (2, 'er'), (3, 'san'), ('one', 1)])\nprint('one' in d)\t#True\n#增加操作\nd[\"dj\"]=\"qwe\"\n#修改操作\nd[\"dj\"]=\"rty\" #修改value\n\nmy_dict = {'a': 4, 'b': 2, 'c': 1, 'd': 3}\nsorted_dict = dict(sorted(my_dict.items(), key=lambda x: x[1]))\n\t'''\n\t1. 使用items()方法将字典转换为元组列表，元组的第一个元素为键，第二个元素为值。\n\t2. 在sorted()函数中，使用lambda表达式指定排序规则，例如按值从小到大排序：key=lambda x: x[1]。\n\t3. 使用dict()方法将排序后的元组列表转换回字典。\n\t'''\n#删除操作\n\ndel d[3] # 删除键3\nd.clear()     # 清空字典\ndel d         # 删除字典\nstr(d)#输出字典，可以打印的字符串表示。\n#不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住\n#键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行\n\n 浅拷贝与深拷贝\n参考:https://github.com/familyld/learnpython/blob/master/Difference_between_DeepCopy_and_ShallowCopy.md\n\n非容器类型（如数字、字符串、和其他’原子’类型的对象）不存在拷贝。\n只包含原子类型对象的元组变量不存在拷贝。\n\n​\t\t首先，如果我们不进行拷贝，而是直接赋值，很有可能会出现意料之外的结果。比如a是一个列表，b=a，那么修改a的同时，b也会同样被修改，因为Python对象的赋值都是进行引用（内存地址）传递的，实际上a和b指向的都是同一个对象。\n​\t浅拷贝会创建一个新的对象，然后把生成的新对象赋值给新变量，新的对象是指copy创建了一个新的列表对象，而不是列表里的int对象。这样a和b这两个变量指向的列表对象就不是同一个，但和两个列表对象里面的元素依然是按引用传递的，所以a列表中的对象1和b列表中的对象1是同一个。这时只有修改a列表的可变对象，b列表才会受到影响。\n>>> a = [1,2,3]\n>>> import copy\n>>> b = copy.copy(a)\n>>> b is a\nFalse\n>>> a[0] is b[0]\nTrue\n>>> a[0] = 4\n>>> a\n[4, 2, 3]\n>>> b\n[1, 2, 3]\n\n>>> a = [1,2,[3,]]\t#可变对象[3,]\n>>> b = copy.copy(a)\n>>> a is b\nFalse\n>>> a[2].append(4)\n>>> a\n[1, 2, [3, 4]]\n>>> b\n[1, 2, [3, 4]]\n\n​\t\t深拷贝不仅重新创建对象，还重新创建对象里的元素。但是对于对象中的不可变元素，深拷贝不会重新生成，变量改动时会自动生成另一个不可变对象，然后改变引用的地址。\n>>> a = [1,2,[3,]]\n>>> b = copy.deepcopy(a)\n>>> a is b\nFalse\n>>> a[0] is b[0]\nTrue\n>>> a[2] is b[2]\nFalse\n\n[1, 2, [3]]\n>>> a = [1,2,[3,]]\n>>> b = copy.deepcopy(a)\n>>> a[2].append(4)\n>>> a\n[1, 2, [3, 4]]\n>>> b\n[1, 2, [3]]\n\n generator生成器\n在 Python 中，生成器是一种特殊的迭代器，它使用了 yield 语句来实现迭代器的协议，并且可以动态地生成值，避免了一次性生成大量数据所带来的内存消耗。\n在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。\n# 示例 1：使用生成器函数创建生成器\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n\n# 使用 for 循环遍历生成器\nfor i in my_generator():\n    print(i)\n\n# 示例 2：使用生成器表达式创建生成器\ngen = (x*x for x in range(5))\n\n\n# 使用 for 循环遍历生成器\nfor i in gen:\n    print(i)\n\n Iterator迭代器\nIterable 可迭代对象：可以直接作用于for循环的对象\nIterator迭代器：可以被next()函数调用并不断返回下一个值的对象。\n\n生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。\n把list、dict、str等Iterable变成Iterator可以使用iter()函数，iter(list1)\n\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nprint (next(it))   #1 输出迭代器的下一个元素\nprint (next(it))\t#2\n\n#目录遍历\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nfor x in it:\n    print (x, end=\" \")\n#输出1 2 3 4\n\n#用next()函数\nimport sys         # 引入 sys 模块\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\n \nwhile True:\n    try:\n        print (next(it))\n    except StopIteration:\n        sys.exit()\n\n#把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。\n\n#在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。\n\n#迭代20次终止\nclass MyNumbers:\n  def __iter__(self):\n    self.a = 1\n    return self\n  def __next__(self):\n    if self.a &lt;= 20:\n      x = self.a\n      self.a += 1\n      return x\n    else:\n      raise StopIteration\t#标识迭代的完成\nmyclass = MyNumbers()\nmyiter = iter(myclass)\nfor x in myiter:\n  print(x)\n\n 3. 条件语句和循环语句\n if…elif…else…\n两种写法如下\nscore=int(input('请输入一个成绩:'))\nif score>=90 and score&lt;=100:\n    print('A级')\nelif score>=80 and score&lt;=89:\n    print('B级')\nelif score>=70 and score&lt;=79:\n    print('C级')\nelif score>=60 and score&lt;=69:\n    print('D级')\nelif score>=0 and score&lt;=59:\n    print('E级')\nelse:\n    print(\"对不起，您的输入有误\")\n\nscore2=int(input('请输入第二个成绩:'))\nprint('score>score2') if score>score2 else print('score&lt;=score2')\n\n\n\n range函数创建列表\n#range的三种创建方式\nr=range(10)#默认从0开始，默认相差1\nprint(r)#range(0,10)，区间左闭右开\nprint(list(r))#可用该方法查看range对象中的整数序列\n \nr=range(1,10)#指定了起始值，从1开始不包含10\nprint(list(r))\n \nr=range(1,10,2)#指定了起始值结束值和步长\nprint(list(r))\n\n while\na=0\nsum=0\nwhile a&lt;=100:\n    if not bool(a%2):\n        sum+=a\n    a+=1\nprint('1-100的偶数和',sum)\n\n for-in循环\nfor item in 'Python':\n    print(item)\n \nfor i in range(10):\n    print(i)\n    \nlist = ['chinese','english','japanese']\nu = 'say:'\nfor i, j in enumerate(list):\n    list[i] = u + j.title()\nprint(list)\t#输出['say:Chinese', 'say:English', 'say:Japanese']\n\n#循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。\npass 不做任何事情，一般用做占位语句\n\n\n \nimport sys\n \ndef fibonacci(n): # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if (counter > n): \n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\nf = fibonacci(10) # f 是一个迭代器，由生成器返回生成\n \nwhile True:\n    try:\n        print (next(f), end=\" \")\n    except StopIteration:\n        sys.exit()\n\n 4. 函数\n\n\n函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。\n\n\n任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。\n\n\n函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。\n\n\n函数内部定义的变量前面加global可以让该变量变为全局变量\n\n\nreturn [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。\n在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。\n\n**不可变类型：**变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。\n**可变类型：**变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n\npython 函数的参数传递：\n\n**不可变类型：**值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。\n**可变类型：**引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响\n\n可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了\n#py传递不可变对象\ndef change(a):\n    print(id(a))   # 指向的是同一个对象\n    a=10\n    print(id(a))   # 一个新对象\na=1\nprint(id(a))\nchange(a)\nprint(id(a))\n#输出\n3177650651376\n3177650651376\n3177650651664\n3177650651376\n#可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。\n参数\n\n\n\n 1. 参数类型\n\n位置参数 ：调用函数时根据函数定义的参数位置来传递参数。\n关键字参数：函数调用时通过“键=值”形式传递参数。\n缺省参数：也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传入该默认参数的值。\n不定长参数：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数（包括不传参）的场景。\n\n注意：\n​\t定义函数时，要遵循普通参数，默认参数，第一种不定长参数，第二种不定长参数的顺序。def func(a,b=3,*c,**d)\n​\t调用函数时，位置参数必须在关键字参数的前面，普通参数必须赋值。\n#!/usr/bin/python3\ndef printinfo( name, age = 35 ):\n\t# 默认参数age=35需要放在普通参数后面，不然会报错\n   print (\"名字: \", name,end=' ')\n   print (\"年龄: \", age)\n   return\n#调用函数\nprintinfo( age=50, name=\"a\" )\t#关键字参数\nprintinfo( name=\"a\" )\t#name必须传值\nprintinfo(\"zhangsan\",25)\t#位置参数\n\t名字:  a 年龄:  50\n\t名字:  a 年龄:  35\n\t名字:  zhangsan 年龄:  25\n\n#不定长参数\n1. 位置传递：以*标记一个形式参数，以元组的形式接受参数，一般命名为args。\n2. 关键字传递：以**标记一个形式参数，以字典的形式接受参数，一般命名为kwargs。\n\ndef sun(*a, **b):\n    print(a)\n    print(b)\nsun(1, 2, x=3, y=4)\n\t'''\n\t(1, 2)\n\t{'x': 3, 'y': 4}\n\t'''\n\n# 使用不定长参数传固定值,注意，*a、**b可省略，name不可省略,否则报错\ndef printinfo( name,age = 35 ,*a,**b, ): #定义函数\n\t# 默认参数age=35需要放在最后，不然会报错\n    print ( name,end=' ')\n    print ( age)\n    print(a)\n    print(b)\n    return\n#调用函数\nprintinfo( \"a\", 50,1,2,3,a=1,b=2 )\t#注意顺序\n\n# 如果单独出现星号 *，则星号 * 后的参数必须用关键字传入：\ndef f(a,b,*,c):\n\treturn a+b+c\nprint(f(1,2,c=3))\n\ndef fun(a,b,c):\n    print(a,b,c)\nlst=[11,22,33]\nfun(*lst)#11 22 33,在函数调用时，将列表中的每个元素都转换为位置实参传入\ndic={'a':111,'b':222,'c':333}\t#a=111,b=222,c=333\nfun(**dic)#111 222 333,在函数调用时，将字典中的键值对都转换为关键字实参传入\n\n 2. 匿名函数\n\nPython 使用 lambda 来创建匿名函数。\nlambda 传入参数:函数体\n\nlambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。\nlambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。\n虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n\n\n#!/usr/bin/python3\nsum = lambda arg1, arg2: arg1 + arg2\t#只能写一行\nprint ( sum( 10, 20 )) # 30\n\nrs=(lambda x,y:x if x>=y else y)(10,20)\nprint(rs)# 20\n\n我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。\ndef myfunc(n):\n  return lambda a : a * n\n \nmydoubler = myfunc(2)\nmytripler = myfunc(3)\n \nprint(mydoubler(11)) # 22\nprint(mytripler(11)) # 33\n\n 5. 面向对象\n 1. 基础\n在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问\nclass Student2(object):\n    \"\"\"docstring for Student\"\"\"\n    def __init__(self, name, score): #构造方法\n        print(\"调用了构造函数\")\n        self.__name = name\t#私有属性赋值\n        self.__score = score\n    def print_score(self):\t#类的方法必须有self参数\n        print('%s : %s ' % (self.__name, self.__score))\n    def get_name(self):\n        return self.__name #外部通过get_name函数访问私有属性\n    def __del__(self):\n        print(\"调用了析构函数\")\n     \nbartt = Student2('bart', 59)\nbartt.print_score()\nbartt.swecore=89\nprint(bartt.swecore)\nprint(bartt.get_name())\n\n#Python解释器对外把__name变量改成了_Student__name,所以，仍然可以通过_Student__name来访问__name变量：\nprint(bartt._Student2__name)\n\n 2.魔术方法\n 简单的\n__init__\t构造函数\n__del__\t\t析构函数\n__dict__ 获取对象属性和方法\n__mro__\t查看类的方法的解析顺序(类的调用顺序)\n\n call\nclass Student2(object):\n    def __init__(self, name, score):  # 构造方法\n        print(\"调用了构造函数\")\n        self.__name = name  # 私有属性赋值\n        self.__score = score\n    def __call__(self, a, b):\n        print(a, b)\nc = Student2(1,2)\t#先创建对象并调用构造函数\nc( 3, 4)\t#使得类实例对象可以像调用普通函数那样使用\n\n调用了构造函数\n3 4\n\n str和new\n__new__ 创建一个新的实例对象的静态方法\n    至少传入一个参数cls，cls表示要实例化的类\n\t若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行，将没有__init__被调用。\n\nclass A(object):\n    def __init__(self, value):\n        print(\"into A __init__\")\n        self.value = value\n    def __new__(cls, *args, **kwargs):\n        print(\"into A __new__\")\n\n        return object.__new__(cls)  # 不知道为啥这里参数只能是cls\nclass B(A):\n    def __init__(self, value):  #子类重写父类__init__()方法\n        print(\"into B __init__\")\n        self.value = value\n\n    def __new__(cls, *args, **kwargs):\n        print(\"into B __new__\")\n        return super(B, cls).__new__(cls, *args, **kwargs)\n    def __str__(self):  # 重写__str__方法，返回值必须是字符串\n        return str(self.value)\nif __name__=='__main__':\n    b = B(10)\n    print(b)    # 自动调用__str__方法\n#结果\ninto B __new__\ninto A __new__\ninto B __init__\n10\n\nclass PositiveInteger(int):\t#自定义一个整数类型\n    def __new__(cls, value):\n        return super(PositiveInteger, cls).__new__(cls, abs(value))\n \ni = PositiveInteger(-3)\nprint(i)\t#3\n\n 3. 继承，重写\n多重继承顺序:https://zhuanlan.zhihu.com/p/268136917\npython使用C3 linearization算法搜索\nclass people:\n    name = \"\"\n    age = 0\n    __weight = 0\n    def __init__(self,n,a,w):\n        self.name=n\n        self.age=a\n        self.__weight=w\n    def speak(self):\n        print(\"%s 说：我今年 %d 岁了，体重 %d kg\" % (self.name,self.age,self.__weight))\n    def get_weight(self):\n        return self.__weight\n#单继承示例\nclass student(people): #子类student继承父类people\n    grade=''\n    def __init__(self,n,a,w,g):\n        super(student,self).__init__(n,a,w)#调用父类构造函数\n            #或者people.__init__(self,n,a,w)  使用这个可能会出现父类__init__多次调用的情况\n            #或者super().__init__(n,a,w)\n        # 也可以super().__init__(self,n,a,w)\n        self.grade=g\n    def speak(self):    #子类重写父类方法\n        print(\"%s 说：我今年 %d 岁，读 %d 年级，体重 %d kg\" % (self.name, self.age,self.grade, self.get_weight()))\nclass speaker():\n    topic = ''\n    name = ''\n    def __init__(self, n, t):\n        self.name = n\n        self.topic = t\n    def speak(self):\n        print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\" % (self.name, self.topic))\n#多继承\nclass sample(speaker,student):\n    a =''\n    def __init__(self,n,a,w,g,t):\n        student.__init__( self,n, a, w, g)\n        super(sample,self).__init__( n, t)\n\n\ntest = sample(\"Tim\",25,80,4,\"Python\")\nprint(sample.__mro__) #查看方法的搜索顺序\ntest.speak()   #方法名同，一般调用的是在括号中参数位置排前父类的方法(sample(speaker,student))\n    #我叫 Tim，我是一个演说家，我演讲的主题是 Python\nsuper(student,test).speak()#调用student父类方法\n    #Tim 说：我今年 25 岁了，体重 80 kg\n\nt2=student(test.name,test.age,test.get_weight(),test.grade)\nt2.speak() #Tim 说：我今年 25 岁，读 4 年级，体重 80 kg\n\nprint(list(test.__dict__.values())[0:4]) #['Tim', 25, 80, 4]\n    #__dict__属性获取sample类对象test的属性字典\n    #提取字典的值，转为列表形式，截取前四个参数\nt3=student(*list(test.__dict__.values())[0:4])\nt3.speak() #Tim 说：我今年 25 岁，读 4 年级，体重 80 kg\n\n 4. 抽象类与多态\nimport abc# abstract base class\nclass Animal(metaclass=abc.ABCMeta): #同一类事物:动物\n#或者class Animal(abc.ABC):\n    #metaclass 控制类的创建与行为\n    @abc.abstractmethod\n    def talk(self):\n        pass\n\nclass Cat(Animal): #动物的形态之一:猫\n    def __init__(self,name):\n        self.name=name\n    def talk(self):\n        print(f'{self.name} say miaomiao')\n\nclass Dog(Animal): #动物的形态之二:狗\n    def talk(self):\n        print('say wangwang')\n\nclass Pig(Animal): #动物的形态之三:猪\n    def talk(self):\n        print('say aoao')\n# 多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承）\nif __name__=='__main__':\n    c=Cat(\"power\")\n    c.talk()\n#结果\npower say miaomiao\n\n 5. 闭包与装饰器\n 1.闭包\n\n函数的返回值必须是被包函数对象(函数名)\n闭包中必须引用了外层函数作用域内的变量或者形参\n\ndef outer(n):\n\tdef inner(n1):\n\t\tprint(n+n1)\n\treturn inner\nif __name__=='__main__':\n\tjk=outer(11)\t#此时jk可看作inner\n\tjk(22)\t#33 执行jk()就相当于执行inner()\n\n闭包修改外部函数变量\n\n函数内部想要修改全局变量，使用global关键字\n在闭包函数内部，想要修改外部函数的局部变量，需要使用nonlocal关键字\n\ndef outer():\n    num = 10\n    def inner():\n        # num = 100  ,这一行的num只是inner里面的num\n        nonlocal num  # 声明使用外部变量 num ，不重新定义\n        num = 100\n    print(f'调用inner之前：{num}')\n    inner()\n    print(f'调用inner之后：{num}')\n    return inner\n\nfunc = outer()\n调用inner之前：10\n调用inner之后：100\n\n闭包陷阱\n\nouter 函数返回了一个包含三个闭包（inner 函数）的列表 f_list。每个闭包都捕获了循环变量 i 的引用，而不是在它们被创建时的值。因此，在循环结束后，这些闭包引用的 i 都指向了最终的循环结束值，即 3。\n\ndef outer():\n    f_list = []\n    for i in range(1, 4):\n        def inner():  \n            return i * i\n        f_list.append(inner)\n    return f_list\nfor fun in outer():\n    print(fun())\n#输出\n9\n9\n9\n#解决问题：创建闭包时传递参数来捕获循环变量的值\ndef inner(x=i):  # 使用参数 x 捕获循环变量值\n    return x * x \n\n 2. 装饰器简介\n装饰器本质就是一个闭包函数，只不过比较特殊\n​\t1.定义外层函数(要求参数只有一个，类型是函数类型，调用时传参传递的是原函数）\n​\t2.定义内层函数，在内层函数中，书写新的功能，并在合适的时机调用原函数\n​\t3.返回内部函数的地址\nimport time\ndef jkloli():\n    print(\"我是jkloli\")\n    time.sleep(2)\ndef count_time(func):\n    def inner():\n        t1 = time.time()\n        func()\t#引用外部函数的形参func,实际是调用原函数jkloli()\n        print(\"执行时间为：\", time.time() - t1)\n    return inner\t#返回内层函数地址\n \nif __name__ == '__main__':\n    jk = count_time(jkloli)\n    jk()\t#jk()相当于inner()\n我是jkloli\n执行时间为： 2.0066511631011963\n\n 3. 装饰器语法糖\ndef login_check(fn):\n    def inner():\n        # 书写新的功能，使用print进行模拟\n        print('登录验证......')\n        # 新的功能书写完成之后，调用原函数\n        fn()\n    return inner\n\n# 装饰器的语法糖格式，\n@login_check  # comment =login_check(comment)\ndef comment():\n    # 使用print输出模拟评论功能\n    print('进行评论检查......')\nif __name__ == '__main__':\n    comment()\n登录验证......\n进行评论检查......\n\n 4. 装饰带返回值的原函数\n\n\n如果原函数有返回值，返回的就是原函数的返回值\n\n\n如果没有返回的是None\n\n\ndef logger(fn):\n    def inner(*args, **kwargs):\n        print(f'{fn.__name__} enter....',end=' ')\n        result = fn(*args, **kwargs)\n        print(f'{fn.__name__} leave....',end=' ')\n        # 函数没有书写返回值，默认返回None\n        return result\n    return inner\n\n@logger # func=logger(func)\ndef func(into):\n    return into\n\n@logger\ndef my_sum(a, b):\n    return a + b\n\nif __name__ == '__main__':\n    print(func('hello')) #func('hello')相当于inner('hello')\n    print(func((3, 6)))\n    print(my_sum(1,3))\n# 结果\nfunc enter.... func leave.... hello\nfunc enter.... func leave.... (3, 6)\nmy_sum enter.... my_sum leave.... 4\n\n 5. 带参数的装饰器\ndef p(name=None):\n    def outer(fnc): # 捕获传递给它的函数f\n        def inner(j=name):\n            return fnc(j)\t\t#注意return\n        return inner\n    return outer\n@p(name=\"abc\") # 将f函数传给装饰器工厂p,然后被包裹在outer和inner里\ndef f(name):\n    return name\n\nif __name__=='__main__':\n    print(f())\n    k = p(name=\"abc\")(f) # 手动调用装饰器\n    print(k())\n#结果\nabc\nabc\n\n 6. 类装饰器\n回到装饰器上的概念上来，装饰器要求接受一个callable对象，并返回一个callable对象（不太严谨）。那么用类来实现也是也可以的。我们可以让类的构造函数__init__()接受一个函数，然后重载__call__()并返回一个函数，也可以达到装饰器函数的效果。\nclass logging(object):\n    def __init__(self, func):\n        print(\"进入init函数\")\n        self.func = func\n\n    def __call__(self, *args, **kwargs):\n        print(\"进入call函数\")\n        return self.func(*args, **kwargs)\n    \n@logging\t#此时进入init函数\ndef say(something):\n    print(\"say {}!\".format(something))\nsay(555)\n#结果\n进入init函数\n进入call函数\nsay 555!\n\n相当于\ndef say(something):\n    print(\"say {}!\".format(something))\nsay=logging(say)\nsay(555)\n\n 7. 带参数的类装饰器\nclass logging(object):\n    def __init__(self, a, b):\n        print(\"进入init函数\")\n        self.a = a\n        self.b = b\n    def __call__(self, fnc):\n        print(\"进入call函数\")\n        def speak(*args):\n             print(f\"参数：{self.a} {self.b}\")\n             fnc(*args)\n        return speak\n\n@logging(\"come on\", \"daddy\")\ndef say(something):\n    print(\"say {}!\".format(something))\n\nsay(888)\n#结果\n进入init函数\n进入call函数\n参数：come on daddy\nsay 888!\n\n 6. 文件操作\n 1. 文件基本读写\n模式\nmode字符       意义\n'r'       文本读取（默认）\n'w'       文本写入，并先清空文件（慎用），文件不存在则创建\n'x'       文本写，排它性创建，如果文件已存在则失败\n'a'\t      文本追加，如果文件存在则在末尾追加，不存在则创建\n与mode组合字符\t意义\n'b'\t    二进制模式，例如：'rb'表示二进制读，不需要encoding\n't'\t    文本模式（默认），例如：rt 一般省略 t\n'+'\t    读取与写入，例如：'r+' 表示同时读写\n\n一些读写函数\n\n\n\n编号\n关键字\n使用方法\n作用\n\n\n\n\n1\nopen\n文件对象 = open（file，mode，encoding）\n打开文件获得指定文件对象\n\n\n2\nread\n文件对象.read（num）\n文本模式下读取num长度字符，二进制下读取num长度字节，不指定num读取文件全部\n\n\n3\nreadline\n文件对象.readline（）\n读取一行\n\n\n4\nreadlines\n文件对象.readline（）\n读取全部行，得到列表\n\n\n5\nfor\nfor line in 文件对象\nfor循环文件行，一次循环得到一行数据\n\n\n6\nclose\n文件对象.close（）\n关闭文件对象，具有flush的作用\n\n\n7\nwith open\nwith open（） as fp\n打开文件，不用fp.close()，可以自动关闭\n\n\n8\nflush\nfp.flush()\n当调用flush时，内容才会真正写入文件\n\n\n9\nwrite\nfp.write()\n直接调用write，内容并未真正写入文件，而是积攒在程序的内存中，称为缓冲区\n\n\n10\ntell\nfp.tell()\n文件指针距离文件开头的字节数\n\n\n11\nseek\nfp.seek()\n详见下面解析\n\n\n\n注意文本模式下只允许从文件的开头进行偏移，也只支持 whence=0\nseek 移动文件句柄\nseek 方法接收两个参数：\noffset 表示偏移指针的字节数\nwhence 表示偏移参考，默认为 0\n0 表示偏移参考文件的开头，offset 必须是 >=0 的整数\n1 表示偏移参考当前位置，offset 可以是负数\n2 表示偏移参考文件的结尾，offset 一般是负数\n\nf = open(\"test.txt\", \"rb\") #建议二进制形式打开\nf.seek(5,1)\n\n#ce.txt用记事本敲入下面内容\ni love you\n baby\n123456\n78910\n\n#展示读操作\nfp=open(\"C:\\\\Users\\\\21609\\\\Desktop\\\\ce.txt\",\"rt\",encoding=\"utf-8\") #创建文件对象fp\nline=fp.readlines()\np=\"\"\nfor i in line:\n    p+=i\nprint(p)\n'''\ni love you\n baby\n123456\n78910\n'''\nprint(line)\n#['i love you\\n', ' baby\\n', '123456\\n', '78910']\nfp.close()\n\n#展示写操作\nwith open(r\"C:\\Users\\21609\\Desktop\\ce.txt\",\"a+\",encoding=\"utf-8\") as fp: #r防止转义，创建文件对象fp\n    fp.write(\"\\n原神，启动！\")\n    fp.flush()  #刷新一下\n    print(fp.tell())    #文件指针距离文件开头的字节数\n    fp.seek(0)  #文件指针回到开头\n    a=fp.read() \n    print(a)\n'''\n52\ni love you\n baby\n123456\n78910\n原神，启动！\n'''\n\n","categories":["计算机基础"],"tags":["python"]},{"title":"我的博客","url":"/2023/06/24/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"","categories":[],"tags":[]},{"title":"Hello World","url":"/2023/06/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n Quick Start\n Create a new post\n$ hexo new \"My New Post\"\n\nMore info: Writing\n Run server\n$ hexo server\n\nMore info: Server\n Generate static files\n$ hexo generate\n\nMore info: Generating\n Deploy to remote sites\n$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]