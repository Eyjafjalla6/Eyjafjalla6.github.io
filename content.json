{"meta":{"title":"jkloli的博客","subtitle":"","description":"","author":"jkloli","url":"https://eyjafjalla6.github.io","root":"/"},"pages":[],"posts":[{"title":"C语言基础-下","slug":"C语言基础-下","date":"2023-10-10T07:00:27.000Z","updated":"2023-10-10T07:18:14.266Z","comments":true,"path":"2023/10/10/C语言基础-下/","link":"","permalink":"https://eyjafjalla6.github.io/2023/10/10/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%8B/","excerpt":"","text":"十二.位运算 2. 概念 1. 进制转换 1. 二进制转换为10进制： 按权展开，然后求和，就可把二进制数转换成十进制数。例如： (101.1)2＝1×22+0×21+1×20+1×2−1＝(5.5)10(101.1)_2＝1×2^2+0×2^1+1×2^0+1×2^{-1}＝( 5.5 )_{10} (101.1)2​＝1×22+0×21+1×20+1×2−1＝(5.5)10​ 2. 十进制转二进制 十进制数有整数和小数两部分。 在转换时，整数部分采用除2取余法 小数部分采用乘2取整法c 3. 二进制转八进制 三位并一位：以小数点为基准，整数部分从右到左，小数部分从左到右，每三位一组，不足三位添0补足，然后把每组的三位二进制数按权展开后相加，得到相应的一位八进制数码，再按权的顺序连接即得相应的八进制数。 (1011100.00101011)2=(?)8(001,011,100.001,010,110)2=(134.126)8134.126(1011100.00101011)_2=(?)_8\\\\ (001,011,100.001,010,110)_2=(134.126)_8\\\\ 1 3 4 . 1 2 6 (1011100.00101011)2​=(?)8​(001,011,100.001,010,110)2​=(134.126)8​134.126 4. 八进制转二进制 \\xxx表示3为八进制,\\1011超char范围（非法） 一位拆三位：将每一位八进制数写成对应的三位二进制数，然后按权连接即可。 123.67(八进制)001,010,011.110111(二进制)(123.67)8=(1010011.110111)21 2 3 . 6 7 (八进制)\\\\ 001,010,011.110111 (二进制)\\\\ (123.67)_8=(1010011.110111)_2 123.67(八进制)001,010,011.110111(二进制)(123.67)8​=(1010011.110111)2​ 5. 二进制转十六进制 四位并一位：以小数点为基准，整数部分从右到左，小数部分从左到右，每四位一组，不足四位添0补足,然后把每组的四位二进制数按权展开后相加，得到相应的一位十六进制数码，再按权的顺序连接即得相应的十六进制数。 (1011110.00011)2=(?)16(0101,1110.0001,1000)2=(?)165E.18(1011110.00011)_2=(?)_{16}\\\\ (0101,1110.0001,1000)_2=(?)_{16}\\\\ 5 E . 1 8 (1011110.00011)2​=(?)16​(0101,1110.0001,1000)2​=(?)16​5E.18 6. 十六进制转二进制 ‘\\xa’ --合法，0xa 合法，\\0xa非法 一位拆四位：把一位十六进制数写成对应的四位二进制数，然后按权连接即可。 123.EF(十六进制)0001,0010,0011.1110,1111(二进制)(123.EF)16=(100100011.11101111)21 2 3 . E F (十六进制)\\\\ 0001,0010,0011.1110,1111 (二进制)\\\\ (123.EF)_{16}=(100100011.11101111)_2 123.EF(十六进制)0001,0010,0011.1110,1111(二进制)(123.EF)16​=(100100011.11101111)2​ 指按二进制位进行运算。 ＆ 按位与 ~ 取反 | 按位或 &lt;&lt; 左移 ^ 按位异或 &gt;&gt; 右移 (1)位运算符中除~以外，均为二目（元）运算符，即要求两侧各有一个运算量。 (2)运算量只能是整型或字符型的数据，不能为实型数据（浮点型）。 3.按位与&amp; 含义：参加运算的两个数据，按二进制位进行“与”运算。 如果两个相应的二进制位都为１，则该位的结果值为１；否则为０。 例如： ０＆０＝０，０＆１＝０， １＆０＝０，１＆１＝１ 如果参加&amp;运算的是负数（如-3&amp;-5），则要 以补码形式表示为二进制数，然后再按位进行 “与”运算。 1111011的第二位是0 4.按位或 | 两个相应的二进制位中只要有一个为１，该位的结果值为１。 ０|０＝０，０|１＝１， １|０＝１，１|１＝１ 大小写转换 大写写字母二进制第五位变成一1就是小写字母 32 100000 223 1101 1111 255 1111 1111 #include &lt;stdio.h> #include &lt;conio.h> void main() { char ch, temp; printf(\"请输入一个字母: \\n\"); ch = getchar(); temp = getchar();//吃一个回车 while( !(ch>'A' &amp;&amp; ch&lt;'z') || (ch > 'Z' &amp;&amp; ch &lt; 'a') ) { printf(\"输入有误, 请重新输入一个字母: \\n\"); ch = getchar(); } if( ch &amp; 32 ) { ch = ch &amp; 223; // 使第五位为0，变大写 } else { ch = ch | 32; // 使第五位为1，变小写 } putchar(ch); printf(\"\\n\"); } 5. 异或(XOR运算符)^ 若参加运算的两个二进制位同号则结果为0(假)，异号则结果为１(真) 即:0^0=0，0^1=1，1^0=1， 1^1=0 使特定位翻转 比如低4位翻转 与0相^，保留原值 交换两个值 a=a^b; b=b^a; a=a^b; ~是一个单目(元)运算符~，用来对一个二进制数按位取反，即将0变1,将1变0.","categories":[{"name":"大一","slug":"大一","permalink":"https://eyjafjalla6.github.io/categories/%E5%A4%A7%E4%B8%80/"}],"tags":[]},{"title":"C语言基础-上","slug":"C语言基础-上","date":"2023-10-05T07:15:42.000Z","updated":"2023-10-15T09:51:27.566Z","comments":true,"path":"2023/10/05/C语言基础-上/","link":"","permalink":"https://eyjafjalla6.github.io/2023/10/05/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%8A/","excerpt":"","text":"C语言基础-上 0基础 下载vc6，devc，visual studio 2022。建议visual studio 2022 1. 简介 1字节1B，1024b=1kb 内存四大区:CODE(代码区),DATA(全局数据区),STACK(栈),HEAP(堆内存) 一个C语言源程序是由函数组成. C语言本身没有输入输出语句 C语言中的标识符只能由字母、数字和下划线三种字符组成，且第一个字符必须为字母或下划线 下列可作为C语言赋值语句的是 i–; 目标程序是指源程序经编译可直接被计算机运行的 机器码 集合。目标程序文件的扩展名为.obj 函数一般由函数头和函数体组成 一个函数的函数体一般包括参数和返回值 程序是指一组计算机能识别和执行的指令 2. 简单快捷键 ctrl+s保存 vc6 alt+f8自动缩进 shift+tab往前缩进 tab往后缩进 visual studio 2022 ctrl+D 复制这行到下一行 3. 常见问题解决(重点) 判断整成赋值 a==1，a=1 忘记取地址符&amp; scanf(&quot;%d&quot;,&amp;a); 控制台按回车键，getch()会识别成\\r(13)，getchar()，scanf()会识别成\\n(10)。 scanf(“%c”,&amp;op)吃回车键的问题 //解决方法 scanf(\"%d%d\",&amp;a,&amp;b); fflush(stdin); scanf(\"%c\",&amp;op); //或者 scanf(\"%d%d\",&amp;a,&amp;b); getchar(); scanf(\"%c\",&amp;op); //或者 scanf(\"%d%d %c\",&amp;a,&amp;b,&amp;c); 转义输出 printf(\"\\\\ %%\");//输出\\ % 常见运算符顺序问题 a++*2;//相当于a*2;a++ switch漏break int a=2; switch(a)&#123; case 2: printf(&quot;2 &quot;); case 1: printf(&quot;1\\n&quot;);break; &#125;//2 1 visual studio 2022需要#define _CRT_SECURE_NO_WARNINGS 数组越界。(自己看着办) putchar(‘\\n’);表示字符要单引号，而不是双引号 (*pointer_1)相当于a，要打括号，因为从右往左结合 vc6和devc会把%hhu解析成%u导致unsigned char读取时出现数据覆盖问题。 4. 简单输入输出 #include &lt;stdio.h> int main(int argc, char *argv[]){ int a; scanf(\"%d\",&amp;a); printf(\"%d\",a); return 0; } 5. 注释方法 //这是行注释 /*多行 注释*/ #if(0)//if(0)不执行其中的代码 int a[3][4]={1,2,3}; #endif 1.数据类型 1. 储存空间和内存四大区 可以用sizeof(int)查看int类型的所占字节数 char&lt;int&lt;long int&lt;=float&lt;double printf(\"%d\",sizeof(int));//4 short 2 float 4 double 8 内存四大区：代码区，栈区(存放函数参数值，局部变量)，堆区（程序员分配），全局/静态区（放常量，全局变量）。 2. 数据类型 以下环境为64位windows 整型(默认向下取整) 占位符 字节 short %hd 2 int %d 4 long %ld 4 long long %lld 8 浮点型 float 单精度浮点型 %f 4 double 双精度浮点型 %lf 8 字符型 char (内存中以ASCII码储存) %c 1 布尔型(C99以后) bool (需包含stdbool.h) %hhu 1 _Bool %hhu 1 常量 除法3/2输出1，3.0/2输出1.5，(double)3/2输出1.500000 bool可以赋值为true(1),false(0)。 _Bool可以赋值为0或1。 整型四舍五入 int a; float b=5.6; a=b+0.5; 常见ascii码 字符 ascii码 0 48 A 65 a 97 空格 32 . 109 ! 33 char c[]=\"hello world\"; printf(\"%s\",c); 3. 常量 1. 整数常量 U 表示无符号整数（unsigned） 0x 或 0X 表示十六进制 0 表示八进制 U 表示无符号整数（unsigned） L 表示长整数（long） 212 /* 合法的 */ 215u /* 合法的 */ 0xFeeL /* 合法的 */ 078 /* 非法的：8 不是八进制的数字 */ 032UU /* 非法的：不能重复后缀 */ 2. 浮点常量 3.14159 /* 合法的 */ 314159E-5L /* 合法的 */ 1e-6 //表示1*(10^-6) 510E /* 非法的：不完整的指数 */ 210f /* 非法的：没有小数或指数 */ .e55 /* 非法的：缺少整数或分数 */ //e的前面不能没有数字，e的后面不能有小数。 3. 定义常量 用define或const定义常量。 #include&lt;stdio.h> #define WIDTH 5 #define NEWLINE '\\n' int main() { const int LENGTH = 10; int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0; } 4. printf 格式化输出(重点) 修饰词 %hh 限定输出格式为8位，即1个字节 %h 限定输出格式为16位，即2个字节 %l 限定输出格式为32位，即4个字节 %ll 限定输出格式为64位，即8个字节 占位符 空白符包括回车符\\r, 换行符 \\n, 制表符 \\t(Tab)。 %g 输出实数（f格式或e格式），系统根据数据占宽度m大小，自动选择占宽度较小的某种格式输出，不输出小数点后无意义的零，默认宽度为6。 ％d 整型(int)输出 ％ld 长整型(long)输出 ％s 输出字符串(char数组)，遇’\\0’停止。输入时，遇空白字符停止。 ％c char型，输出一个字符 %p 16进制打印指针的值 ％f 单精度浮点型(float)，默认情况下保留小数点6位，如1.000000。 %lf 是双精度浮点型，默认情况下保留小数点6位，通常用来输出double型 ％e 以指数形式输出实数 ％o 以八进制数形式输出整数 ％x 以十六进制数形式输出整数，或输出字符串的地址 %10d右对齐，%-10d左对齐，默认空格填充，%05d有0标志用0填充。 “%”与字母之间可以插入数字表示场宽，如%2d表示输出2位整型数，不够2位右对齐 %.2f用来输出小数，保留两位小数，如1.00 %g,%e,%f都会在精度的下一位四舍五入 %g默认保留六位有效数字输出 scanf(“%s”,s);这里不能有&amp;符号。 %m.ns。输出占m列，但只取字符串中的左端n个字符，这n个字符输入输出在m列的右则，左则补空格。 -%m.ns。n个字符输出在m列的左侧，右侧补空格。 注意：%d与%u有无符号的数值范围，也就是极限的值，不然数值打印出来会有误 #include &lt;stdio.h> int main(){ printf(\"%3s,%7.2s,%.4s,%-5.3s\\n\",\"china\",\"china\",\"china\",\"china\"); printf(\"%g,%g,%g\\n\",9.555555,123.55555,1234567.6666); return 0; } //china, ch,chin,chi //9.55556,123.556,1.23457e+006 5. 基本输入输出的方法（重点） 1. 详解 int i; char a[20]=‘hello world’; char b;char c;char d[50]; puts(a); 输出一个字符串遇到\\0转换为\\n,并结束输出。 gets(a); 读入一个字符串，长度应该小于字符数组，可以输入空格。(C99后淘汰) printf(“%d”,i); 格式化输出 scanf(“%d”,&amp;i); 格式化输入，scanf(%s)输入空格结束。 b=getchar(); 从输入缓冲区里面读取一个字符 putchar(b); 输出一个字符 c=getch(); 暂停输出控制台，直到按下一个键为止，它不使用任何缓冲区来存储输入字符，输入的字符将立即返回，而无需等待回车键，输入的字符不会显示在控制台上。需要&lt;conio.h&gt; c=getc(stdin); 从“流”中读入一个字符。stdin是标准输入流 ungetc(b,stdin); 将b中字符复制到输入流，可以用getchar()从输入流取出。 sprintf(d,“miku, %s\\n”,a); 将格式化的数据写入字符串d中。 scanf()返回值 scanf(“%d %d”, &amp;a, &amp;b); a,b都正确输入，返回2（正确输入了两个变量）; a,b中正确输入了一个变量,返回1。 0 表示用户的输入不匹配，无法正确输入任何值。 EOF 这是在stdio.h里面定义的常量（通常值为-1，表示输入流已经结束， 遇到错误或者end of file） 结束输入流的方法：ctrl+z，回车。 #include &lt;stdio.h> int main(){ int a; do { printf(\"请输入一串正整数: \"); while (scanf(\"%d\", &amp;a) != 1) {//如果读取的不是整数(返回值不为1) printf(\"请输入一串正整数: \"); /* %后面跟*表示跳过相应的输入程序 scanf(\"%*d %d\",a);输入66 55只会把55赋值给a，而忽略%*d读取的66 */ scanf(\"%*[^\\n]\");//清除输入流的非数字字符，这边除了换行符都清理了 } } while (a&lt;=0); printf(\"你输入的数字是%d \\n\",a);// \\n换行 return 0; } 2. 实际操作 //连续读一串数字 #include &lt;stdio.h> int main(){ int a; while (scanf(\"%d\", &amp;a) != -1) {//如果输入流没结束(没按ctrl+z然后回车) //注意，如果输入e，scanf会返回0，进入死循环，打印奇怪的内容。 printf(\"%d \",a); } printf(\"\\n\"); return 0; } //输入1 2 3 4 5 //屏蔽操作 #include &lt;stdio.h> #include &lt;stdlib.h> int main(){ int a; int sum=0; char ch; while (scanf(\"%d\", &amp;a) == 1) {//scanf正常接收输入 sum+=a; while((ch=getchar())==' ');//只屏蔽空格 if(ch=='\\n'){ break;//结束while循环 } ungetc(ch,stdin);//将ch的值放回stdin输入流 } printf(\"总数:%d\\n\",sum); return 0; } 66 55 44 //a第一次值为66，ch第一次为' '，然后ch为'5'，然后ch的值放回输入流,a第二次值为55 总数:165 //隐蔽输入 #include &lt;stdio.h> #include&lt;conio.h> int main() { char a = 'A'; char b[20] = \"hello \\0world\"; char c; int i=0; char password[20] = { 0 }; while (1) {//visual studio 2022写法 c = _getch();//实现隐蔽输入 if (c == '\\r') {//遇回车键跳出循环 break; } password[i] = c; i++; } putchar(a);//打印字符 puts(b); puts(password); _getch();//让程序停一下,敲一个回车就停 return 0; } 3. 指针的打印 #include &lt;stdio.h> int main () { int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ ip = &amp;var; /* 指针存储 var 的地址 */ printf(\"var变量的地址: %p\\n\", &amp;var ); printf(\"指针的值,也就是var的地址: %p\\n\", ip );//输出指针的值，也就是var的地址 printf(\"指针指向的值，也就是var的值: %d\\n\", *ip );//指针解引用，输出指针指向的值。 //指针的值是一个地址，这个地址对应的内存存放着数据。 return 0; } 输出： var变量的地址: 0000002267CFF8F4 指针的值,也就是var的地址: 0000002267CFF8F4 指针指向的值，也就是var的值: 20 6. 强制类型转换 int a=5; double b=a; double c=(double)a; #include&lt;stdlib.h&gt; int atoi(const char* str) //字符串转为整数 double atof(const char* str) //字符串转为浮点数 long int atol(const char* str) //字符串转为长整型 7. math.h库常见函数 #include&lt;math.h&gt; double pow(x, y)：x^y，x的y次幂 float powf(float x,float y); 功能与pow一致，只是输入与输出皆为浮点数 double modf(double value,double *iptr);拆分value值，返回它的小数部分，iptr指向整数部分。 double sqrt(x)：x的平方根 double exp(x)：指数函数 e^x，e ≈ 2.718 double log(x)：自然对数函数 ln(x)，x &gt; 0 double log10(x)：以10为底的对数log10(x)，x &gt; 0 绝对值 int abs(int i); 求整型的绝对值 double fabs (double);求实型的绝对值 double cabs(struct complex znum);求复数的绝对值 取整，取余 double ceil (double); 取上整，返回不比x小的最小整数 double floor (double); 取下整，返回不比x大的最大整数 三角函数 double sin (double a); a的正弦值 double cos (double a); a的余弦值 double tan (double a); a的正切值 三.分支结构 1. if…else if…else #include&lt;stdio.h> int main() { int a; printf(\"输入成绩(整数)：\"); scanf(\"%d\",&amp;a); if(a&lt;60) { printf(\"不及格\\n\"); }else if(a&lt;80){ printf(\"良好\\n\"); }else{ printf(\"优秀\\n\"); } return 0; } 2. switch c语言中很显然int, short, long, enum, char(包括无符号类型和long long)都可以作为switch变量 在switch语句中每一个的case常量表达式的值不可以相同。 常见问题7。 char a; a=getc(stdin);//从输入流读入一个字符 switch(a){ case 'a':printf(\"a\"); break; case 'b': printf(\"b\"); break; default: printf(\"no\"); return 0; } 四. 运算符与顺序问题 逻辑运算符两侧运算对象的数据类型可以是任何类型的数据. &amp;&amp; 两边为真才是真 || 其中一边是真才是真 优先级顺序表 优先级 运算符 名称或含义 使用形式 结合方向 说明 1 [] 数组下标 数组名[常量表达式] 左到右 – () 圆括号 (表达式）/函数名(形参表) – . 成员选择（对象） 对象.成员名 – -&gt; 成员选择（指针） 对象指针-&gt;成员名 – 2 - 负号 -表达式 右到左 单目运算符 ~ 按位取反运算符 ~表达式 ++ 自增运算符 变量名/变量名 – 自减运算符 –变量名/变量名– ***** 取值运算符 *指针变量 &amp; 取地址运算符 &amp;变量名 ! 逻辑非运算符 !表达式 (类型) 强制类型转换 (数据类型)表达式 – sizeof 长度运算符 sizeof(表达式) – 3 / 除 表达式/表达式 左到右 双目运算符 ***** 乘 表达式*表达式 % 余数（取模） 整型表达式%整型表达式 4 + 加 表达式+表达式 左到右 双目运算符 - 减 表达式-表达式 5 &lt;&lt; 左移 变量&lt;&lt;表达式 左到右 双目运算符 &gt;&gt; 右移 变量&gt;&gt;表达式 6 &gt; 大于 表达式&gt;表达式 左到右 双目运算符 &gt;= 大于等于 表达式&gt;=表达式 &lt; 小于 表达式&lt;表达式 &lt;= 小于等于 表达式&lt;=表达式 7 == 等于 表达式==表达式 左到右 双目运算符 ！= 不等于 表达式!= 表达式 8 &amp; 按位与 表达式&amp;表达式 左到右 双目运算符 9 ^ 按位异或 表达式^表达式 左到右 双目运算符 10 | 按位或 表达式|表达式 左到右 双目运算符 11 &amp;&amp; 逻辑与 表达式&amp;&amp;表达式 左到右 双目运算符 12 || 逻辑或 表达式||表达式 左到右 双目运算符 13 ?: 条件运算符 表达式1? 表达式2: 表达式3 右到左 三目运算符 14 = 赋值运算符 变量=表达式 右到左 – /= 除后赋值 变量/=表达式 – *= 乘后赋值 变量*=表达式 – %= 取模后赋值 变量%=表达式 – += 加后赋值 变量+=表达式 – -= 减后赋值 变量-=表达式 – &lt;&lt;= 左移后赋值 变量&lt;&lt;=表达式 – &gt;&gt;= 右移后赋值 变量&gt;&gt;=表达式 – &amp;= 按位与后赋值 变量&amp;=表达式 – ^= 按位异或后赋值 变量^=表达式 – |= 按位或后赋值 变量|=表达式 – 15 ， 逗号运算符 表达式,表达式,… 左到右 – x&gt;y?x:y 若x&gt;y为真则返回x，否则返回y 赋值相关 { int a=2,b=4,c=6,x,y; y=((x=a+b),(b+c));//这里的y才=10。 y=(x=a+b),(b+c);//这里的y就直接等于6了 printf(\"y=%d,x=%d\",y,x); } //关于i++,i--赋值，是从右往左开始算的 #include&lt;stdio.h> void main() { int i=0; printf(\"%d %d %d %d %d %d %d %d\",i,++i,-i--,++i,i,i++,i,i++); }//i++好像没反应 //输出 2 2 -1 1 0 0 0 0 五.循环语句 0. 单步调试方法 F9插入断点开始调试 F11（汇编跟踪到循环语句）一般黄箭头在c=max(a,b)这行时用，然后进入被调用的函数中 F10常用的，运行下一步 1. while int i,sum=0; while(i&lt;=100){ sum += i; i++; } 2. do…while… do-while循环中，根据情况可以省略while 先执行再判断while真假 do { i++; }while(i&lt;=100); 3. for嵌套 #先执行最内层for，这里因为内部嵌套每次只输出一个字符，所以可用putchar('A')代替printf(\"%c\",'*') #for(;;)相当于while(1)会一直循环 #for(表达式1;表达式2;表达式3) /* 1.先求解表达式1； 2.求解表达式2,其值为真(非0),则执行for循环语句中的内嵌语句,然后执行第3步,其值为假,则结束循环,转到第五步. 3.求解表达式3. 4.转回上面第二步继续执行. 5.循环结束，执行for语句下面一个语句 */ 在字符数组中’\\0’是占一个位置的！ 例如 定义char c[6]=“hello”，而在内存中字符数组 c 则是\"hello\\0\"； #include &lt;stdio.h> void main (){ int b,a; for(b=1;b&lt;7;b++){ for(a=0;a&lt;b;a++){ printf(\"*\"); } printf(\"\\n\"); } } * ** *** **** ***** ****** 5. break，continue break一次只跳出一层循环 while,do while,for可以用break跳出循环,continue结束本次循环，然后进入下次循环 goto,if语句不能break,continue进行控制，也就是说if语句里面的break终止的是if外一层的循环(比如for，while啥的) #include &lt;conio.h> void main(){ int i=0; char c; while(1){ c='\\0';//变量赋初值 while(c!=13&amp;&amp;c!=27)//键盘接受字符直到按回车或者esc { c=getch();//，字符输入函数，不回显函数，无需按回车，要求头文件&lt;conio.h> printf(\"%c\\n\",c); } if(c==27) break;//判断若esc键则跳出循环 i++;//按下回键，i++ printf(\"The number is %d\\n\",i); } printf(\"The end\"); } 6.精度判断,算pi 近似公式pi/4约等于1-1/3+1/5-1/7+… 1e-6表示1*(10^-6) #include&lt;stdio.h> #include&lt;math.h> void main(){ int s;float n,t,pi; t=1;pi=0;n=1.0;s=1; while(fabs(t)>1e-6) { pi=pi+t;n+=2;s=-s;t=s/n; } pi=pi*4; printf(\"pi=%10.6f\\n\",pi);//如果输出的长度小于10则会在结果左端补充空格(右对齐) /*float k=6.0;printf(\"%5.1f\\n\",k);左端空格为2个*/ } 7.素数判断 思路：让m被2到k整除，k=sqrt(m),for(i=2;i&lt;=k;i++),n%i==0 8.斐波那契 思路：f1,f2覆盖过去就行了,比如f1=f1+f2 六.数组 1. 简介+string.h 一维数组 类型说明符 数组名[常量表达式]; 整型数组int a[10];有十个元素，从a[0]到a[9],不存在a[10] vc中int 4字节，float 8字节 对于同一个数组，其所有元素的数据类型都是相同的 允许int a,b,c,d,k1[10],k2[20]; C语言不允许对数组大小作动态定义（不能变量说明数组大小），即int n; scanf(“%d”,&amp;n);int a[n];是不允许的 float a[0]没有意义 合法的a[0]=a[2]+a[5]-a[2*3];引用中a[i+j];引用中a[i++] 在c语言中只能逐个使用下标变量，不能一次性使用整个数组 #string.h strcmp(字符数组一，字符数组二)字符数组一比较字符串 strlen(字符数组)求字符串长度 strlwr(字符数组)大写换小写 strupr(字符数组)小写换大写 strcat(char* s1,char* s2)字符串2拼接到字符串1末尾，删掉字符数组1末尾的\\0 strcpy() 将一个字符串复制到另一块空间地址中 的函数，‘\\0’是停止拷贝的终止条件，同时也会将 '\\0' 也复制到目标空间。 strstr()用于找到子串在一个字符串中第一次出现的位置 #include &lt;stdlib.h> atoi字符串转换为整型 atof字符串转换为浮点型 atol字符串转换为长整型 '2'-48=2 #一维数组在内存的存放 int mark[100]; 低地址 86 mark[0] 92 mark[1] 77 mark[2] 52 mark[3] ... 高地址 94 mark[99] 86占四个字节（每个数据元素占用的字节数，就是基类型的字节数，一个元素占4个字节） 2. 数组赋值 int i,a[0]; for(i=0;i&lt;=9;i++) { scanf(\"%d\",&amp;a[i]);//动态赋值,每输入一次要回车，赋值还可以a[i]=i; } for(i=9;i>=0;i--) { printf(\"%d\",a[i]); } 3. 初始化赋值 字符数组中可以存放ASCII字符集中的任何字符 字符数组的字符串可以整体输入、输出 不可以用关系运算符对字符数组中的字符串进行比较 假设有char a[10]=“abc”;则strlen(a)的值为3。 int a[10]={1,2,3,4,5}//这时候a[8]=0 int a[10];//这时候a[0]是乱码 int a[]={1,2,3,4,5,6,7}//可以不指定数组长度 //要防止越界问题字符串末尾默认是\\0 char s[6] = {\"ABCDE\"}; //这个系统可以自动添加 char s[6] = {’A’, 'B’, 'C’, 'D’, 'E’ ,'\\0'}; //这个需要自己手动添加。 //下面两个，a的长度比b长 char a[ ]=\"ABCDEF\"; char b[ ]={'A', 'B', 'C', 'D', 'E', 'F'}; 4. 数组求解斐波那契 公式求解 #include&lt;stdio.h> void main(){ int i; int a[20]={1,1}; for(i=2;i&lt;20;i++) { a[i]=a[i-2]+a[i-1]; } for(i=0;i&lt;20;i++){ if(0==i%5){ printf(\"\\n\"); } printf(\"%12d\",a[i]); } printf(\"\\n\"); } 5. 冒泡排序 相邻数比较,小的冒泡上排，大的沉底, n个数，进行n-1趟比较，第一趟比较进行n-1次两两比较，第j趟进行n-j次两两比较 #include&lt;stdio.h> void main(){ int a[10]; int i,j,t; printf(\"input 10 number:\\n\"); for(i=0;i&lt;10;i++) { scanf(\"%d\",&amp;a[i]);//1.用户输入十个数 } printf(\"\\n\"); for(j=0;j&lt;9;j++) { for(i=0;i&lt;9-j;i++)//n-j次两两比较 { if(a[i]>a[i+1]) { t=a[i];a[i]=a[i+1];a[i+1]=t;//两数替换 //这边可以加个flag=0;减少次数 } } } printf(\"the sorted number is:\\n\"); for(i=0;i&lt;10;i++) { printf(\"%d >>\",a[i]); } printf(\"\\n\"); } 6.二维数组 类型说明符 数组名 [常量表达式] [常量表达式]; 在c语言中，二维数组是按照行排列的 多维数组第一维的下标量变化最慢 a[3][4]//三行四列，第一个a[0][0] 1. 二维数组引用和初始化 int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; 也可以(第二维长度必须指定) int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12}; int a[3][4]={{1},{0,6},{0,0,11}};//a[0][0]=1;第二行第二个6;第三行第三个11 int a[3][4]={{1},{5},{9}};//初始化的是每一行的第一个元素,其他初始化为0!!a[0][0]=1,a[1][0]=5,a[0][1]=0 int a[3][4]={1,5,9};//初始化的是第一行的三个元素 2. getchar输入二维数组（重点） #include&lt;stdio.h> #include&lt;math.h> #include&lt;string.h> int main() { int i=1,j=0,n; char a[21][21],ch; scanf(\"%d\",&amp;n); getchar();//吃一个回车 for(i=1;i&lt;=n;i++) { while((ch=getchar())!='\\n') { //用ch避免数组吃回车 a[i][j]=ch; j++; } a[i][j]='\\0';//数组末尾补0 j=0; } for(i=1;i&lt;=n;i++){ puts(a[i]);//从a[1][0]开始打印第1行，遇到\\0结束 } return 0; } 7. 二分法查找 有个数组从小到大排列,找其中的一个数 选定区域查找,每次搜索范围缩小一半 需要low,mid,high分别指向开始,中间,末尾 #define M 10 //宏定义,没分号 #include &lt;stdio.h> void main() { static int a[M]={-12,0,6,16,23,56,80,100,110,115};//普通变量存放在栈区,static变量存放在data区 int n,low,high,mid,found; low=0;high=M-1;found=0; printf(\"input a number to be search:\"); scanf(\"%d\",&amp;n);//预处理步骤, /*scanf可以改进一下 do { scanf(\"%d\",&amp;n); getchar(); }while(n&lt;a[0]||n>a[M-1]); */ while(low&lt;=high) { mid=(low+high)/2; if(n==a[mid]) { found=1;break; }//找到,结束循环 else if(n>a[mid]) low=mid+1;//若low=mid后面如果high=n,low在n前面一个元素,mid没法指到n else high=mid-1; } if(found==1) printf(\"the index of %d is %d\",n,mid); else printf(\"there is no %d\",n); } 8. 中文字符串（宽字符和多字节字符） 用visual studio 2022 #include &lt;stdio.h> #include &lt;string.h> #include &lt;stdlib.h> #include &lt;locale.h> #include &lt;wchar.h> int main() { setlocale(LC_ALL,\"\");//utf-8一个中文占三字节 int cont=0; //wchar_t *a=L\"春天\"; char *a=\"春天\"; char b[20]; char c[20]={\"你好再见\"}; //cont=wcstombs(b,a,20); c[0]=*a; c[1]=*(a+1); c[2]=*(a+2); printf(\"%s\",c); return 0; } 输出 春好再见 #include &lt;stdio.h> #include &lt;string.h> #include &lt;stdlib.h> #include &lt;locale.h> #include &lt;wchar.h> int main() { setlocale(LC_ALL,\"\");//软件运行时的语言环境 //utf-8一个中文占三字节 int cont=0; wchar_t *a=L\"春天\"; char b[20]; char c[20]={\"你好再见\"}; cont=wcstombs(b,a,20);//宽字符转化成多字节字符 c[0]=b[0]; c[1]=b[1]; c[2]=b[2]; printf(\"%s\",c); return 0; } 输出 春好再见 七.函数 0. 概念 所有函数是平行的，即在定义函数时是分别进行的，是相互独立的。 函数不能嵌套定义，但可以嵌套调用 函数可以相互调用，但不能调用main函数，main函数是系统调用的。 程序从main函数开始，在main函数中调用其他函数，调用后流程回到main函数，在main函数中结束整个程序运行。 用户角度函数有两种：标准函数（库函数），用户自定义函数。 函数形式来看，函数分为两类：无参函数（主函数不向被调用函数传递数据，一般用来执行指定的一组操作），有参函数(主函数通过参数向被调用函数传递数据，执行被调用函数会得到一个函数值，供主函数使用)。 在主函数中调用（不是声明）一个函数时，函数名后面的括弧中的参数（可以是一个表达式）称为实际参数（简称实参）。 有参函数中定义函数时，函数名后面的括弧中的变量名称为形式参数（简称形参）。 return后面的括弧中的值（）作为函数带回的值（简称函数返回值）。 在不同函数间传递数据，可以使用的法：参数：通过形式参数和实际参数，返回值：用return语句返回计算结果。全局变量：外部变量。 形参在未出现函数调用之前不占内存中的储存单元，并且在调用结束后形参所占的储存单元也被释放。 实参可以是常量，变量或表达式（比如3，a+b,x&gt;y?x:y）但要有确定的值，在调用时将实参的值赋给形参。 在被定义的函数中，必须指定形参的类型int x 形参或实参的类型赋值兼容或相同 内存中实参单元和形参单元是不同单元。实参对形参的数据传递是值传递（相当于copy，实参保留原值），单向传递，只能由实参传递给形参。 一个函数的函数体一般包括参数和返回值 如果在一个函数中的复合语句中定义了一个变量，则该变量只在该复合语句中有效 在函数内定义的变量只在本函数范围内有效 在不同函数中可以使用同名字的变量 形式参数是局部变量 下面函数调用语句含有实参的个数为2。 (x1,x2)实际上只取了x2做参数，(x3,x4,x5)实际上只取了x5做参数； func((exp1, exp2), (exp3, exp4, exp5)); 如果形参与实参的类型不一致，以形参类型为准 如果函数值的类型与返回值类型不一致，以函数值类型为准 函数的实参可以是常量，变量或者表达式，但是函数形参不能是常量 形参，实参可以为任意类型 C语言规定，简单变量作为实参时，它和对应形参之间的数据传递方式是单向值传递。 若使用一维数组名作为函数实参，则以下正确的说法是必须在主调函数中说明此数组的大小 C语言规定，函数返回值的类型是由在定义该函数时所指定的函数类型所决定 1.定义函数 //定义无参函数 void pt(){ int a=10;//声明部分 printf(\"%d\\n\",a);//语句部分 } //定义有参函数 double square(double a){ char c[30]=\"square is used\"; printf(\"%s\",c); return a*a;//返回值跟函数同一类型double } //定义空函数 dummy(){}//相当于int dummy(){} 2.调用函数时数据的传递 #include &lt;stdio.h> void main() { float max(float x,float y);//被调用函数的声明在主调函数之后，要对max函数的声明，里面是形参 float a,b,c; scanf(\"%f,%f\",&amp;a,&amp;b);//例如输入11.2,13.9 c=max(a,b);//实参 printf(\"max is %f\\n\",c); } float max(float x,float y) { float z; z=x>y?x:y; return(z);//函数返回值通过return语句获得 } 3.函数返回值 return z;等价于return (z); 函数返回值应属于某一确定类型，在定义函数时指定函数的返回类型。 在c语言中，凡是不加类型说明的函数，自动按整形处理。（c++所有函数要指定函数类型） 对不带回值的函数，应该用void定义函数为无类型（空类型）。（此函数不带return） 4.函数的调用 一般调用：函数名(实参表列) vc6，visual studio 2022对实参求值的顺序是自右向左调用 _cdecl方法，stdcall方法都是自右向左调用 //对于函数调用 int i=2,p; p=f(i,++i); //如果按自左向右求参的值，则函数调用相当于f(2,3) //如果按自右向左求参的值，则函数调用相当于f(3,3) #include &lt;stdio.h> void main() { int f(int a,int b); int i=2,p; p=f(i,++i); printf(\"%d\\n\",p); } int f(int a,int b) { int c; if(a>b)c=1; else if(a==b)c=0; else c=-1; return(c); } 5.函数调用方式 //用函数语句 printstar(); //函数表达式 c=2*max(a,b); //函数参数，函数调用作为一个函数的实参 m=max(a,max(b,c));//先运行里面那个 printf(\"%d\",max(a,b)); 6.对被调用函数的声明和函数原型 首先被调用的函数必须是已经存在的函数（是库函数或用户自己定义的函数）。 如果使用库函数，在本文件开头用include语句把头文件包含进来 如果使用用户自己定义的函数，而该函数的位置在调用它的函数（即主调函数）的后面(在同一个文件中)，应该在主调函数中对被调用函数作声明。 声明（declaration）作用是把函数名，函数参数个数，参数类型等信息通知给编译系统，以便在遇到函数调用时，编译系统能正确识别函数并检查调用是否合法。（不占内存） 函数定义是指对函数功能的确立（占内存） 如果被调用函数的声明在主调函数之前，可以不必加以声明。 #include &lt;stdio.h> int f(int a,int b) { int c; if(a>b)c=1; else if(a==b)c=0; else c=-1; return(c); } void main() { int f(int a,int b); //被调函数在主调函数前，上面一行可以不写 int i=2,p; p=f(i,++i); printf(\"%d\\n\",p); } 7.自敲pow函数 #include&lt;stdio.h> void main(void) { double power(double x,double y); printf(\"%lf\",power(2,3)); } double power(double x,double y) { double z=1; while(y) { z*=x; --y; } return z; } 8.自敲sqrt函数(不好,只能整数部分) #include&lt;stdio.h> int sqrt_02(int question) { int temp=question/2; while(temp--) { if((temp*temp)&lt;=question) return temp; } return -1; } void main(void) { int question=49,answer; answer=sqrt_02(question); if(answer&lt;0) printf(\"error\"); else printf(\"question is %d,and answer is %d\",question,answer); } 9.嵌套调用函数 return返回上一层函数 计算s=(22)!+(32)! 需要定义的函数 factorial计算阶乘 square计算平方值 #include &lt;stdio.h> long square(int p); long factorial(int q);//声明 void main() { int i; long s = 0; s = square(2) + square(3); printf(\"%ld\\n\", s); } //定义square long square(int p) { int k; long r; k = p * p; r = factorial(k); return r; } long factorial(int q) { long c = 1; int i; for (i = 1; i &lt;= q; i++) { c *= i;//迭代 } return c; } 10.递归调用（recursion） 在调用一个函数的过程中，直接或者间接地又调用该函数本身，称为递归调用 //计算n! //0!=1 #include &lt;stdio.h> long rc(int n); void main() { int n; long result; scanf(\"%d\", &amp;n); result = rc(n); printf(\"%d!=%ld\\n\", n, result); } long rc(int n) { long t; if (n &lt; 0) printf(\"n&lt;0,input error!\\n\");//结束递归 else if (n == 0 || n == 1) t = 1;//结束递归 else t = rc(n - 1) * n;//递归，调用这个调用函数 return t; } 取牌游戏 游戏规则: 桌面有12张牌，玩家和机器人轮流取牌，每次只能取走1~3张，玩家先取,取走最后一张牌的一方失败。请证明玩家必赢。 #include &lt;stdio.h> #include &lt;stdbool.h> int x, z;//数组坐标 int d = 0;//递归深度 int b[15][20] = { 0 }; bool canWin(int n) { d++;//深度+1 if (n &lt;= 0) { d--; return true;//0张牌时，自己赢 } int i; for (i = 1; i &lt;= 3; i++) { // 尝试取1~3张牌 if (!canWin(n - i)) { //存在子负己胜 (对方输，自己赢) //if,()里面canwin的返回值是对方赢或者输 if (d % 2 == 1) {//人类赢，记录 b[x][d] = i; } else {//机器赢 b[x][d] = 0;//清空这一块 } d--;//递归返回，深度-1 return true; } } //不存在子负己胜==任意子胜己负 if (d % 2 == 0) { //机器人输，记录 if (n == 1) { b[x][d] = 1;//剩一张牌时，取1 } else { b[x][d] = (i==4?3:i); } } else {//人类输 b[x][d] = 0; } d--;//递归返回，深度-1 return false; } void pt(int n) { int i = 0, j = 1; while (1) { if (b[n][j] != 0) { printf(\"%d \", b[n][j]); j++;//列号++ } else { printf(\"\\n\");//换行 break; } } } int main() { x = 0, z = 0; int n; for (n = 4; n &lt;= 12; n++) { x = n; if (canWin(n)) { printf(\"剩下%d 张牌先手必赢 \\n\", n); pt(x); } } return 0; } 11.数组元素作为函数的实参 //只要数组类型和函数的形参变量类型一致 int a[10]={1,2,3,4,5,6}; int i; for(i=0;i&lt;10;i++) { test(a[i]); } void test(int v)//这里形参可以不是数组 { if(v>0) { printf(\"%d\",v); } } 12.数组名作为函数参数 //形参和实参必须类型相同的数组 //进行址传递（形参数组不被分配内存） //形参数组和实参数组指向同一段内存空间 //数组名是第一个元素的地址 #include&lt;stdio.h> void test(int b[10]); void main() { int a[10]={1,2,3,4,5,6,7,8,9,10}; test(a); putchar('\\n'); } void test(int b[10]) { int i=0; for(;i&lt;5;i++) { printf(\"%d\",b[i]); } } 求平均成绩 //一维数组score,10学生成绩, #include&lt;stdio.h> double average(double array[10]); void main() { double score[10]={82,100,87.5,89,78,85,67.5,92.5,93,94},result; result=average(score); printf(\"average score is %5.2lf\\n\",result); putchar('\\n'); } double average(double array[10]) { double result=0; int i=0; for(i=0;i&lt;10;i++) { result+=array[i]; } result/=10; return result; } } 形参数组不定义长度 double average(double array[]) //形参array里面不写元素个数或者乱写都可以 13.局部变量（按变量的作用域来分） 形参也相当于局部变量，只在该函数里有效 主函数定义的变量也只在主函数里有效 不同函数里可以使用相同名字的变量，他们代表不同的对象，互不干扰。 在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为分程序或者程序块。（见下面1-2） 1-1 float float(int a)//函数f1 { int b,c;//a,b,c有效 } char f2(int x,int y)//函数f2 { int i,j;//x,y,i,j有效 } void main()//主函数 { int m,n;//m,n有效 } 1-2 void main() { int a,b;//出了括号,这里c就无效了 { int c; c=a+b;//c在此范围内有效，a,b在此范围内有效 } } 14.全局变量 在函数外部定义的变量为外部变量，也就是全局变量。（全程变量） 全局变量可以为本文件中其他函数所共用。他的有效范围为从定义变量的位置开始到本源文件结束。 全局变量在程序的全部执行过程中都占用储存单元，而不是仅在需要的时候才开辟单元。过多会降低程序清晰度。 从一个文件复制函数到另一个文件时，全局变量也要移过去，很麻烦。 int p,q;//全局有效 float float(int a)//函数f1 { int b,c;//a,b,c,q,p有效 } char f2(int x,int y)//函数f2 { int i,j;//x,y,i,j,p,q有效 } void main()//主函数 { int m,n;//m,n,p,q有效 } int vs(int a,int b,int c)//比如这样用 { int v; v=a*b*c; p=a*b; q=c*b; return v; } 15.变量存储类别（变量值存在的时间来分） 在c语言中每个变量和函数都有两属性：数据类型和数据的存储类别（数据在内存中的存储方式）。 存储方式分为两大类：静态存储类和动态存储类。 具体四种：自动(auto)，静态(static)，寄存器(register)，外部（extern） 动态存储 (auto变量,形参，register变量）（本函数有效） 静态存储 （静态局部变量，函数内有效） （static外部变量，本文件有效） （外部变量，其他文件可用） 动态存储方式 动态存储方式是在程序运行期间根据需要进行动态的分配存储空间的方式 静态存储方式 静态存储方式是在程序运行开始由系统分配固定存储空间的方式 1. auto变量 函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的栈，数据存储在动态存储区中。 调用时分配存储空间，调用后释放存储空间。 因此这类局部变量称为自动变量，用auto作为存储类别的声明。 关键字auto可以省略，auto不写则隐含定为自动存储类别，属于动态存储方式。 int f(int a) { auto int b,c=3;//定义a，b为自动变量 } auto int m相当于int m相当于auto m 2. 用static声明局部变量 有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，即其所占的存储单元不释放，在下次该函数调用时，该变量已有值，就是上一次函数调用结束时的值。 定义局部静态变量不赋入初值，则对静态局部变量来说，编译时自动赋初值为0（对数值型变量），或者空字符。 而对于自动变量来说，如果不赋入初值则它的值是一个不确定的值。（每次调用后存储单元会释放） 虽然静态局部变量在函数调用结束后任然存在，但是其他函数是不能引用它的。 #include&lt;stdio.h> int f(int a) { auto b=0;//相当于auto int b, //上面局部变量存储在栈 static int c=3;//静态变量存储在数据区 b=b+1; c=c+1; return(a+b+c); } void main() { int a=2,i; for(i=0;i&lt;3;i++) { printf(\"%d\\n\",f(a));//a作为形参传到另一个函数里 } } 3. register(寄存器)变量 如果有一些变量频繁地使用，每次循环都要引用某局部变量的值。对寄存器的存储速度远高于对内存的存储速度。 register所在子函数执行完毕立即释放。 #include&lt;stdio.h> int fac(int n) { register int i,f=1; for(i=1;i&lt;n;i++) { f*=i; } return f; }//计算阶乘 4. extern声明外部变量&amp;外部函数(重要) 用来扩展程序文件中的作用域 一般跟着全局变量用 //如果在定义函数时省略extern,则隐含为外部函数。 同一个项目下创建a.h,a.c //a.h #pragma once #ifndef _A_H_ #define _A_H_ #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h> #define N 8 extern int m[N][N];//声明m为一个已定义的外部数组 void pt(double a); #endif //a.c #define _CRT_SECURE_NO_WARNINGS #include\"a.h\" #include&lt;stdio.h> int m[N][N] = { 0 }; void fill() { register int i , j ; for (i=0; i &lt; N; i++) { for (j=0; j &lt; N; j++) { //防止数组越界，一般每行最后一位保证是0 m[i][j] = i + j; printf(\"%d \",m[i][j]); } putchar('\\n'); } } void pt(double a) { printf(\"%g\", a); } //主函数所在.c #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h> int main() { double a = 10.56; pt(a); putchar('\\n'); fill(); return 0; } 5. static声明外部变量 希望某些外部变量只限于被本文件引用，而不能被其他文件引用 static int A;只属于该文件 6. 关于变量声明与定义 定义性声明（要建立存储空间如int a）；引用性声明（不需建立存储空间如extern a）; int a既是声明又是定义；extern a只是声明不是定义； 八. C语言指针详解（重点） 0. 概念与选择题 1.直接访问,例如a=5，把5保存到地址为2000的单元 2.间接访问，例如scanf(“%d”,&amp;a);调用函数时，把变量a的地址传递给函数scanf,函数首先把该地址保存到一个单元中，然后把从键盘接收的数据通过所存储的地址保存到a变量中。//我觉得地址可以理解为单元的门牌，数据是里面住的人。 3.指针作为特殊变量，存放地址。 4.*取值操作符。&amp;取址操作符。 5.当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。 int **var; 6.指针变量之差是两个指针之间的元素个数 7.char *language[ ]=&#123;&quot;FORTRAN&quot;, &quot;BASIC&quot;, &quot;PASCAL&quot;, &quot;JAVA&quot;, &quot;C&quot;&#125;;其中*language[2]的值是字符P 8.main函数的正确说明形式是int main(int abc, char **abv) 9.若假设第一个printf语句输出的是ffca，则第二个printf语句的输出ffdc。 void main(){ short int a[10] = {2,4,6,8,10,12,14,16,18,20},*p; p = a; printf(\"%x\\n\", p); printf(\"%x\\n\", p+9); } 若有以下定义，则正确的程序段是( D )。 int *p, *s, i, j; char *q, ch; A) main() { *p = 100; ...}//p为野指针，解引用出问题 B) main() { p=&amp;ch; s=p; ...}//int指针把char当成int访问不必要内存 C) main() { p=&amp;i; q=&amp;ch; p=q; ...} D) `main() { p=&amp;i; q=&amp;ch; *p=40; *q=*p; ...}` 11.当main函数带有形参时，传给形参的值一般从命令行中得到 12.若有函数max(a,b)，并且已使函数指针变量p指向函数max，当调用该函数时，正确的调用方法是 (*p)(a,b); 13.若有以下定义和语句，则对a数组元素的正确引用为*(p[1]+1) 。 int a[2][3], (*p)[3] p=a; 14.指针变量和它指向的变量之间的关系，可以用指针运算符“*”表示。 15.这段代码是错误的，因为数组指针p的列没跟b的列一致。 int b[3][5], (*p)[3], (*q)[5]; p=b; q=b; 16.(不严谨)若有以下定义，且0&lt;=i&lt;4，则不正确的赋值语句是( B )。 int b[4][6], *p, *q[4]; A)q[i]=b[i]; B)p=b; C)p=b[i]; D)q[i]=&amp;b[0][0]; /*先右后左原则来看指针 q本质是int*s[]，q[i]本质int*s b表示整个二维数组，本质int*s[] b[i]本质int*s，p本质int*s &amp;b[i][j]本质int*s 单从类型对应角度选B */ 1. 指针常见形式详解（重要） 32bit架构内存地址长度4字节，32bit程序中指针大小4字节。 64bit架构内存地址长度8字节，64bit程序中指针大小8字节。 int* a,b; 等价于 int *a；int b；而不等价于 int *a; int *b; //定义指针变量,用来存放整型变量i的地址 int *i_pointer //间接存放i的值，可以先找到存放i的地址的变量i_pointer,从中取出i的地址(2000),然后取出i的值3 int i=2000; int *pointer;//1.这里*不是取值操作符，而是声明指针的特征(表示这是个指针变量，变量名为pointer) i_pointer=&amp;i;//2.&amp;取i的地址赋给i_pointer printf(\"%d\\n\",*pointer);//3.这个是取值操作符，进行指针解引用 void main() { int *a,*b,c; c=5; a=&amp;c;//指针a所在地址单元存放c的地址 b=a; printf(\"%d \",b);//指针b所在地址单元存放c的地址 } /*&amp;c *a *b 1703720 内容 1703720 1703720 地址 1703728 1703724 */ 辨认准则：找到变量名(没有就看最内部结构)，先向右看(不跳过括号)，然后向左看(不跳过括号)，然后跳出一层括号，重复上述操作。 //比如：int* a[5]; 首先向右看，它是一个5元素数组，然后向左看指向int类型，所以a是个有5个指向int类型指针的数组。 含义 int a[n] int数组 int *p[n] 指针数组p，由n个指向整型的指针元素构成 int (*p)[n] p为指向含n个元素的一维数组的指针变量 int f() f为带回一个整型函数值的函数 int *p() p为带回一个指针的函数，该指针指向整形数据 int (*p)() p为指向函数的指针，该函数返回整型值 int **p p为指针变量（二级指针），存放一级指针地址，一级指针指向int变量 int (*(*v)[])() v是一个指针，指向一个数组，数组元素是指针，每个指针指向一个int函数。 *&amp;a等价于变量a &amp;*a等价于&amp;a #include&lt;stdio.h> #include&lt;string.h> #include &lt;malloc.h> void main() { char *str=NULL; int s=30; str=fa(s); printf(\"str=%s\\n\",str);//printf(%s)需要的是一个地址，然后从这个地址开始打印字符串遇到空格或\\0停止 free(str);//防止内存泄漏。free()只能释放指针所指向的那片内存。 str=NULL;//防止产生野指针 system(pause); } char* fa(int x)//指针数组带回一个指针 { char *pstr=NULL; x++; pstr=fb(10); return pstr;//指针变量pstr到这里结束 } char* fb(int m) { char *pa=\"123456\";//pa指针在栈区 //123456在堆区 char *p=NULL; //指针变量在栈区分配4字节 {int i=30;} p=(char *)malloc(100); //malloc函数开辟一块堆区存储空间, strcpy(p,\"wudunxiong 123456\"); //wudongxiong 123456在常量区 return p;//返回给主调函数fa() } 2. 野指针 野指针是指程序员或操作者不能控制的指针。野指针不是NULL指针，而是指向“垃圾”的指针。 造成“野指针”的原因主要有： 1.指针变量没有初始化，任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指。在初始化的时候要么指向合法的指针，要么指向NULL。 2.指针变量被free或delete之后，没有设置为NULL。它们只是把指针所指的内存给释放掉，但指针本身还有值。 3.指针操作超越了变量的作用范围。 注意其生命周期。 3. 编写swap的注意 int main() { int a=10, b=20; printf(\"a=%d,b=%d\\n\", a, b); swap(&amp;a, &amp;b); printf(\"a=%d,b=%d\\n\", a, b); return 0; } void swap(int p, int q) { int t; t=p; p=q; q=t; } 上面代码是错的，p，q不指向a，b，没法改值。 修改后的swap函数可以是： void swap( int *p, int *q ) {int t; t=*p; *p=*q; *q=t; } 4. 指针的使用 //错误示范 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdlib.h> #include &lt;stdio.h> typedef struct node { int data; struct node* next; }node; void create(node *h){ h = (node*)malloc(sizeof(node)); //此时h!=NULL,head==NULL h->data = 10; } int main() { int i, j; node* head=NULL; create(head);//值传递,h=head=NULL printf(\"%d\", head->data); //报错，因为一级指针并没影响到head指针 return 0; } //更正方法1: 返回一级指针 node* create(node *h){ h = (node*)malloc(sizeof(node)); h->data = 10; return h; } head=create(head); //更正方法2: 用二级指针指向一级指针实现引用传递 void create(node **h){ *h = (node*)malloc(sizeof(node)); (*h)->data = 10; } create(&amp;head); 2.指针变量定义 变量的地址称为该变量的指针。（指针变量的值是一个地址） 专门用来存放变量地址的变量，称为指针变量。 定义一般形式：类型说明符 *变量名 &amp;a表示a的地址 如果将一个整数赋给一个指针变量，那么编译器会把该值当成一个地址来处理。 //合法定义 char a='A';int *p=&amp;a;//&amp;a是a的地址(一个整数) //非法定义 double b = 66.6; int* p = b; //b不是整数不能代表一段地址 注意：(*pointer_1)相当于a，要打括号，因为从右往左结合 3.指针做函数参数 #include&lt;stdio.h> void swap(int *p1,int *p2); void main() { int a,b; int *pointer_1,*pointer_2; scanf(\"%d%d\",&amp;a,&amp;b); pointer_1=&amp;a; pointer_2=&amp;b; if(a&lt;b) { swap(pointer_1,pointer_2); }//此后p1指向b，p2指向a printf(\"%d > %d\\n\",a,b); //这里也可以是*pointer_1,*pointer_2 } void swap(int *p1,int *p2)//*声明指针变量 { int temp; printf(\"I'm swapping······\\n\"); temp=*p1;//用了取值操作符，所以temp=a; *p1=*p2; *p2=temp; } 4.数组与指针 一个数组包含若干元素，每个数组元素都在内存中占用存储单元，但它们都有相应的地址。 数组名翻译成数组第一个元素的地址。 p=&amp;a[0]; p=&amp;*(a+i);//比如p=&amp;*(a+1); *(p+i) 1. 数组名作函数参数 f(int arr[],int n)编译时将arr按照指针处理（数组名代表数组首元素地址），相当于将函数f的首部写成f(int *arr,int n) reverse(a,10);//实参a是一个一维数组 void reverse(int *x,int n)//形参x为指针变量 {} 2. 多维数组和指针（重点） 定义一个a[3] [4]，地址排列类似一维数组 一维数组取出的值是二维数组的地址例如*(a+1) 表现形式 含义 地址（例如） a 二维数组名，指向以维护组a[0],即0行首地址 2000 a[0],*(a+0),*a 0行0列元素地址 2000 a+1,&amp;a[1] 1行首地址 2016 a[1],*(a+1) 1行0列元素a[1] [0]的地址 2016 a[1]+2,*(a+1)+2,&amp;a[1] [2] 1行2列元素a[1] [2]的地址 2024 *(a[i]+2),*(*(a+1)+2),a[1] [2] 一行二列元素a[1] [2]的值 元素值为13 3. 指向二维数组的指针 把二维数组a分解为一维数组a[0],a[1],a[2]之后，设p为指向二维数组的指针变量。 可定义为:int (*p)[4]，他表示p是一个指针变量，指向包含4个元素的一维数组。 若指向第一个一维数组a[0],其值等于a,a[0],或&amp;a[0] [0]等。 二维数组指针变量说明的一般形式为： 类型说明符 (*指针变量名)[长度] #include&lt;stdio.h> void main() { int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11}; int (*p)[4];//p相当于有4个格子的窗格。 //本质是指向一个含有四个元素数组的指针 int i,j; p=a; for(i=0;i&lt;3;i++) { for(j=0;j&lt;4;j++) { printf(\"%2d \",*(*(p+i)+j)); } printf(\"\\n\"); } } 5. 字符串与指针 //声明字符串，放到常量存储区，字符串不可改变，字符串编译地址赋给*a //可以改变指针变量的值，让它指向不同常量的值 char *a=\"i love fishc.com!\"; printf(\"%s\\n\",a); a+=4; printf(\"%s\\n\",a);//输出ve fishc.com! 6. 关于使用字符指针变量和字符数组 1.字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是字符串第一个字符的地址。 对数组的初始化 char str[20]={\"i love fish\"}; 不等价于 char str[20]; str[]=\"i love fish\";//这个只能一个字符一个字符赋值 //对于指针可以 char *a; a=\"i love fish\"; //等价于 char *a=\"i love fish\"; char str[10]; scanf(\"%s\",str); //以上完全可以 //以下危险（指针变量不赋初值会随机指向） char *a; scanf(\"%s\",a); //用数组下标索引 char *a=\"i love fishc.com!\"; printf(\"%s\\n\",a); a+=4; printf(\"%s\\n\",a);//输出ve fishc.com!char 7. 指针函数与函数指针 指针函数：返回指针的函数,本质函数 函数指针：指向函数的指针 #include&lt;stdio.h> int* han2(int* b);//han2在han下面，所以要声明 void han(int* (*x1)(int*), int a, int* b) {//函数指针，注意*号不要漏了 int* p; p = x1(&amp;a); printf(\"a:%d b:%d\\n\", *p, *b); } int* han2(int* b) {//指针函数 int* p = b;//p和b都指向a的地址 return p; } int main() { int a = 10, b = 20; han(han2, a, &amp;b); return 0; } 8. 函数指针实现多态 每次调用实现不同功能 #include &lt;stdio.h> int add(int a, int b) { return a+b; } int sub(int a, int b) { return a-b; } int mul(int a,int b) { return a*b; } int process(int (*fun)(int,int), int a, int b) { return fun(a,b);//也可以return (*fun)(a,b); } int main() { int a,b,r; printf(\"输入a、b两数：\\n\"); scanf(\"%d%d\",&amp;a,&amp;b); printf(\"两数之和：%d\\n\", process(add,a,b)); printf(\"两数之差：%d\\n\", process(sub,a,b)); printf(\"两数之积：%d\\n\", process(mul,a,b)); } 10. 指针数组和数组指针 指针数组：存放指针的数组，本质数组。int* name[10]={&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4]}; 数组指针：指向数组的指针。int (*a)[5];//指向一个每列5个元素的int类型数组 11. main函数参数问题 写完下面代码后编译，把生成的.exe文件(在debug文件夹里)放到一个文件夹里 在文件夹里开cmd， 输入 文件名.exe fish.com i love fish .com! 例如.\\666.exe i love fishc.com? yess; #include&lt;stdio.h> #include&lt;stdlib.h> void main(int argc,char *argv[]) { int i; printf(\"the number of string is : %d\\n\",argc-1);//参数个数 for(i=1;i&lt;argc;i++) { printf(\"the string %d is : %s\\n\",i,argv[i]);//后面输入时，空格隔开当成一个参数 } } 12. void指针与const指针 void *p 不指向一个确定的类型数据，仅仅存放一个地址 如果将void指针的值赋给其他类型的指针，则需要进行强制的类型转换 其他类型指针都可以直接给void指针赋值 const指针 const 在*号左边则不能改变值，在右边则不能改变指向。 #include&lt;stdio.h> #include&lt;stdlib.h> void main(int argc,char *argv[]) { const char *str=\"Welcome to Fishc.com!\\n\\n\"; //指针str指向const char类型，不能改值，可以改指向。 #if(0) str[0]='w';//非法 #endif str=\"I love fishc.com!\\n\\n\";//合法 printf(\"\\n\\n%s\",str); } #include&lt;stdio.h> #include&lt;stdlib.h> void main(int argc,char *argv[]) { char * const str=\"Welcome to Fishc.com!\\n\\n\"; //从右往左看，str先是一个常量，然后发现是const指针指向char //所以str不可改指向，但是可以改指向的数据内容。(理论上) str[0]='w';//合法（编译可过，但windows静止常量被重写） #if(0) str=\"I love fishc.com!\\n\\n\";//非法 #endif printf(\"\\n\\n%s\",str); } 13. 二级指针 int *p,**p;//这是错误的，因为重名了。 #include &lt;stdio.h> int main() { int a = 10; int b = 20; int *p = &amp;a; int** s = &amp;p;//二级指针所在地址存放一级指针的地址 printf(\"%d %d\",*s,p);//426767748 426767748c //指针一次解引用,*s类型int* *s = &amp;b; //指针二次解引用,**s类型int **s = 200; return 0; } 14. 数组偏移与指针偏移（重要） 数组偏移 详见 int a[10]={0}; &amp;a 、a 、&amp;a[0] 表示的是同一个地址，但是级别是不一样的。 &amp;a + 1 偏移了40字节，即声明数组空间的大小。 a + 1 ，&amp;a[0] + 1偏移了4字节，即数组中一个元素的空间大小。 &amp;a指向整个数组的地址，是数组中的最高级别，而 a 和 &amp;a[0] 表示 &amp;a 代表地址的下一级别地址。 指针偏移 char a[10] = “hello world”; char* p = a; p+1偏移一个字节(sizeof(char))。 char b[4][10] = &#123; 0 &#125;; char (*p)[10] = b; p + 1偏移10个字节。 #include &lt;stdio.h> int main() { //普通变量 int a1 = 1; int a2 = 1; int a3 = 1; //指针数组，本质数组 int* p[3] = { &amp;a1,&amp;a2,&amp;a3 };//数组大小32 //二级指针，本质指针 int** s = p; printf(\"%d %d \\n\", s, p);//s的值是数组的地址 printf(\"%d %d %d %d %d %d\", &amp;a1,*s, p[0], *s + 1, p[0] + 1,**s); //&amp;a1相当于1级指针，*s==&amp;a1==p[0] //*s+1和p[0]+1偏移4字节，因为int a1,a2,a3内存中连续存储 return 0; } 九.预处理 优点 方便输出 比如#define P printf #define D “%d\\n” #define F “%f\\n” 使用时P(D F,a,b); 1. 无参宏定义 #开头的均为预处理命令 define为宏定义命令 格式 #define 标识符 字符串 注意 宏定义必须写在函数以外，作用域为宏定义命令开始到源程序结束，可以用#undef命令终止作用域 比如#undef PI; 末尾加分号则连分号一起置换 宏名在源程序中若用引号括起来，则预处理程序不对其作宏代换。 #define PI 3.1415926 printf(\"now the PI is %g\\n\",PI); 2. 宏定义 宏定义允许嵌套，在宏定义的的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层代换。 #define PI 3.1415926 #define S PI*r*r 宏定义是普通的字符串替换 #define _quote(que) quote #define qwe _quote(que) //qwe表示quote //打印数字0-999 #include&lt;stdio.h> #define A(x) x;x;x;x;x;x;x;x;x;x; int main(void) { int n=0; A(A(A(printf(\"%d\",n++)))); return 0; } 3. typedef 对类型说明符重命名 比如 typedef char* pStr1; #define pStr2 char* pStr1 s1, s2;//等价于char *s1, *s2; pStr2 s3, s4;//等价于char* s3, s4; //#define 只做简单的字符串替换 4. 带参宏定义 带参宏定义中，宏名和形参表之间不能有空格出现。 #define MAX (a,b) (a&gt;b)?a:b//不行 #define MAX(a,b) (a&gt;b)?a:b//行 . 在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义。宏定义可以带有参数，宏调用时是以实参代换形参。而不是“值传送”。 在宏定义中，字符串内的形参通常要用括号括起来以避免出错。 #define SQ(y) (y)*(y) 那么SQ(4)=16 #define SQ(y) y*y 那么SQ(3+1)=7 3+1乘3+1 #define SQ(y) (y)*(y) 那么160/SQ(3+1)=160 160/y乘y #define SQ(y) ((y)*(y)) 那么160/SQ(3+1)=10 在宏定义中的形参是标识符，而宏调用中的实参可以是表达式。 . 带参的宏和带参函数很相似，但有本质上的不同，除上面已谈到的各点外，把同一表达式用函数处理与用宏处理两者的结果有可能是不同的。 #define SQ(y) ((y)*(y)) SQ(++i),如果i=1 (++i)*(++i)=9 宏定义也可用来定义多个语句，在宏调用时，把这些语句又代换到源程序内。 #define M(y) y*y+3*y /*宏定义*/ …… k=M(5); /*宏调用*/ 5. 文件包含 一个include命令只能指定一个被包含文件，若有多个文件要包含，则需用多个include命令。 文件包含允许嵌套，即在一个被包含的文件中又可以包含另一个文件。 #include&quot;stdio.h&quot; #include&lt;math.h&gt; 使用尖括号表示在包含文件目录中去查找(包含目录是由用户在设置环境时设置的)，而不在源文件目录去查找； 使用双引号则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找 6. 条件编译 #ifdef 标识符 程序段1 #else 程序段2 #endif 1.如果标识符已被 #define命令定义过则对程序段1进行编译；否则对程序段2进行编译。没有程序段2，可以不写#else。 2.不执行 #if(0) 程序段 #endif 十. 结构体和共用体 1. 概述 在定义结构时，不可以为成员设置默认值 结构体中的成员可以与结构体变量同名 C语言结构体类型变量在其生存期间所有成员一直驻留在内存中 typedef struct { int n; struct {int y, m, d; } date; } PERSON; 则下面定义结构体数组并赋值的语句中错误的是()。 PERSON x[2]={{1},04,10,1,{2},04,12,30}; ``` 5. ```c typedef struct REC { char c; int a[4]; }REC1;//**REC1，REC是结构体类型,不是变量** ``` 6. 结构体类型本身不占用内存空间，结构体变量占用内存空间。 7. 结构体成员的类型不一定是基本数据类型。 8. 共用体变量不可以进行初始化 9. 枚举类型中的元素都具有一个整型值。 ### 2. 结构体变量定义和赋值 ```c /*1.先声明结构体类型再定义变量名 类型名struct 结构体名student 变量名student1 定义student1和student2为struct student类型的变量，具有struct student 类型的结构 在定义了结构体变量后，系统会为之分配内存单元。*/ struct student { int num; char name[20]; char sex; int age; float score; char addr[30]; }; struct student student1,student2;//有点像实例化对象 //2.在声明类型的同时定义变量 struct student//结构体名 { int num; char name[20];//成员表列 char sex; int age; float score; char addr[30]; }student1,student2;//变量名表列 //3. 直接定义结构体类型变量,即不出现结构体名 struct{ int id; char name[20]; }student; ``` > 赋值 ```c struct student { int num; char* name; char sex; float score; }boy1, boy2 = { 102, \"Jane\", 'M', 98.5 };//赋值方法1 int main() { boy1.num = 666;//赋值方法2 boy1=boy2;//赋值方法3 strcpy(boy1.name , \"Fishc\");//赋值方法4 return 0; } ``` ### 3. 结构体引用与嵌套 1. “.”是成员(分量)运算符 2. 正确引用结构体变量中成员的方式为： 结构体变量名.成员名 3. 不能将一个结构体变量作为一个整体进行输入和输出。 4. 对结构体变量的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。 ```c /* 不能用student1.birthday来访问student1变量中的成员birthday,因为birthday本身是一个结构体变量。*/ #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h> void main() { struct date { int day; int month; }; struct { int num; char name[20]; char sex; struct date birthday;//把struct date看成是自定义类型。 float score; } boy1, boy2; printf(\"Please input birthday(MM:) \"); scanf(\"%d\", &amp;boy1.birthday.month); printf(\"Please input birthday(DD:) \"); scanf(\"%d\", &amp;boy1.birthday.day); printf(\"\\n\"); boy2 = boy1; printf(\"boy1's birthday is %d-%d\\n\", boy1.birthday.month, boy1.birthday.day); printf(\"boy2's birthday is %d-%d\\n\", boy2.birthday.month, boy2.birthday.day); } ``` ### 5. 结构体数组 ```c //可以这样定义 struct student { int num; char name[20]; char sex; int age; float score; char addr[30]; }; struct student student[3]; //或者这样 struct student { int num; char name[20]; char sex; int age; float score;c char addr[30]; }student[3]; ``` ### 6. 初始化数组 ```c struct student { int num; char name[20]； char sex； int age； float score; char addr[30]； }stu[2]＝ {{101,″LiLin″,′M′,18,87.5,″Beijing″},{102,″Zhang″,′F′,19,99,″Shanghai″}}; 或者 struct student str[]={{…},{…},{…}}； &lt;/stdio.h> 7. 指向结构体类型的指针 结构指针变量说明的一般形式为： struct 结构名 *结构指针变量名 struct stu *pstu; 赋值是把结构变量的首地址赋予该指针变量，不能把结构名赋予该指针变量。 pstu=&amp;boy是正确的。 pstu=&amp;stu是错误的。 **结构名**表示一个结构形式，编译系统并不对它分配内存空间。**结构体变量**有分配存储空间。 访问方法 (*pstu).num pstu-&gt;num #include &lt;stdio.h> struct stu { int num; char *name; char sex; float score; } boy1 = {102, \"Fishc\", 'M', 78.5}; void main() { struct stu *pstu; pstu = &amp;boy1; printf(\"Number = %d\\nName = %s\\n\", boy1.num, boy1.name); printf(\"Sex = %c\\nScore = %f\\n\\n\", boy1.sex, boy1.score); printf(\"Number = %d\\nName = %s\\n\", (*pstu).num, (*pstu).name); printf(\"Sex = %c\\nScore = %f\\n\\n\", (*pstu).sex, (*pstu).score); printf(\"Number = %d\\nName = %s\\n\", pstu->num, pstu->name); printf(\"Sex = %c\\nScore = %f\\n\\n\", pstu->sex, pstu->score); } *(++p)->m这里->优先级比*高 8. 结构指针变量作函数参数 将一个结构体变量的值传递给另一个函数，有3个方法: （1）用结构体变量的成员作参数 （2）用结构体变量作实参 （3）用指向结构体变量（或数组）的指针作实参，将结构体变量（或数组）的地址传给形参 //用结构体变量作函数参数 #include &lt;stdio.h> #include &lt;string.h> struct student { int num; char *name;//或者char name[20];搭配下面第二种 float score[3]; }; void print( struct student stu ) { printf(\"\\tnum : %d\\n\", stu.num); printf(\"\\tname : %s\\n\", stu.name); printf(\"\\tscore_1 : %5.2f\\n\", stu.score[0]); printf(\"\\n\"); } void main() { struct student stu; stu.num = 8; stu.name = \"Fishc.com!\"; stu.score[0] = 98.5; print( stu ); } //用结构体变量作实参 void print( struct student *p ) { printf(\"\\tnum : %d\\n\", p -> num); printf(\"\\tname : %s\\n\", p -> name); printf(\"\\tscore_1 : %5.2f\\n\", p -> score[0]); printf(\"\\n\"); } void main() { print( &amp;stu ); } 9.动态存储分配（重点） #include&lt;stdlib.h&gt; 分配内存空间函数 malloc、calloc 修改已经分配内存函数realloc 释放内存空间函数 free malloc函数 void *malloc(unsigned int size); 其作用是在内存的动态存储区中分配一个长度为size的连续空间（size是一个无符号数）。 此函数的返回值是一个指向分配域起始地址的指针（类型为void）。 失败则返回空指针(NULL)。 int* a = (int *)malloc(5*sizeof(int)); calloc函数 void *calloc（unsigned n, unsigned size）; 其作用是在内存的动态存储区中分配ｎ个长度为size的连续空间。 函数返回一个指向分配域起始地址的指针； 如果分配不成功，返回NULL。 int* p=(int*)calloc(10,sizeof(int)); realloc函数 void* realloc(void* ptr,size_t size) 修改已经分配的内存块大小。 int* a = (int *)malloc(5*sizeof(int)); int* p=(int *)realloc(a,20*sizeof(int));//返回指向新分配内存的指针 free函数 函数原型为void free（void *p）; 其作用是释放由p指向的内存区，使这部分内存区能被其他变量使用。 p是最近一次调用calloc或malloc函数时返回的值。 free函数无返回值。 10 . typedef typedef可以声明各种类型，但不能用来定义变量 #define在预编译时处理，typedef在编译时处理 //1. 给已有类型int取别名 typedef int INTEGER; //2. 给结构体取别名REC1 typedef struct REC{ char c; int a[4]; } REC1; //REC1是一个结构体定义 void main(){ REC1 data1; data1.c='k'; } //3. 声明NUM为整型数组类型 typedef int NUM[100]; void main(){ NUM num={0}; printf(\"%d\",sizeof(num)); } //声明STRING为字符指针类型 typedef char* STRING; void main(){ STRING p; p=\"i love fishc.com\"; printf(\"%s\",p); } //声明POINTER为指向函数的指针类型 typedef void (*POINTER)(); void fun(){ printf(\"i love fishc.com\"); } void main(){ POINTER p1;//void (*p1)(); p1=fun; p1(); } 11. 链表（重点） 链表是一种常见的重要的数据结构,是动态地进行存储分配的一种结构。 链表的组成： 头指针：存放一个地址，该地址指向第一个结点。 结点：一个指向结构体变量(包含数据域和指针域)的指针。 在数据结构中会详细介绍各种链表，这里只以单链表为例。 1. 单链表创建和打印 #include &lt;stdio.h> #include&lt;stdlib.h> typedef struct listnode{//结构体取别名LN int val;//数据域 struct listnode * next;//指针域 }LN; int main() { //创建头节点 LN* head = NULL; LN* n1 = (LN*)malloc(sizeof(LN));//创建第一个节点 n1->val = 1; n1->next = NULL; head = n1;//头节点目前相当于n1 LN* n2 = (LN*)malloc(sizeof(LN));//创建第2个节点 n2->val = 2; n2->next = NULL; n1->next = n2;//n1->next指向n2地址 //打印链表的值 LN* current = head;//current相当于n1 while (current != NULL) { printf(\"%d \", current->val); current = current->next;//指向下一个结点 } printf(\"\\n\"); //释放内存 current = head; while (current != NULL) { LN* temp = current->next; free(current); current = temp; } return 0; } 2. 单链表的前插(头插) 链表L在值为i的第一个结点前插入一个值为j的结点 LN* preInsert(LN* head, int i, int j) { LN* p = head; if (p == NULL) { printf(\"空链表\"); return head; } while (p != NULL) {//单链表至少包含两个结点(包含头结点) if (p->val == i) {//在头节点前插入 LN* m = (LN*)malloc( sizeof(LN)); //单链表没有连续的内存块，不能重新分配(realloc)一块内存块 m->next = p;//指向旧的头结点 m->val = j; head = m;//新的头结点 return head;//返回 } else if (p->next->val == i) { LN* m = (LN*)malloc(sizeof(LN)); m->next = p->next;//新节点先连接后面 p->next = m;//再连接前面 m->val = j; return head; } p = p->next; } printf(\"找不到元素\"); return head; } 3. 单链表的后插(尾插) 链表L在值为i的第一个结点后插入一个值为j的结点 LN* tailInsert(LN* head, int i, int j) { LN* p = head; if (p == NULL) { printf(\"空链表\"); return head; } while (p != NULL) {//单链表至少包含两个结点(包含头结点) if (p->next==NULL&amp;&amp;p->val==i) {//在尾结点后插入 LN* m = (LN*)malloc(sizeof(LN)); p->next=m; m->next=NULL; m->val=j; return head; } else if (p->val == i) { LN* m = (LN*)malloc( sizeof(LN)); m->next=p->next;//先连后面 p->next=m;//再连前面 m->val=j; return head;//返回 } p = p->next; } printf(\"找不到元素\"); return head; } 4. 单链表的删除 删除值为i的结点，要用m保存结点，再释放内存 LN* deleteNode(LN* head, int i) { LN* p = head; if (p == NULL) { printf(\"空链表\"); return head; } while (p != NULL) {//单链表至少包含两个结点(包含头结点) if (p->val == i) {//删除n1，头结点指向n2 LN* m = (LN*)malloc(sizeof(LN)); m = head; head = head->next; free(m); return head;//返回 } else if (p->next->val == i) { LN* m = (LN*)malloc(sizeof(LN)); m = p->next; p->next = m->next; free(m); return head; } p = p->next; } printf(\"找不到元素\"); return head; } 12. 共用体 几个不同变量共用一段内存的结构 union data { int i; char ch; }a,b,c; 或者 union data { int i; char ch; }; union data a,b,c; 13. 枚举 #include&lt;stdio.h> /* 定义枚举类型 */ enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; void main() { /* 使用基本数据类型声明变量，然后对变量赋值 */ int x, y, z; x = 10; y = 20; z = 30; /* 使用枚举类型声明变量，再对枚举型变量赋值 */ enum DAY yesterday, today, tomorrow; yesterday = MON; today = TUE; tomorrow = WED; printf(\"%d %d %d \\n\", yesterday, today, tomorrow); } 或者 /* 使用枚举类型声明变量同时对枚举型变量赋初值 */ enum DAY yesterday = MON, today = TUE, tomorrow = WED; 或者 /* 定义枚举类型，同时声明该类型的三个变量，并赋初值。它们都为全局变量 */ enum DAY { MON=1, TUE,WED,THU,FRI,SAT,SUN }yesterday = MON, today = TUE, tomorrow = WED; 十一.文件操作 1.概念 “文件”是指一组相关数据的有序集合 特殊文件(标准输入输出文件或标准设备文件),普通文件(磁盘文件) 输入文件：终端键盘,输出文件：显示屏和打印机 ASCII文件(文本文件):每一个字节放一个ASCII代码 二进制文件:把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放。 文件的读函数是从输入文件中读取信息，并存放在内存中。 不能用&quot;r&quot;方式打开一个并不存在的文本文件。 若执行fopen函数时发生错误，则函数的返回值是0。 fclose成功0，失败EOF(-1) 设fp是指向某个文件的指针，且已读到文件末尾，则库函数feof(fp)的返回值是非0值 若要用fopen函数打开一个新的二进制文件，该文件既要能读也要能写，则文件方式字符串应是( “wb+”)。 若要指定打开c盘上子目录myfile下的二进制文件test.bin，在调用函数fopen时，第一个参数的正确格式是(&quot;c:\\\\myfile\\\\test.bin&quot;)。 设有一个名为file1C源程序，且已知命令行为：FILE1 CHINA BEIJING SHANGHAI，则可得以以下运行结果的C源程序为( )。 CHINA BEIJING SHANGHAI main(int argc, char *argv[ ]) { while(argc-->1) printf(\"%s\\n\", *++argv); } 13. 下面程序段的运行结果是( a+=b,a=11,b=10 )。 char *format=&quot;%s,a=%d,b=%d\\n&quot;; int a=1,b=10; a+=b; printf(format,“a+=b”,a,b); 以下程序有错，错误原因是(q虽然指向了具体的存储单元，但该单元中没有确定的值，所以不能执行语句*p=*q; )。 main() { int *p, i; char *q, ch; p = &amp;i; q = &amp;ch; *p = 40; *p = *q; ...... } 文件名不一定要包含后缀名。 getchar只针对标准输入流stdin，即使对stdin重定向，getchar针对的也只是stdin。f 系列（比如fwrite）的输入输出函数都是作用于所有流的 C语言对文件的处理方法 缓冲文件系统：系统自动地在内存区为每一个正在使用的文件开辟一个缓冲区。用缓冲文件系统进行的输入输出又称为高级磁盘输入输出。 非缓冲文件系统：系统不自动开辟确定大小的缓冲区，而由程序为每个文件设定缓冲区。用非缓冲文件系统进行的输入输出又称为低级输入输出系统。 在UNIX系统下,用缓冲文件系统来处理文本文件，用非缓冲文件系统来处理二进制文件。 ANSI C 标准只采用缓冲文件系统来处理文本文件和二进制文件。 2.文件读写详解 1. 详解 修饰符 t 以文本模式打开文件(默认)，可省略(w等价于wt) b 以二进制模式打开文件 模式 r 以只读的形式打开文本文件，文件必须已存在 w 以只写的形式打开文本文件(若不存在则新建，存在则清空文件内容) a 以追加的形式打开文本文件(若不存在，则新建；反之，在原文件后追加) rb 以二进制只读的形式打开二进制文件 wb 以二进制只写的形式打开二进制文件 ab 以二进制追加的形式打开一个文件 r+ 以读写的形式打开文件(文件必须已存在) w+ 读写方式打开文件。文件不存在，则建立一个新文件。若文件存在，则删除文件内容。 a+ 读写方式打开文件。如果文件存在，数据会被写入到文件末尾。如果文件不存在，则创建新文件。 rb+ 以二进制读写的形式打开文件。文件必须已存在。(r+b) wb+ 以二进制读写的形式打开文件。文件存在则清空文件内容，不存在则创建新文件。(w+b) ab+ 以二进制读写的形式打开文件。文件存在，则在尾部追加数据。不存在则创建文件。 读写相关函数 int num=100,a[10]; FILE *fp1=fopen(“.//user.txt”,“r”);//定义文件指针 FILE *fp2=fopen(“.//user.txt”,“rb”);//二进制打开文件 char str[100],ch; const char* str2=“hello”; 读写相关函数 解释 fopen 打开文件 fclose(fp); 删除文件 ch=fgetc(fp); 读取一个字符 fgets(str,sizeof(str),fp); 读取一行字符串 fputc(ch,fp); 向文件写入一个字符 fputs(str2,fp); 向文件写入一个字符串 fscanf(fp,“%d”,&amp;num); 格式化读取数据 fprintf(fp,“it is %d”,num); 向文件格式化输出数据 fread(a,sizeof(int),10,fp); (重要)二进制读取10个大小为sizeof(int)的元素 fwrite(a,sizeof(int),10,fp); (重要)二进制写入 num=getw(fp); 二进制读取一个整数 putw(num,fp); 二进制写入一个整数 文件内部指针相关函数 起始点 文件开头 SEEK_SET 0 文件当前位置 SEEK_CUR 1 文件末尾 SEEK_END 2 函数 作用 返回值 long offset=ftell(fp); 得到流式文件中的当前位置。 成功返回当前文件位置指针相对于文件起始位置的偏移量。错误返回-1。 fseek(fp,100L,0); 改变文件内部位置指针，fseek(文件指针，偏移量，起始点) 成功0，失败非0。 feof(fp) 判断是否到达文件结尾 达到文件末尾，返回非0，否则返回0 rewind(fp); 将文件位置指针重新设置到文件起始位置 无 ferror(fp) 检查文件流错误标志是否被设置 如果被设置，返回非0，否则返回0 clearerr(fp); 清除文件错误标志和文件结束标志(并不会把指针重置到文件开头) 无 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h> int main() { FILE* fp = fopen(\".//test1.txt\", \"a+\"); int a = 10; char b[50]; fprintf(fp, \"num:%d\\n\", a); rewind(fp);//文件指针重新指向开头，fseek(fp,0,0); fscanf(fp, \"%s\", b);//一般读取一行 printf(\"%s\", b); fclose(fp); return 0; } 2. 流的概念 【维生素C语言】第十六章 - 文件操作（上）_柠檬叶子C的博客-CSDN博客 注意 应注意文件指针和文件内部的位置指针不是一回事。 文件指针是指向整个文件的，须在程序中定义说明，只要不重新赋值，文件指针的值是不变的。 文件内部的位置指针用以指示文件内部的当前读写位置，每读写一次，该指针均向后移动，它不需在程序中定义说明，而是由系统自动设置的。 3. 刷题 1. 查询 数据 xuebi,da,345,6.00 //雪碧，规格，数量，单价 xianchengduo,zhong,5,4.00 //鲜橙多 xuebi,xiao,4567,2.00 xuebi,da,456,6.00 解题代码 #include &lt;stdio.h> #include &lt;string.h> struct good { char name[20]; char type[12]; int number; float price; };//用结构体接收二进制文件 int main(void) { int i = 0, n, flag; char str[20]; struct good goods[100];//结构体类型的数组 FILE *fp; fp = fopen(\"sp.dat\", \"rb\"); //二进制读取 while (!feof(fp))//到文件尾结束 { fread(&amp;goods[i], sizeof(struct good), 1, fp);//1的意思是1个sizeof()大小 i++; } n = i; flag = 0; printf(\"Please input shang pin pin ming:\"); scanf(\"%s\", str);//商品名 printf(\"Output:\\ncha zhao qing kuang:\\n\"); for (i = 0; i &lt; n; i++) { if (strcmp(goods[i].name, str)==0) { printf(\"%s,%s,%d,%.2f\\n\", goods[i].name, goods[i].type, goods[i].number, goods[i].price); flag = 1; } } if (flag == 0) { printf(\"mei you shang pin %s\\n\", str); } return 0; } 2. 读取 数据 lb8103a.txt abcdefghijklmnopqrstuvwxyz lb8103b.txt zyxwvutsrqponmlkjihgfedcba 解题代码 #include &lt;stdio.h> #include &lt;string.h> int main(void) { int n,i=0; char str[80]={\"C:\\\\Users\\\\21609\\\\Desktop\\\\Cprogramm\\\\\"}; char ch,a[20]; FILE *fp; printf(\"Input filename:\");//输入文件名 scanf(\"%s\",a); printf(\"Input n:\");//读取多少个 scanf(\"%d\", &amp;n); strcat(str,a);//a拼接到str末尾 fp = fopen(str, \"r\"); printf(\"Output:\\n\"); if (fp == NULL) { printf(\"Open Error!\\n\"); return 0; } ch=fgetc(fp); while(!feof(fp)&amp;&amp;(i&lt;n)){ putchar(ch); ch=fgetc(fp); i++; } fclose(fp); return 0; }","categories":[{"name":"大一","slug":"大一","permalink":"https://eyjafjalla6.github.io/categories/%E5%A4%A7%E4%B8%80/"}],"tags":[]},{"title":"python常用库","slug":"python常用库","date":"2023-08-24T07:33:11.000Z","updated":"2023-08-24T08:32:27.470Z","comments":true,"path":"2023/08/24/python常用库/","link":"","permalink":"https://eyjafjalla6.github.io/2023/08/24/python%E5%B8%B8%E7%94%A8%E5%BA%93/","excerpt":"","text":"常见模块解析 1. math库 数学函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 **Python 3 已废弃，使用 (x&gt;y)-(x。 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) 返回数字x的平方根。 三角函数 Python的math库包括以下三角函数：(比如：math.sin(math.pi/2)) 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 数学常量 常量 描述 math.pi 数学常量 pi（圆周率，一般以π来表示） math.e 数学常量 e，e即自然常数（自然常数）。 2. random库 Python的random库包含以下常用随机数函数： import random # 生成一个 [0, 1) 范围内的随机小数 print(random.random()) # 生成一个 [1, 10] 范围内的随机整数 print(random.randint(1, 10)) # 生成一个 [0, 1] 范围内的随机小数 print(random.uniform(0, 1)) # 从序列中随机选择一个元素 seq = ['apple', 'banana', 'orange'] print(random.choice(seq)) # 将序列中的元素随机打乱（shuffle洗牌） seq = [1, 2, 3, 4, 5] random.shuffle(seq) print(seq) 3. re 模块 1. 常用正则表达式 模式 描述 \\w 匹配字母数字及下划线 \\W 匹配非字母数字下划线 \\s 匹配任意空白字符，等价于[\\t,\\n,\\r,\\f] \\S 匹配任意非空字符 \\d 匹配任意数字，等价于[0-9] \\D 匹配任意非数字 \\A 匹配以xx字符串开始 \\Z 匹配xx字符串结束，如果是存在换行，只匹配到换行前的结束字符串 \\z 匹配xx字符串结束 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开头 $ 匹配字符串的末尾 . 匹配任意字符, 除了换行符, 当 re.DOTALL 标记被指定时, 则可以匹配包括换行符的任意字符 […] 用来表示一组字符， 单独列出：[amk] 匹配 ‘a’，‘m’ 或 ‘k’ [^…] 不在 [ ] 中的字符：[^abc] 匹配除了a， b， c之外的字符 * 匹配0个或多个的表达式 + 匹配1个或多个的表达式 ? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面表达式。 {n，m} 匹配n到m次由前面的正则表达式定义的片段，贪婪方式 alb 匹配a或b () 匹配括号内的表达式，也表示一个组 注意：[ ]所有的特殊字符在字符集中都失去其原有的特殊含义,在字符集中如果要使用]、-或^，可以在前面加上反斜杠，或把]、-放在第一个字符，把^放在非第一个字符 2. 常用函数 函数 说明 re.match( ) 从字符串的起始位置匹配, 匹配成功, 返回一个匹配的对象, 否则返回None re.search( ) 扫描整个字符串并返回第一个成功的匹配 re.findall( ) 在字符串中找到正则表达式所匹配的所有子串, 并返回一个列表, 如果没有找到匹配的, 则返回空列表 re.split( ) 将一个字符串按照正则表达式匹配结果进行分割, 返回列表类型 re.finditer( ) 在字符串中找到正则表达式所匹配的所有子串, 并把它们作为一个迭代器返回 re.sub( ) 把字符串中所有匹配正则表达式的地方替换成新的字符串 re.complie( ) 将正则表达式传入, 返回一个匹配对象, 一般与其他方法组合使用 3. 正则匹配使用示例 print(\"hello\".replace(\"llo\",\"ooo\")) # heooo print(\"hello\".find(\"abcd\")) # -1 (找不到返回 -1) print(\"hello\".find(\"he\")) # 0 import re print(re.findall(\"\\w\",\"ab* 12$ _\")) # ['a', 'b', '1', '2', '_'] print(re.findall(\"\\s\",\"ab* 12$ _ \")) # [' ', ' ', ' '] print(re.findall(\"\\Aab\",\"ab* 12$ _\")) # ['ab'] print(re.findall(\"\\Aaa\",\"ab* 12$ _\")) # [] 没匹配到为空 print(re.findall(\"_\\Z\",\"ab* 12$ _\")) # ['_'] print(re.findall(\"0\\Z\",\"ab* 12$ _\")) # [] 没匹配到为空 print(re.findall(\"\\t\",\"ab* 12$ \\t_\")) # ['\\t'] #\"\\s\" 可以匹配\"\\t\"和\"\\n\" print(re.findall(\"^ab\",\"ab* 12$ _\")) # ['ab'] print(re.findall(\"_$\",\"ab* 12$ _\\n\")) # ['_'] 重复匹配 #.匹配任意一个字符 import re print(re.findall(\"a.b\",\"a\\tb\")) # ['a\\tb'] print(re.findall(\"a.b\",\"a\\nb\")) # [] (换行符匹配不到,匹配为空) print(re.findall(\"a.b\",\"a b a*b abb a_b\")) # ['a b', 'a*b', 'abb', 'a_b'] print(re.findall(\"a.b\",\"a\\nb\",re.S)) # ['a\\nb'] (加入参数, 包含换行) print(re.findall(\"a.b\",\"a\\nb\",re.DOTALL)) # ['a\\nb'] (同上效果一样) #* 匹配前面那个字符0个或者n个 print(re.findall(\"a*\",\"aaaa aa\"))# ['aaaa', '', 'aa', ''] (零个或多个a) print(re.findall(\"ab*\",\"abab aa\"))# ['ab', 'ab', 'a', 'a'] (一个a零个或多个b) print(re.findall(\"a*b\",\"ababaaaba aa\")) # ['ab', 'ab', 'aaab'] (零个或多个a一个b) print(re.findall(\"ab*\",\"bbbbbbbb\")) # [] (没有匹配到一个a零个或多个b) #? 匹配前面那个字符0个或者1个 print(re.findall(\"ab?\",\"a\")) # ['a']，匹配1个a，0个b print(re.findall(\"ab?\",\"abbb\")) # ['ab'] #{n,m} 匹配n~m个 print(re.findall(\"a{2}\",\"aaaa\")) # ['aa', 'aa'] print(re.findall(\"ab{2,6}\",\"abbb\")) # ['abbb'] (一个a,2~6个b) print(re.findall(\"ab{1,}\",\"abbb\")) # ['abbb'] (相当于 ab+) print(re.findall(\"ab{0,}\",\"abbb\")) # ['abbb'] (相当于 ab*) #[ ]逐个匹配 print(re.findall(\"a[*1_c-]b\",\"a*ba1b a_baaba-b\")) # ['a*b', 'a1b', 'a_b', 'a-b'] print(re.findall(\"a[^a-zA-Z0-9]b\",\"a*banb aPbaa7b\")) # ['a*b'] (非a~z,A~Z,0~9) #( )分组 print(re.findall('ab+','ababab123')) # ['ab', 'ab', 'ab'] print(re.findall('(ab)+123','ababab123')) # ['ab']，匹配到末尾的 ab123 中的 ab print(re.findall('(?:ab)+123','ababab123')) #['ababab123']， findall的结果不是匹配的全部内容，而是组内的内容, ?: 可以让结果为匹配的全部内容,详见非捕获匹配 print(re.findall('href=\"(.*?)\"','&lt;a href=\"http://www.baidu.com\">点击&lt;/a>'))# ['http://www.baidu.com'] print(re.findall('href=\"(?:.*?)\"','&lt;a href=\"http://www.baidu.com\">点击&lt;/a>&lt;a href=\"http://www.aiqiyi.com\">点击2&lt;/a>')) # ['href=\"http://www.baidu.com\"', 'href=\"http://www.aiqiyi.com\"'] print(re.findall(\"a\\.b\",\"a1b a.b\")) # ['a.b'] print(re.findall(\"shawn|song\",\"shawn is man song is shawn\")) # ['shawn', 'song', 'shawn'] print(re.findall(\"A(?:abc|cba)A\",\"AabcA\")) # ['AabcA'] print(re.findall(\"com(?:puter|e)\",\"come on! Here is a computer \")) # ['come', 'computer'] #匹配所有数字 print(re.findall(\"\\d+\\.?\\d*\",\"12as3.45qw2k7\")) # ['12', '3.45', '2', '7'] 贪婪匹配.*与懒惰匹配.*? print(re.findall(\"a.*b\",\"a11b22222b33\")) # ['a11b22222b'] print(re.findall(\"a.*?b\",\"a11b22222b3\")) # ['a11b'] 4. 方法示例 #re.findall(pattern,string) #在字符串中找到正则表达式所匹配的所有子串, 并返回一个列表, 如果没有找到匹配的, 则返回空列表 print(re.findall(\"(ab)+(cd)+\",\"ababcdcd abcd\")) #[('ab', 'cd'), ('ab', 'cd')]，返回元组列表 #re.search() 匹配整个字符串, 只到找到第一个匹配然后返回一个包含匹配信息的对象(re.Match对象) 该对象可以通过调用 group()方法得到匹配的字符串,如果字符串没有匹配，则返回None 如果没有匹配到值就调用 group() 方法, 抛出异常 print(re.search(\"abc\",\"112abc333abc\")) # &lt;re.Match object; span=(3, 6), match='abc'> print(re.search(\"abc\",\"112abc333abc\").group()) # abc print(re.search(\"abcd\",\"12abc333abc\")) # None print(re.search(\"abcd\",\"12abc333abc\").group()) # 报错 \"AttributeError\" 因为没拿到这个对象,所以没有group()属性 #re.match() 与 re.search 功能相同, 但必须匹配起始位置, 不然返回 None print(re.match(\"abc\",\"abc22abc\")) # &lt;re.Match object; span=(0, 3), match='abc'> print(re.match(\"abc\",\"abc22abc\").group()) # abc print(re.match(\"abc\",\"1abc22abc\")) # None #re.split() 以规定字符作为分隔符对字符串进行切分, 切分结果放入列表, 没匹配到返回原字符串列表 将规定字符放入 [ ] 则是逐个匹配 print(re.split(\"ab\",\"abcoababcoabc\")) #['', 'co', '', 'co', 'c'] print(re.split(\"a\",\"nbc\")) #['nbc']，返回原字符串 print(re.split(\"[ob]\",\"abcoabcoabc\")) # ['a', 'c', 'a', 'c', 'a', 'c'] #re.sub()和re.subn() 匹配字符, 并将其该成指定字符, 返回改变后的字符串, 后面可跟个数参数, 不指定默认替换所有 re.subn( ) 返回一个元组, 第二个元素返回的是替换的个数 print(re.sub(\"a\",\"AA\",\"i am a man\")) # i AAm AA mAAn print(re.sub(\"a\",\"AA\",\"i am a man\",100)) # i AAm AA mAAn，不报错 print(re.subn(\"a\",\"A\",\"i am a man\")) # ('i Am A mAn', 3) (显示替换的个数) #re.compile() 返回一个对象 obj=re.compile(\"\\d{2}\") print(obj) # re.compile('\\\\d{2}') print(obj.findall(\"ab123bc123\")) #['12', '12'] print(obj.search(\"ab123bc123\").group()) # 12 print(obj.match(\"123ab123bc123\").group()) # 12 substitude 替换 5. 非捕获匹配?: ?! ?= # ?: (?:)非捕获分组，只会进行单纯的模式匹配并不会将匹配到的值进行保存，与()区分 print(re.findall(\"jk(loli)+\",\"jkloli\")) # ['loli'] print(re.findall(\"jk(?:loli)+\",\"jkloli\")) # ['jkloli'] # ?! 正向否定预查 1.在没匹配到字符串的前提下，再进行后续的正则，后续匹配仍然从被匹配字符串的头开始 res = re.match(\"(?![\\d]+$)(?![a-zA-Z]+$)[\\da-zA-Z]{6}$\",passwd) #匹配6位数字与字母组合，不能纯数字或字母 2.匹配位置 后面 不能跟着指定表达式。 print(re.findall(\"19(?!99)\",\"1999\")) print(re.findall(\"\\d{2}(?!99)\",\"1999 1988\"))#['99', '19', '88'] #先尝试匹配\"1999\"，再'999 '(成功)，再\"9 19\"，再\" 198\"，再\"1988\"(成功)，再\"88\",理解下匹配的窗格移动 # ?= 正向肯定预查 1.在匹配到字符串的前提下，再进行后续的正则，后续匹配仍然从被匹配字符串的头开始 res = re.search(\"(?=.*[\\d])(?=.*[a-z])(?=.*[A-Z])(?=.*)(?=.*[!@#%&amp;])^([\\da-zA-Z!@#%&amp;]{7,})$\",passwd) #至少七位密码，包含大小写，数字，特殊字符(!,@,#,%,&amp;) 2.匹配位置 后面 必须跟着指定表达式。 r\"foo(?=bar)\"可以匹配foobar中的foo，不能匹配foobaz中的foo # ?&lt;= 匹配位置 前面 必须跟着指定表达式。 print(re.findall(\"(?&lt;=jk).*?(?=li)\",\"mcjli jkloli liejk\")) #['lo'] # ?&lt;! 匹配位置 前面 不能跟着指定表达式。 print(re.findall(\"\\\\B(?&lt;!18)\\d{2}\\\\b\",\"1988 1899\")) #['88'] 6. 边界匹配问题 \\b表示单词边界，\\B表示非单词边界 一般空格、换行、标点符号或者特殊符号来表示边界 或者说非数字、字母、下滑线、unicode汉字表示边界 中文字符串为边界的话要用re.A编码模式 print(re.findall(\"\\\\b19(?:[^9]{2})\\\\b\",\"1999 1988\")) #['1988'] print(re.findall(\"\\\\b19(?:[^9]{2})\\\\b\",\"你也玩1999?1988带我一个\",re.A)) # ['1988'] 4. request模块 吐槽：b站王道的计算机网络好水。 5. time库","categories":[{"name":"计算机语言基础","slug":"计算机语言基础","permalink":"https://eyjafjalla6.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://eyjafjalla6.github.io/tags/python/"}]},{"title":"测试","slug":"测试","date":"2023-08-24T07:11:21.000Z","updated":"2023-10-10T07:03:50.367Z","comments":true,"path":"2023/08/24/测试/","link":"","permalink":"https://eyjafjalla6.github.io/2023/08/24/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"测试 hello world!","categories":[{"name":"测试","slug":"测试","permalink":"https://eyjafjalla6.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[]},{"title":"数据库原理mysql版","slug":"数据库原理mysql版","date":"2023-08-24T07:11:21.000Z","updated":"2023-10-05T08:21:41.550Z","comments":true,"path":"2023/08/24/数据库原理mysql版/","link":"","permalink":"https://eyjafjalla6.github.io/2023/08/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86mysql%E7%89%88/","excerpt":"","text":"数据库原理 By：jkloli 参考资料： mysql_note/README.md at main · Buildings-Lei/mysql_note · GitHub MySQL - 智云知识 (dhc.pythonanywhere.com) http://t.csdn.cn/jM0hE CiCi喜之郎 http://t.csdn.cn/XolDf 粉红色的Pig … 0. 问题解决 mysql命令行不要忘了; mysql命令行注释-- zerofill要在not null前面 mysql中``用于引用数据库对象，防止歧义。''用于引用字符串对象。 ''空串不是null 给字符类型赋值，右侧一定要打双引号或单引号 同一个数据库中表名不能重复。 条件判断时逻辑判断 -- 不等于其中一个就行 select sno from s where s.sno!=any(select sc.sno from sc) order by sno asc; -- 不等于任何一个 select sno from s where s.sno!=all(select sc.sno from sc) order by sno asc; select sno from s where not s.sno=any(select sc.sno from sc) order by sno asc; select sno from s where s.sno not in (select sc.sno from sc) order by sno asc; mysql数据库备份记得用cmd，而不是power shell cmd记得chcp 65001，防止中文字符串乱码 1. 环境配置 0 系统是win11 1 先安装navicat，mysql。(知乎，csdn教程) 2 配置用户和系统环境变量（mysql.exe路径），直接置顶 3 windows以管理员方式开终端 net stop MySQL80 #停止服务 net start MySQL80 #开启服务 chcp 65001 #临时改命令行编码为utf-8 mysql -h \"127.0.0.1\" -uroot -p #登录MYSQL mysql>ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; #修改用户密码为123456 mysql> exit #退出mysql net stop MySQL80 #停止服务 2. 概述 1. 一些概念 比较细碎的1 从数据管理角度分析，数据库的发展可以分为三个阶段： 人工管理阶段 20世纪50年代中期之前 文件系统阶段 20世纪50年代中期到60年代中期 数据库系统阶段 20世纪60年代后期 数据(Data)：描述事物的符号记录。数据与语义是分不可开的。 数据库(DataBase)：是长期存储在计算机内，有组织，可共享的大量数据的集合。 ​ 特点：较小的冗杂度，较高的数据独立性和多扩展性。 数据库管理系统（DataBase Management System，DBMS）：位于用户应用与操作系统之间的一层数据管理软件。 数据库系统（DBS）：是由数据库，数据库管理系统（及应用开发工具），应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统。 ​ 特点：1. 数据结构化 2. 数据的共享性高，冗余度低且易扩充 3. 数据独立性高 4. 数据由数据库管理系统统一管理和控制。 信息世界基本概念 实体（行/记录/元组）：是客观存在并可以相互区别的事物，对应数据表中的一行“记录”。如：“张三”。 属性（列/字段）：是事物本身固有的性质，对应数据表中的“字段”或“列”。如：“姓名”。 码(key)：唯一标识实体的属性集。主键也叫主码。如：学生(学号(主键),姓名,班级)。 实体型：用实体名及其属性名集来抽象和刻画同类实体。如：学生(学号,姓名) 实体集：同一类型实体的集合。如：全体同学。 联系：一对一，一对多，多对多。 数据模型 数据模型：分为概念模型(层次模型)，逻辑模型，物理模型。 ​ 逻辑模型：按计算机系统的观点对数据建模，用于DBMS实现。 ​ 物理模型：描述数据在系统内(磁盘上)的表达方式和存储方式。 数据模型的组成要素：数据结构，数据操作，数据的完整性约束条件。 数据独立性：物理独立性，逻辑独立性。 ​ 物理独立性：用户的应用程序与数据库中数据的物理存储是独立的。比如内模式。 ​ 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。比如外模式。 第一代数据模型：层次模型(树状结构)，网状模型(网状) 第二代数据模型：关系模型 比较细碎的2 关系模型：建立在集合代数基础上的数据模型。 ​ 术语： 关系名(表名) 关系模式(表头) 关系(二维表) 元组(记录/行) 属性(列) 属性名(列名) 属性值(列值) 分值(一条记录中的一个列值) 非规范关系(表中有表) 关系的完整性约束条件:实体完整性，参照完整性，用户定义完整性。 ​ 实体完整性：主码非空且不重复。 ​ 参照完整性：外键不为空(或均为空值)。 ​ 用户定义完整性：用户定义的完整性约束条件。 三级模式结构：外模式，模式，内模式。 ​ 外模式可以多个，模式和内模式只能一个。 数据表与数据库 数据表就是记录的集合 。 数据库就是数据表、数据库关系和数据库关系对象的集合。 在数据库连接中，默认的数据库： information_schema：提供了访问数据库元数据的方式。 mysql：是mysql的核心数据库。 performance_schema ：主要用于收集数据库服务器性能参数。 test ： mysql创建的测试库。 笛卡尔乘积 2. E-R图 E-R图，也称为实体关系图，用于显示实体集之间的关系。 实体： 用矩形框表示，将实体名写在框内。 属性： 用椭圆框表示，将属性名写在框内，用连线将实体与属性连接。 联系： 用菱形框表示，将联系名写在框内，用连线将相关的实体连接，并在连线旁标注联系类型(一 0 对 一 “1：1”、一对多 “1：n”、多对多 “n：m”)。 3. 数据库类型 在文件中读写数据速度相对较慢，所以现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。 数据库可以分为关系型数据库和非关系型数据库。 所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS即关系数据库管理系统(Relational Database Management System)的缩写。 特点： · 数据以表格的形式出现 · 每行为各种记录名称 · 每列为记录名称所对应的数据域 · 许多的行和列组成一张表 · 若干的表组成database 关系型数据库：表与表之间存在对应关系。 非关系型数据库：表之间不存在关系，数据独立，随便存。 4. 常见的数据库管理系统 oracle:在全球范围内市场份额占据32% sql server: 在我国，.net平台和sql server数据库应用也极其广泛 Sybase: 广泛应用于我国的大中型应用软件中 IBM/DB2:在OS/2和windows系统中应用广泛 mysql:简单，开源，功能强大 5. MySQL介绍 ​ MySQL是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 Mysql是开源的，所以你不需要支付额外的费用。 Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL使用标准的SQL数据语言形式。 Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。 MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。 6. SQL概述 SQL(Structured Query Language),即结构化查询语言，是高级的非过程化编程语言。SQL是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系型数据库系统。 SQL分类： 数据查询语言（Data Query Language） DQL 数据操纵语言（Manipulation）DML 数据定义语言（Definition）DDL 数据控制语言（Control）DCL 实际上不同数据库系统之间的SQL不能完全相互通用。 2. navicat基础操作 1. 使用navicat创建数据库 1.先在命令行启动服务net start MySQL80 (一般已经启动了) 2.然后开navicat，连接测试，然后点确定。 3.右键连接名，选新建数据库（或命令行界面） 4.选阉割版的utf-8字符集，下面那个选大小写不敏感。 utf8mb3 ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。 utf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。 在utf8mb4下，英文占1个字符，中文3个，特殊符号4个. 2. 修改字段属性 右键点击需要修改的表，选择「设计表」，然后在右侧编辑字段属性 3. 添加数据 打开表后在左下角有加号。 快捷键：insert添加记录，ctrl+s保存记录。 4. 查询表 5. 备份和还原数据库 选中要备份的数据库—&gt;右键—&gt;转储SQL文件—&gt;结构和数据： 成功则可以生成一个sql文件，然后在另一个空的数据库-&gt;右键 -&gt;运行SQL文件。 数据库右键-&gt;刷新。 3. 数据类型 1. 数字类型 整数类型 二进制,有符号数,首位为1的是负数,首位为0的是正数。 数据类型 字节数 无符号数的取值范围 有符号数的取值范围 TINYINT 1 0~255(2^8-1) - 128 ~ 127 SMALLINT 2 0~65 535 - 32 768 ~ 32 767 MEDIUMINT 3 0~16 777 215 - 8 388 608 ~ 8 388 607 INT 4 0~4 294 967 295 - 2 147 483 648 ~ 2 147 483 647 BIGINT 8 0 ~ 18 446 744 073 709 551 615 - 9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807 浮点数 比如：price double(5,2)可以表示-222.22 数据类型 字节数 负数的取值范围 非负数的取值范围 FLOAT 4 －3.402 823 466E + 38 ～－1.175 494 351E－38 0 和 1.175 494 351E－38～3.402 823 466E+38 DOUBLE 8 －1.797 693 134 862 315 7E + 308 ~ －2. 225 073 858 507 201 4E－308 0 和 2.225 073 858 507 201 4E－308～1.797 693 134 862 315 7E + 308 定点数类型 包括decimal和numeric。 DECIMAL(M,D) 设置精度（总位数）和标度（小数点后位数）。 其中，M表示数字总位数（不包括“.”和“-”)，最大值为65，默认值为10；D最大值为30，默认值为0。 例如，DECIMAL(5，2) 表示的取值范围是 －999.99～999.99。 若小数部分超出范围，会进行四舍五入，并出现 Data truncated(数据截断) 警告。 若整数部分超出范围，会报错。 2. 事件和日期类型 数据类型 取值范围 日期格式 零 值 YEAR 1901 ~ 2155 YYYY 0000 DATE 1000-01-01 ~ 9999-12-3 YYYY-MM-DD 0000-00-00 TIME －838:59:59 ~ 838:59:59 HH:MM:SS 00:00:00 DATETIME 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 0000-00-00 00:00:00 TIMESTAMP 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 0000-00-00 00:00:00 如果插入的数值不合法，系统会自动将对应的零值插入数据库中。 用1901或&quot;1901&quot;表示1901年 若是YY表示年，其中'00'~'69' 的值会被转换为2000~2069的值，70'~'99' 的值会被转换为 1970~1999 的值 当使用 YEAR 类型时，一定要区分 '0' 和 0。因为字符串格式的 '0' 表示的 YEAR 值是 2000，而数字格式的 0表示的 YEAR 值是 0000 。 3. 字符串类型 文本字符串 数据类型 类型说明 储存需求 CHAR(M) 固定长度字符串 M个字符，M区间[0,255] VARCHAR(M) 可变长度字符串 L+1个字节。M取值与字符集有关，不超过65535字节 TINYTEXT 非常小的 L+1字节，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，L&lt;2^16 MEDIUMTEXT 中等大小的 L+3字节，L&lt;2^24 LONGTEXT 非常大的 L+4字节，L&lt;2^32 ENUM(‘value1’,‘v2’) 枚举类型 1或2个字节，取决于枚举值的个数（&lt;=65535） SET(‘v1’,‘v2’) 一个集合，字符串对象可以有零个或多个集合成员 1,2,3,4或8个字节，取决于set成员数目(最多64) varchar varchar(10)插入超出10个会报错。 varchar(4)可以插入&quot;abcd&quot; 需要额外的1个或2个字节记录字符串的长度，字符串长度小于255字节使用1个字节，否则使用2个。 当定义一个字段类型为 varchar(10)，插入的值为&quot;abc&quot;这一字符串时，那么实际存储大小为3个字节，除此之外，varchar还需要使用1个额外字节（因为‘abc’字节数＜255）来记录字符串的长度。 char 长度不够时内部储存用空格填充。 name char(3)可以存放&quot;abc&quot; char(3)超过三个字符会报错。 另外 在创建表时，char和varchar需要指定长度，但是text，tinytext，mediumtext，longtext数据类型不需要指定长度。 二进制字符串 数据类型 说明 储存需求 BIT(M) 位数据类型 (M+7)/8字节，M区间[1,64] BINARY(M) 固定长度的二进制字符串 M字节 VARBINARY(M) 可变长度的二进制字符串 M+1字节 TINYBLOB(M) 非常小的 L+1字节，L&lt;2^8 BLOB(M) 二进制大对象（Binary Large Object） L+2字节，L&lt;2^16 MEDIUMBLOB(M) 中等大小的 L+3字节，L&lt;2^24 LONGBLOB(M) 非常大的 L+4字节，L&lt;2^32 BLOB一般用来存图片。 4. JSON数据类型 略。 4. SQL分类详解 1. DDL 数据定义语言 1. 数据库操作 #查看数据库 mysql>show databases; #创建数据库db1 create database db1; #创建数据库并设置编码格式 create database db9 character set gb2312; #删除数据库db1 drop database db1; /*使用名为mysql数据库*/ use mysql; select database(); -- 显示当前所使用的数据库 show create database 数据库名; -- 查看这个数据库的建库语句； 2. 表操作（重要） 注意： 创建表名不超过64字符，不重名(mysql表名不区分大小写)。 表名为mysql关键字时需要用反引号，比如create 同一表中不能有重名字段。 显示当前数据库内所有的表名 show tables; 查看建表语句 show create table 表名; 查看user数据表的结构（主要看类型） desc user; 创建新表 create table 表名( 字段名 类型(长度), 字段名 类型(长度) ); 添加字段： ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]; 修改数据类型： ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型： ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; 删除字段： ALTER TABLE 表名 DROP 字段名; 修改表名： ALTER TABLE 表名 RENAME TO 新表名 删除表： DROP TABLE [IF EXISTS] 表名; 删除表，并重新创建该表： TRUNCATE TABLE 表名; 实际操作 -- 创建新表 create table teacher( id int(10) primary key auto_increment comment \"编号\", -- 编号 类型 主键 自增 注释表名 注释 name varchar(10) unique,-- 不重复 age int(10) zerofill not null ,-- 宽度不够则左侧补0,非空 classId int(10) unsigned default 1 -- 这里不要打逗号，默认1 )engine=innodb,charset=utf8; drop table teacher; -- 删除新表 int(3)表示最大宽度（显示宽度）为3，比如666，-666。 若数值的位数小于显示宽度，会填充空格，若大于显示宽度，则不影响显示结果。 设置零填充后，字段自动设为无符号类型，这是因为负数不能使用负填充。 zerofill要在not null前面 alter table test2 add id int(10); alter table test2 modify name varchar(20); alter table test2 change id age int(10); alter table test2 drop age; alter table test2 rename to test3; truncate table test3; drop table if exists test3; 注意如果已经存了char数据，修改成int参数类型会报错。 int类型储存的int数据可以转换成char类型。 2. DML（数据操作语言） 1. 添加数据 insert 指定字段： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 全部字段： INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 2. 更新和删除数据update,delete 修改数据： UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ]; 删除数据： DELETE FROM 表名 [ WHERE 条件 ]; insert into teacher value(1,\"gg\",56,3); insert into teacher value(2,\"bfb\",56,3); delete from teacher where id=2; update teacher set name = 'mom' WHERE id = 1; -- 给字符类型赋值，右侧一定要打双引号或单引号。 select * from teacher; 3. DQL（数据查询语言） 关键字书写顺序 SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 关键字执行顺序 FROM&gt; WHERE &gt; GROUP BY &gt;having&gt; SELECT &gt; ORDER BY &gt;limit 1. 基础查询 select 查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： select `name` as '名字' from teacher; -- 名字是别名 select `name` '名字' from teacher; -- 只改变显示，不改字段名 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '\\_张三' ESCAPE '\\' \\ 之后的_不作为通配符 select distinct age from teacher; -- 可以匹配_xx select name from user where name like '\\_%' ; 2. 条件查询 where 语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： > >= &lt; &lt;= = &lt;>或!= between ... and ... -- 比如between 10 and 20,在[10,20]区间内 in(...) -- 多选一,比如in(20,35,40) like 占位符 -- 模糊匹配 is null -- 是空 is not null -- 非空 &amp;&amp; 或 and -- 且 || 或 or -- 或 ! 或 not -- 非 mysql常用通配符 %表示任何字符出现任意次数（包括0次） _表示匹配一个字符。 -- 可以匹配abc,ABC(忽略大小写) SELECT * from test1 where name like '%B%'; -- 可以匹配ABC(加了binary不忽略大小写) SELECT * from test1 where binary name like '%B%'; -- 不匹配a SELECT * from test1 where binary name like 'a_'; 3. 聚合查询count,avg… 常见聚合函数： 函数 功能 count() 统计数量 max() 最大值 min() 最小值 avg() 平均值 sum() 求和 例： select count(*)id from test1 where age between 1 and 5 having id>3;-- count(*)id等价于count(id) 4. 分组查询group by 相关函数：avg平均,count计数,sum总和,max最大,min最小 group by分组之后可能出现一个单元格有多个值并报错。比如分组后name为aa的一行中，id同时有1和2。一般需要用聚合函数或group_concat解决。 语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; 例如： select group_concat(`name`),`age` from test1 group by `age`; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 select s.sno as \"学号\",s.sn as \"姓名\",avg(sc.score) as \"平均成绩\" from s,sc,c where sc.sno=s.sno group by sc.sno having avg(sc.score)>80 order by s.sno asc; 5. 排序查询order by 语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 6. 分页查询limit 语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 100 实际操作 4. DCL 1. 管理用户 查询用户： USE mysql;SELECT * FROM user; 创建用户: CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码： ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户： DROP USER '用户名'@'主机名'; 主机名可以使用 % 通配 -- 只能主机localhost访问 create user 'user2'@'localhost' identified by '123456'; -- 任意主机访问 create user 'user3'@'%' identified by '123456'; create user 'user4' identified by '123456'; -- 修改密码 alter user 'user2'@'localhost' identified with mysql_native_password by '123'; -- 删除用户 drop user 'user2'@'localhost'; 2. 权限控制 常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 USAGE 不优先 查询权限： show grants for '用户名'@'主机名'; 授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 show grants for 'user2'@'localhost'; GRANT SELECT, INSERT ON db1.test1 TO 'user2'@'localhost'; GRANT USAGE ON *.* TO `user2`@`localhost`; revoke select,insert on db1.test1 from `user2`@`localhost`; 5. mysql正则表达式 a{5} a只能出现5次 a{1,3} a取值范围[1,3] [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 [1] 以charlist开头的列 X$ 表示以字母 X 结尾的字符串。 . 匹配任何一个字符，包括回车、换行等 x* x{0,}。星号匹配 0 个或多个字符，在它之前必须有内容。 x? x{0,1}。问号匹配 0 次或 1 次。('baa?na’匹配一个a或者0个a) x+ x{1,}加号匹配 1 个或多个字符，在它之前也必须有内容。 (abc)* 匹配任意多个abc（包括空串) *? (懒惰)重复任意次，但尽可能少重复 .* (贪婪)尽可能多匹配 下面在mysql里需要两条反斜杠（大小写敏感） \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束（\\blove\\b匹配&quot;i love you&quot;中的love） \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。(regular-expression) 正则表达式默认不区分大小写。 -- 查询找到所有名称以元音开始和 ok 结束的: SELECT name FROM tb1 WHERE name REGEXP '^[aeiou]|ok$'; -- 匹配元素是1-3个a，可以匹配a,aa,aaa SELECT name FROM test1 WHERE name REGEXP '^a{1,3}$'; -- 匹配元素含有1-3个a，可以匹配aaaa SELECT name FROM test1 WHERE name REGEXP 'a{1,3}'; 6.函数 1. 字符串函数 -- 拼接,HelloWorld SELECT CONCAT('Hello', 'World'); -- 小写,hello SELECT LOWER('Hello'); -- 大写,HELLO SELECT UPPER('Hello'); -- 左填充,---01 SELECT LPAD('01', 5, '-'); -- 右填充,01--- SELECT RPAD('01', 5, '-'); -- 去除两边空格,Hello World SELECT TRIM(' Hello World '); -- 切片（起始索引为1）,Hello SELECT SUBSTRING('Hello World', 1, 5); -- 替换，结果是http:www.google.com.cn SELECT REPLACE('http://www.google.com.cn/','/',''); -- 类型转换 下面浮点数转字符串 cast(3.14 as char(4)) convert(3.14,char(4)) 2. 数值函数 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 3. 日期函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 4. 系统信息函数 功能 charset(str) 返回str字符集 current_user()session_user()user()system_user() 返回当前用户名称 connection_id() 当前用户连接id schema() 当前数据库名 version() 数据库版本号 5. 流程函数 if(value, t, f) 如果value为true，则返回t，否则返回f ifnull(value1, value2) 如果value1不为空，返回value1，否则返回value2 if…then…elseif…then…else…end if; case when…then…when…then…else…end case…when…then…when…then…else…end 类似c语言switch select if(true, 'Ok', 'Error'); -- OK -- ''空串不是null,返回''空串 select ifnull('', 'Default'); -- 返回Default select ifnull(null, 'Default'); select name, (case when '北京' then '一线城市' when '深圳' then '一线城市' else '二线城市' end) as '城市级别' from tb_employ; select name, (case math when 100 then '满分' when 0 then '鸭蛋' else '不完美的战士也是战士' end) as '评价' from tb_score; update tb_Salary set sex=if(sex=\"f\",\"m\",\"f\") ; SELECT sno,CASE sex WHEN '男' THEN 'M' WHEN '女' THEN 'F' END AS sex FROM s; 7. 约束 1. 常见约束 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且不重复,每张表最多一个 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 自增 详见下面 AUTO_INCREMENT # 列级约束 字段名 数据类型 PRIMARY KEY #表级约束 PRIMARY KEY（字段名1,字段名2,…） create table tb4( id int primary key auto_increment, name varchar(10) not null unique, age int check(age > 0 and age &lt; 120), status char(1) default '1', gender char(1) ); 2. 外键约束foreign key 候选键（Candidate Key）：一个属性或属性组的值能唯一标识一个元组，而子集不能。 比如，想要知道某位学生的某门课程的成绩Grade，那我们必须要知道该学生的学号Sno以及课程号Cno。此时X[Sno,Cno]称为S的一个候选码。 主键：当有多个候选键时，可以选定一个作为主键，选定的候选键称为主键（主码）。 外键：一个表（从表，参照表）的字段引用主表（被参照表）的主键或者唯一键。 前提： 1、创建外键的表和列存在 2、组成外键的列存在索引 3、必须指定数据表的引擎为InnoDB 4、外键字段和关联字段，数据类型和长度必须一致 5、引用字段的值必须存在于被引用表中。 6、定义外键约束名称(如FK_ID)时，不能加单引号和双引号，可以反引号。 行为 说明 no action 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） restrict 与no action一致 cascade 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 set null 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） set default 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 1. 创建外键 create table father( cid varchar(10) unique, classname char(4) ); create table child( id int(10) primary key auto_increment, name char(4) , classid varchar(10), constraint 外键约束名 foreign key (classid) references father(cid) on delete restrict on update cascade );-- 外键约束名不加引号 insert into father values(1,'一班'); insert into father values(2,'二班'); insert into father values(3,'三班'); -- 报错，因为父表没有为5的cid insert into child values(1,'张三',5); -- 子表插入记录成功 insert into child values(1,'张三',3); //使用alter table创建外键 ALTER TABLE mydb.employees ADD CONSTRAINT FK_ID FOREIGN KEY (dept_id) REFERENCES department (id) ON DELETE RESTRICT ON UPDATE CASCADE; 2. 查看外键 mysql> desc db1.child classid; +---------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+-------------+------+-----+---------+-------+ | classid | varchar(10) | YES | MUL | NULL | | +---------+-------------+------+-----+---------+-------+ 1 row in set (0.11 sec) 添加了外键约束的classid 字段的 Key(索引) 值为MUL，表示非唯一性索引(MUL TIPLE KEY)，值可以重复。 3. 修改和删除外键 -- 修改外键 ALTER TABLE child DROP FOREIGN KEY 外键约束名,add constraint 外键名 foreign key (classid) references father(cid) on delete cascade on update cascade; -- 删除外键 ALTER TABLE child DROP FOREIGN KEY 外键名; 4. 启用或禁用外键 -- 禁用约束 ALTER TABLE 表名 DISABLE CONSTRAINT 约束名; -- 启用约束 ALTER TABLE 表名 ENABLE CONSTRAINT 约束名; 3. 自动增长 一个表中只能有一个自动增长字段，该字段的数据类型是整数类型，且必须定义为键，如 UNIQUE KEY 、PRIMARY KEY 若为自动增长字段插入 NULL、0、DEFAULT 或在插入时省略该字段，则该字段就会使用自动增长值；若插入的是一个具体值，则不会使用自动增长值。 自动增长值从 1 开始自增，每次加 1。若插入的值大于自动增长的值，则下次插入的自动增长值会自动使用最大值加 1；若插入的值小于自动增长值，则不会对自动增长值产生影响。 使用 DELETE 删除记录时，自动增长值不会减小或填补空缺。 -- 自增初值为100，每次自增1 alter table test1 auto_increment=100; -- 添加自动增长 ALTER TABLE 表名 MODIFY 字段名 字段类型 [字段属性] AUTO_INCREMENT; -- 删除自动增长 ALTER TABLE 数据库名 MODIFY 字段名 字段类型 [字段属性]; 8. 多表查询 1. 多表关系 一对多 比如一个部门对应多个员工，一个员工对应一个部门 实现：在多的一方建立外键，指向一的一方的主键 多对多 比如一个学生可以选多门课程，一门课程也可以供多个学生选修 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为unique。 2. 合并查询 合并查询（笛卡尔积，会展示所有组合结果）： select * from child,teacher,father; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔乘积 select * from child,teacher,father where teacher.id=child.id; 3. 内连接查询 内连接查询的是两张表交集的部分 隐式内连接： SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接： SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; select e.name, d.name from employee as e, dept as d where e.dept = d.id; select * from test2 inner join teacher on test2.id=teacher.id; 4. 外连接查询 左外连接： 查询左表所有数据，以及两张表交集部分数据 SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...; 相当于查询表1的所有数据，包含表1和表2交集部分数据,outer可以省略 右外连接： 查询右表所有数据，以及两张表交集部分数据 SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 相当于查询表2的所有数据，包含表1和表2交集部分数据 -- 左 select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;-- e是别名 select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样 -- 右 select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 5. 自连接查询 当前表与自身的连接查询，自连接必须使用表别名。 语法： SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询。 -- 查询员工及其所属领导的名字,输出时a.name替换成员工名字 select a.name as 员工名字, b.name as 所属领导名字 from employee a, employee b where a.managerid = b.id; -- 没有领导的也查询出来 select a.name, b.name from employee a left join employee b on a.managerid = b.id; 在连接查询时，若数据表连接的字段同名，则连接时的匹配条件可以使用 USING 代替ON，多个同名的连接字段之间用逗号分隔。 6. 联合查询union，union all 把多次查询的结果合并，形成一个新的查询集。 union会对结果进行并集操作，去除重复行。 union all 将查询结果合并，保留重复行。 -- 不去重，升序排序 select money from test2 union all select money from test3 order by money ASC; -- 去重 select money from test2 union select money from test3 order by money ASC; 联合查询比使用or效率高，不会使索引失效 7. 子查询(嵌套查询) SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2); 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 1. 标量子查询 -- 查询在张三入职时间后公司新来同事 select * from employee where entrydate > (select entrydate from employee where name = '张三'); 2. 列子查询 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 select money from test3 where money in (select money from test2 ); select money from test3 where money>any(select money from test2 ); -- 大于其中之一 select money from test3 where money>all(select money from test2 ); -- 大于全部 3. 行子查询 select * from test3 where (id,money) in (select id,money from test2 where id=6); 4. 表子查询 select * from test3 where (id,money) in (select id,money from test2); 9. 视图与索引 1. 视图 视图是在一个、多个基本表或视图基础上，通过查询语句定义的虚拟表格。 视图可用于SELECT语句中进行查询 视图只存储定义语句，不存储其数据 当使用视图进行查询时，视图包含的数据才会临时生成。 视图作用：提升数据操作的便携性，提升了数据的安全性，提升了数据的逻辑独立性，视图可用于数据集成。 视图的工作机制：视图中的内容总是与基本表中数据保持一致，即当基本表中数据发生变化时，相关视图的数据也随之变化。 1. 视图创建 CREATE [OR REPLACE ] [ALGORITHM={ UNDEFINED | MERGE | TEMPTABLE}] [DEFINER = { user | CURRENT_USER }] VIEW 视图名[(视图字段列表)] AS 查询语句 [WITH [CASCADED | LOCAL] CHECK OPTION]; 添加OR REPLACE可选参数表明可以在创建视图时替换数据库已有8同名视图。 ALGORITHM表示视图的使用方法。其中，UNDEFINE表示由MySQL自行决定使用方法。 WITH CHECK OPTION表示更新、修改和插入视图数据时，只有满足检查条件操作才会执行。 -- 创建视图 create or replace view s_view as select * from s where dept='信息学院'; -- 多张基本表上创建视图 create or replace view ts_view(name,age) as select tb_score.name,age from teacher,tb_score where teacher.id=tb_score.id; -- 在视图上创建视图 CREATE VIEW s_maj_view AS SELECT * FROM s_view WHERE maj='计算机'; 不能在SELECT语句中包含系统、用户变量以及处理语句参数，同时不能在FROM子句中包含子查询 删除视图依赖的基本表后，视图使用会报错，可通过“CHECK TABLE 表名”检查基本表状态。 不能为临时表创建视图。 创建视图时，ALGORITHM参数指定对部分查询结果具有影响。 2. 视图管理 -- 查看视图 describe ts_view;-- 查看定义(字段之类) show create view ts_view;-- 查看结构 -- 删除视图 drop view if exists ts_view; -- 更新视图的数据(其实更新的是对应的基本表数据) INSERT INTO s_update_view VALUES('s10','韩义','男',19,'计算机','信息学院'); UPDATE s_update_view SET age = 20 WHERE sno = 's10'; DELETE FROM s_update_view WHERE sno = 's10'; 2. 索引 优点： –提高查询执行的速度。 –强制实施数据的唯一性。 –提高表之间联接的速度。 缺点 –存储索引要占用磁盘空间。 –数据修改需要更长的时间，因为索引也要更新。 –创建索引要花时间。 按索引特征：普通索引、唯一索引(unique)、主键索引、全文索引(fulltext)和空间索引(spatial)。 根据索引存储方式进行分类：B-Tree索引、Hash索引 根据索引与数据物理存储关系：聚集型索引、非聚集型索引 根据索引涉及列数进行：单列索引、复合索引 复合索引需要遵循最左匹配原则。 1. 索引创建 CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX 索引名称 ON 表名称(字段名称[(索引字符长度) [ASC | DESC]][,...]); 当字段名称[(索引字符长度) [ASC | DESC]]只有一项时，将建立单列索引。当字段名称[(索引字符长度) [ASC | DESC]]有多项时，将建立复合索引。 create index t_name_index on teacher(name(3) desc); -- 为teacher创建普通索引，针对name的前三个字符降序排列 create unique index c_cn_ct_index on c(cn,ct); -- 为课程表c的课程名（cn）和学时（ct）字段建立复合唯一索引 create table classroom( cid INT AUTO_INCREMENT, crno VARCHAR(10) NOT NULL,-- 教室编号 cbn VARCHAR(10) NOT NULL,-- 教学楼编号 PRIMARY KEY(cid), unique index nb_index(crno, cbn) );-- 建表时创建索引 -- 为已有表创建索引 alter table teacher add index t_name_index(name(3) desc); 2. 索引管理 查看索引 show index from teacher; 使用索引 alter table teacher add fulltext index t_name_index(name); select * from teacher where MATCH(name) against('aaa');-- 全文索引使用 -- 普通索引跟平常用select没区别 删除索引 alter table teacher drop index t_name_index; drop index t_name_index on teacher; 10. 数据库安全管理 安全控制的一般方法：用户登录，安全审计，权限管理，文件权限，数据加密。 1. 添加用户 create user if not exists 'student'@'localhost' identified by 'student123'; #用户为student，密码student123，只允许在mysql所在服务器上登陆 2. 用户管理 重命名 rename user 'student'@'localhost' to stu@'%'; -- 更名为stu,%表示任意位置 修改密码 mysqladmin -u stu -p password; 修改用户 alter user stu@'%' identified by 'student123'; 删除用户 drop user stu@'%'; delete from mysql.user where user='stu' and host='%'; 3. 权限管理 权限授予 grant all on *.* to 'teacher1'@'localhost' with grant option; #为teacher10用户赋予数据库服务器的所有使用权限（ALL），并允许权限由teacher10授予其他用户。 GRANT SELECT, INSERT, UPDATE ON *.* TO 'teacher6'@'localhost'; #为teacher6用户赋予数据库服务器级别的查找、插入和更新数据权限（SELECT、INSERT、UPDATE），并且不允许二次授权。 GRANT SELECT(tno, tn) ON teaching.t TO 'teacher2'@'192.168.1.23'; #为teacher2用户赋予teaching数据库中教师表t上tno字段和tn字段的查找数据权限SELECT，并不允许权限由teacher2授予其他用户。 权限查看 show grants for 'student'@'localhost'; SHOW GRANTS FOR CURRENT_USER; 权限回收 revoke select,delete on *.* from 'student'@'localhost'; 权限转移 grant all on *.* to 'teacher1'@'localhost' with grant option; #允许teacher1将权限转移给其它用户 4. 角色管理 角色（Role）是对权限集中管理的一种机制，通常根据特定需要，将一系列权限集中在一起构成角色。 一个用户可以分配多个角色，也允许一个角色分配给多个用户 角色创建 #创建可在任意主机上使用的教师角色和管理员角色。 create role 'teacher','administrator'; #创建可在本地主机上使用的开发者角色。 CREATE ROLE 'developer'@'localhost'; 角色授权 grant all privileges on *.* to administrator; #为管理员角色administrator授予服务器级别全局权限。 GRANT SELECT, INSERT, UPDATE, DELETE ON teaching.sc TO 'teacher'; #为教师角色teacher授予teaching.sc表级别的查找SELECT、插入数据INSERT、更新数据UPDATE和删除数据DELETE权限。 角色激活 #为用户teacher2分配角色 grant 'teacher' to 'teacher2'; #角色激活 set default role 'teacher' to 'teacher2'; -- 使用户teacher2上的teacher角色生效。 SET DEFAULT ROLE ALL TO 'teacher3'; -- 使用户teacher3上的所有角色生效。 角色查看 select current_role(); -- 查询当前用户生效的角色。 角色注销 revoke 'teacher' from 'teacher2'; -- 回收用户teacher2的角色teacher。 drop role 'teacher'; -- 删除角色teacher。 11. 数据库并发控制与封锁 1. 数据库并发性的含义 数据库最大的特点是数据共享，允许同一时间供多个用户根据自己的需要来操作数据库。 串行：一个用户在运行程序时，其他用户程序必须等到这个用户程序结束才能对数据库进行存取。 并行：最大限度地利用数据库，多个用户并行执行数据库。 数据库的并发性及并发控制机制是衡量数据库系统性能的重要标准。 在 MySQL 中，会话（session）是指客户端与服务器之间的交互过程，包括连接、执行 SQL 语句、获取结果等。 2. 事务及其性质 事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 用户看到的数据总能保持一致性。 1. Mysql支持4种事务模式 自动提交模式：每执行一条SQL就提交 显式模式：有明确的事务开始和结束语句 隐式模式：没有事务开始语句，但有结束语句 分布式模式：适合多服务器系统 start transaction;-- 开启事务 commit; -- 提交所执行的所有操作，标志事务的结束 rollback; /*回滚语句，当事务运行过程中发生故障时，事务不能继续执行，此时回滚操作撤销了事务所做的修改，并结束当前这个事务*/ 2. 事务的性质（四大特性ACID） 原子性(atomicity)：事务是不可分割的最小操作单元，操作要么都执行，要么都不执行 一致性：数据库始终保持一致性。事务完成时，必须使所有数据都保持一致状态。 隔离性：并发执行的事务之间不会相互影响。 持久性(durability)：一个事务被提交后，对数据库中数据的改变是永久性的。 注意：commit没执行，虽然真表的内容没变，但是假表的内容变了，需要回滚假表。(select可以查到假表,navicat双击数据表看到真表) 3. 用户定义的模式 隐式模式： -- 查看事务提交方式 SELECT @@AUTOCOMMIT; -- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效 SET @@AUTOCOMMIT = 0; -- 改为0，则需要在操作完后commit才会修改数据表 update account set money = money - 1000 where name = '张三'; 因为这一行发生错误，所以下面commit不会执行,假表内容被改变了，需要rollback事务 update account set money = money + 1000 where name = '李四'; commit; 显式模式： start transaction;-- 开启事务,也可begin transaction select * from account where name = '张三'; update account set money=money-1000 where name='张三'; update account set money=money+1000 where name='李四'; commit;-- 全部执行成功后，提交事务 3. 并发控制与数据的不一致性 ​ 能够合理调度并发事务，避免并发事务之间的互相干扰造成数据不一致性的技术称为数据库管理系统的并发控制技术。 数据不一致性的种类： 1.丢失更新 ​ 一个事务把另一个对数据的已修改结果覆盖，导致这些修改好像丢失了一样 2.读取脏数据(脏读) ​ 一个事务读取了另一个事务未提交的数据，会造成两个事务得到的数据不一致 3.不可重复读 ​ 一个事务对同一数据的读取结果前后不一致，这是由于读取了另一个事务已修改提交的数据。当其中一个事务需要校验或再确认数据时，出现再读数据与之前读的数据值不相同。(侧重读-读) 4.幻象读(Phantom Read)(幻读) 读到的数据是不真实的。比如select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。(侧重读-写) 原因：其他事务修改、插入、删除了数据。 4. 事务的隔离级别 产生上述四种数据不一致性问题的主要原因是并发的事务操作破坏了事务的隔离性。 为了防止数据库的并发操作导致的数据库不一致性问题，SQL标准定义了4种隔离级别： SELECT @@transaction_isolation; -- MySQL数据库支持所有的隔离级别，查询当前事务隔离级别的语句 -- 设置当前事务的隔离级别(两种方式) SET [global | session] transaction isolation level 隔离级别名称; #global隔离级用于所有用户，session隔离级只用于当前对话和连接 SET transaction_isolation=’隔离级别名称’; 读取未提交事务 READ UNCOMMITTED是最低事务隔离级别，无法避免读取脏数据、不可重复读和幻象读。 -- 设置当前会话隔离级别 set session transaction isolation level read uncommitted; 读取提交的事务 read committed可以避免读取脏数据，但不可避免不可重复读和幻象读。 可重复读 REPEATABLE READ是MySQL默认的隔离级别，确保同一事务内执行相同的查询语句时，读取的结果是一致的。如果事务T2对多行数据进行增加，那么将会出现幻象读的问题。 串行化 SERIALIZABL通过强制事务排序，使事务之间不可能相互冲突。用户之间一个接一个顺序地执行当前事务，从而解决幻象读问题，但是可能导致大量的等待现象。 5. 事务隔离性的实现 按照其对可能重读的操作采取的不同策略可以分为乐观并发控制和悲观并发控制两大类。 乐观并发控制：对于并发执行可能冲突的操作，假定其不会真的冲突，允许并发执行，直到真正发生冲突时才去解决冲突，比如让事务回滚。 悲观并发控制：对于并发执行可能冲突的操作，假定其必定发生冲突。 6. 封锁及封锁协议 封锁是一种用来防止多个事务同时访问数据而产生问题的机制。 封锁可以防止用户读取正在由其他用户修改的数据，并可以防止多个用户同时更改相同数据。 事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。加锁后事务T对该数据对象就有了一定的控制，在事务T释放它的锁之前，其他事务不能更新该数据。 1. 封锁粒度 封锁粒度：封锁的数据库对象的大小。锁定的数据量越少，发生锁争用的可能就越小。在mysql中，封锁粒度分为行级锁和表级锁。 2. 封锁类型 封锁分为排它锁和共享锁两种。 排它锁(eXclusive lock)，简称X锁，又称独占锁或写锁。 排它锁确保不会同时对同一资源进行多重更新。 共享锁(shared lock)，简称S锁，又称读锁。 共享锁允许并发事务读取同一个资源。资源上存在共享锁时，任何其他事务都不能修改数据。除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享锁，那么一旦读取数据，便立即释放资源上的共享锁。 3. 封锁协议 在封锁时约定的一些规则，例如何时申请封锁、申请何种锁、持锁时间、何时释放等，被称为封锁协议（Locking Protocol）。 一级封锁协议： ​ 事务T在修改数据A时必须先对其加X锁，直到事务结束才能释放锁。 ​ 防止丢失更新。 二级封锁协议： 在一级封锁协议的基础上，加上事务T在读取数据R之前必须先对其加S锁，读完后释放S锁。 ​ 防止丢失更新，读脏数据。 三级封锁协议： ​ 在一级封锁协议的基础上，加上事务T在读取数据R之前必须先对其加S锁，读完后并不释放S锁，而直到事务T结束才释放。 ​ 防止丢失更新，读脏数据，不可重复读。 4. 死锁和活锁 死锁（Dead Lock）是指两个或更多的事务同时处于等待状态，每个事务都在等待其中另一个事务解除封锁，它才能继续执行下去，结果造成任何一个事务都无法继续执行。 时 间 事务T1 事务T2 t0 封锁学生表 t1 封锁成绩表 t2 要求封锁成绩表，等待 t3 要求封锁学生表，等待 t4 等待 等待 活锁（Live Lock）是指由于其他事务的封锁操作使某个事务永远处于等待状态，得不到继续操作的机会。 ​ 活锁避免的方法就是采用先来先服务的策略，按照请求封锁的次序对事务进行排队。 12. 存储过程与函数 是一组完成特定功能的SQL语言代码段，经编译后存储在数据库中，可被触发器、其他存储过程、程序设计语言所调用。 1. 定界符与语句块 ​ mysql默认定界符;，可用delimiter命令新建定界符 DELIMITER $$ #表示新的定界符为“$$”，自此开始，直到遇到下一个“$$”，MySQL才会整体执行这段语句代码。 ​ 语句块是由若干条语句构成的程序代码单元，在逻辑上被当作一个整体，语句块中的语句要么被执行，要么整体都不被执行。 #用begin...end定义一个语句块 2. 变量定义与使用 变量具有变量名，变量值，数据类型。 变量分为用户会话变量，局部变量，系统变量。 用户会话变量@ 默认值为NULL，无需给出数据类型 set @a=100,@b=200; set @c:=100,@d:=200; select @e:=100,@f:=200; select max(score),min(score) into @a,@b from sc; 局部变量 在一个语句块内部定义的变量。 定义存储过程时，所有局部变量的声明一定要放在存储过程体的开始 declare total_num int default 0; declare x,y int default 0; declare myname char(10); 系统变量@@ 分为全局变量和会话变量 #查询所有全局变量 show global variables; #查询所有会话变量 show session variables; show variables; #查询某个系统变量的取值 select @@global.wait_timeout;-- 全局变量wait_timeout select @@session.version;-- 会话变量version select @@version;-- 优先查会话变量，再查全局变量 #修改会话变量的值 3. 存储过程的创建和调用 1. 创建 CREATE [DEFINER = { user | CURRENT_USER }] #定义DEFINER,默认为当前用户 PROCEDURE 存储过程名 [SQL SECURITY { DEFINER | INVOKER } | …]#指定DEFINER或INVOKER权限 BEGIN ... END 创建存储过程，计算阶乘 #记得要声明分隔符 drop procedure if exists p1; delimiter $$ create procedure p1() #无参构造 begin declare n,m int;#\"局部变量\" set n=1; set m=1; while n&lt;=10 do set m=m*n; set n=n+1; end while; select m; end$$ delimiter ; #恢复默认分隔符 #调用存储过程 call p1(); 存储过程的形参 in 表示输入参数，调用时必须传入一个确定的值或有确定值的变量。不会影响传入的外部变量(不能被返回)。 out 表示输出参数，调用时必须传入一个用户会话变量，会影响传入的外部变量 inout 表示输入输出参数，调用时必须传入一个有确定值的用户会话变量，会影响传入的外部变量 注意：out，inout不接受系统变量作为实参。 mysql> delimiter $$ create procedure p1(out a char(10)) begin set @a=40; #用户会话变量 set a=80; #存储过程局部变量 select @a,a; end$$ mysql> delimiter ; mysql> set @a=50,@b=30; mysql> call p1(@b);#调用存储过程，传入实参 mysql> select @a,@b; #此时@a=40,@b=80 2. 查看，修改特性，删除 #查看存储过程的定义 show create procedure p1; #查看存储过程的状态特征 show procedure status like \"p%\"; #只能修改存储过程的特性 alter procedure p1 comment '改名了'; alter procedure p1 sql security invoker; #删除 drop procedure if exists p1; 4. 存储过程相关函数 case when…then…when…then…else…end case; while…do…end while; [label:] loop…end loop [label]; 一直循环直到执行leave [label]; [label:] repeat…until…end repeat [label]; 类似do-while DELIMITER // CREATE PROCEDURE test_loop() BEGIN DECLARE id INT DEFAULT 0; add_loop:LOOP IF id &lt; 10 THEN SET id = id + 1; ELSE LEAVE add_loop; END IF; END LOOP add_loop; SELECT id; END // DELIMITER ; CALL test_loop(); 5. 用户自定义函数 #因为开启了二进制日志，所以得设一下下面这个变量 set global log_bin_trust_function_creators=1; delimiter // create function `pt1`() returns int begin return 1; end// delimiter ; select pt1();#调用函数 #查看状态特征 show function status; show function status like \"pt1\"; #查看函数代码 show create function pt1; #修改特征信息 alter function pt1 sql security invoker; #删除函数 drop function pt1; 6. 游标 cursor 游标实际上是一种能从包括多条数据记录的结果集中逐条访问这些记录的机制。 游标主要包括结果集和游标位置。 MySQL游标只能用于存储过程和函数。 #游标声明 DECLARE emp_c CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC; #打开游标 open emp_c; #提取数据 #fetch取出一条记录，游标指针自动向后移动并指向下一条记录。 FETCH emp_c INTO cursor_salary; #关闭游标 close emp_c; 13. 数据库备份还原和日志管理 1. 简介 数据库备份分类 mysql常用数据库备份工具 mysqldump 逻辑备份工具 mysqlhotcopy 仅支持MyISAM 2. mysqldump命令备份 注意：要用cmd，而不是power shell，不然导入不了。 chcp 65001 #登录用户主机为本地，将数据库db1中的teacher表备份到back_file1.sql下 mysqldump -u root -h 127.0.0.1 -proot db1 teacher > C:\\databasestudy\\back_file1.sql #备份所有表 mysqldump -u root -h 127.0.0.1 -proot db1 > C:\\databasestudy\\back_file2.sql #备份表结构 mysqldump -u root -h 127.0.0.1 -proot --opt --no-data db1 teacher > C:\\databasestudy\\back_file3.sql #备份多个表 mysqldump -u root -h 127.0.0.1 -proot db1 teacher student > C:\\databasestudy\\back_file4.sql #备份数据库db1,db2 mysqldump -u root -h 127.0.0.1 -proot --databases db1 db2 > C:\\databasestudy\\back_file5.sql #备份所有数据库 mysqldump -u root -h 127.0.0.1 -proot --all-databases > C:\\databasestudy\\back_file6.sql #备份数据库结构 mysqldump -u root -h 127.0.0.1 -proot --opt --no-data db1 > C:\\databasestudy\\back_file7.sql #备份数据库数据 mysqldump -u root -h 127.0.0.1 -proot --opt --no-create-info db1 > C:\\databasestudy\\back_file8.sql #备份部分数据 mysqldump -u root -h 127.0.0.1 -proot db1 test1 --where=\"age&lt;11\" > C:\\databasestudy\\back_file9.sql 3. 备份还原 未登录服务器用mysql命令还原 mysqldump -u root -h 127.0.0.1 -proot db1 test2 > C:\\databasestudy\\back_file11.sql mysql -u root -p db2 &lt;C:\\databasestudy\\back_file11.sql -- 还原 /*navicat有延时，需要过一段时间再刷新才能看到 据说是本地缓存机制 在cmd登录数据库查看没这个问题*/ 登陆服务器用source命令还原 mysqldump -u root -h 127.0.0.1 -proot db1 test2 > C:\\databasestudy\\back_file11.sql mysql -u root -p use db2; source C:\\databasestudy\\back_file11.sql #这里不能有;号 4. mysql日志管理 注意：cmd里chcp 65001 ​ 日志文件中记录着MySQL数据库运行期间发生的变化；也就是说用来记录MySQL数据库的客户端连接状况、SQL语句的执行情况和错误信息等。 日志文件分为：错误日志，二进制日志，通用查询日志，慢查询日志。 1. 错误日志 默认开启，不能禁止。文件名格式为hostname.err。 my.ini中： log-err定义错误日志的存储位置 log-warnings定义是否将警告信息写入错误日志。 #查看错误日志所在目录及文件名 show variables like '%log_error%'; #删除错误日志(重新加载日志) mysqladmin -u root -p flush-logs 2. 二进制日志 #查看是否开启 show variables like '%log_bin%'; #通过my.ini文件中的log-bin选项可以开启二进制日志 log-bin [=path/[filename]] #路径 expire_logs_days=10 #保留时间 max_binlog_size=100M #单个文件大小限制 #登陆后查看有哪些二进制日志 show binary logs; #查看日志 mysqlbinlog d:/log/DESKTOP-O5KMGM8-bin.000013 #删除二进制日志 PURGE BINARY LOGS BEFORE '2008-04-02 22:46:26'; #删除到某个时间前所有日志 PURGE BINARY LOGS TO 'mysql-bin.010'; #删除到某个日志前(不包括指定日志) #使用mysqlbinlog恢复数据库到某一时刻的状态 mysqlbinlog --stop-datetime=”2021-03-10 10:00:00” C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\DESKTOP-TKC62RP-bin.000005 | mysql -u root -p -- 必须是编号小的先还原 start-datetime、stop-datetime表示恢复数据库的起始时间点和结束时间点。 start-position和stop-position表示恢复数据的开始位置和结束位置。 3. 慢查询日志 慢查询日志在MySQL中默认是关闭的，可以通过配置文件my.ini或者my.cnf中的slow_query_log选项打开。 slow_query_log_file[=path/[filename]] 路径，默认hostname-slow.log long_query_time=n 查询时间超过n则记录，默认10秒 #可以在登陆后开启 set global slow_query_log=on;或 set global slow_query_log=1; #查看慢查询定义的时间值 show global variables like 'long_query_time'; #查看慢查询日志相关变量 show global variables like '%slow_query_log%'; #删除慢查询日志 mysqladmin -u root -p flush-logs; 4. 通用日志管理 默认关闭，可修改my.ini开启，log[=path/[filename]] 也可在登陆后在set global general_log=on/1; show variables like ‘general%’; windows用记事本打开查看。 mysqladmin -u root -p flush-logs; #重设日志 flush logs; #登陆后重设日志 中英对照 cascade 级联 n. [kæˈskeɪd] constraint 约束 n. [kənˈstreɪnt] delimiter 定界符 n. [dɪ’lɪmɪtə] exclusive 排斥的，专有的 adj. [ɪkˈskluːsɪv] phantom 幽灵,幻影 n. [ˈfæntəm] privilege 特权 n. [ˈprɪvəlɪdʒ] procedure 程序，步骤 n. [prəˈsiːdʒə®] protocol 协议 n. [ˈprəʊtəkɒl] charlist ↩︎","categories":[{"name":"大二","slug":"大二","permalink":"https://eyjafjalla6.github.io/categories/%E5%A4%A7%E4%BA%8C/"}],"tags":[]},{"title":"python学习笔记","slug":"python学习笔记","date":"2023-07-14T10:41:35.000Z","updated":"2023-08-24T08:40:31.421Z","comments":true,"path":"2023/07/14/python学习笔记/","link":"","permalink":"https://eyjafjalla6.github.io/2023/07/14/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"python3 学习笔记 1. 基础 多行语句：\\用反斜杠后换行，在 [], {}, 或 () 中的多行语句，不需要使用反斜杠，直接换 #导入模块格式 from somemodule import firstfunc, secondfunc, thirdfunc from somemodule import * #导入模块中的所有函数 import somemodule from sys import argv,path # 导入特定的成员 print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 输出方法 chr() ascii码转为string，chr(65)表示A ord() 字符串转int类型的ascii码,ord(“0”)表示48 range(5,10) 区间左闭右开 #coding:utf-8 #设置编码为utf-8 #print()自带换行 if __name__ == '__main__': name = 'jay zhou' age = 29 print(\"hello world!\");print(\"yes\"\\ r\"\\n\") ''' 同一行两句代码分号隔开 第一个\\表示代码换行继续写 加r表示不转义\\n ''' print(\"\"\"我的年龄是 \"\"\"+str(age), end=\" \" )# 不换行输出 print(f\"大家好，我是{name},今年{age}岁\") print(\"大家好，我是{0},今年{1}岁\".format(name, age)) print(\"大家好，我是%s,今年%d岁\" % (name, age)) w = {\"who\":8,\"am\":5,\"i\":7} print(f'{w[\"who\"]} {w[\"am\"]} {w[\"i\"]} ',666)#8 5 7 666 #不同数据类型逗号隔开 输入方法 #coding:utf-8 name = input(\"请输入一个名字: \\n\") print (name,end='')#表示不换行 print()#表示换行 print(type(name)) 2. 数据类型 数字，字符串，布尔类型，列表，元组，集合，字典。 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 变量都具有三个基本要素：分别是 id，type，value。 赋值方法 #同时为多个变量赋值,id相同 a = b = c = 1 #为多个对象指定多个变量。例如： a, b, c = 1, 2, \"runoob\" 变量命名规则： 变量名必须以字母或下划线字符开头 变量名不能以数字开头 变量名称只能包含字母数字字符和下划线 变量名区分大小写 不能与关键字重复 关键字 and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield 数据处理的一些函数 enumerate()函数用于将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标 格式: enumerate(sequence, [start=0]) #start参数可以不填 seasons = ['Spring', 'Summer', 'Fall', 'Winter'] list(enumerate(seasons,start=1)) # 输出 [(1, 'Summer'), (2, 'Fall'), (3, 'Winter')] map()函数 def f(x): return x * x r = map(f, [1,2,3,4,5,6,7,8,9]) print(list(r)) #[1, 4, 9, 16, 25, 36, 49, 64, 81] filter()函数 #filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 #filter()也接收一个函数和一个序列。 # 在一个list中，删掉偶数，只保留奇数 def is_odd(n): return n % 2 == 1 print(list(filter(is_odd,[1,2,3,4,5,6,7,8,9]))) #[1, 3, 5, 7, 9] 强制类型转换 x = float(1) # x 输出结果为 1.0 complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 int(s1)#强制转为int类型 float(s1)#强制转为float类型 str(s1)#转为string l1=list(s1)#转为列表 s3=set([1,2,3,4])#转为集合 ord() #转数字 chr() #转字符 bin() #转二进制 hex() #转16进制 bytes() #转为字节数组，比如bytes('我喜欢python',encoding='utf-8') Number数字 支持 int、float、bool、complex（复数） a=3.14 print(True==1)#TRUE,bool在一定情况被解释成整数 print(True+1)#2 print(0 is False)#is来判断变量id是否一致 del a;print(a) #del语句删除对象引用a,不会输出东西 from decimal import Decimal#防止浮点数存储不精确 print(Decimal('1.1')+Decimal('2.2'))#3.3 #布尔值为False情况 bool(False)#False bool(0)#False bool(0.0)#False print('')#False bool(\"\")#False bool([])#False空列表 bool(list())#False空列表 bool(())#False空元组 bool(tuple())#False空元组 bool({})#空字典 bool(dict())#空字典 bool(set())#空集合 \"\"\" 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 \"\"\" 70.2E-12表示[70.2*（10**-12）] type() 函数用来查询变量所指的对象类型。 print(type(a), type(b), type(c), type(d)) &lt;class 'int'> &lt;class 'float'> &lt;class 'bool'> &lt;class 'complex'> type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 常见运算符 算术运算&gt;位运算&gt;比较运算&gt;布尔运算&gt;赋值运算 运算符 描述（由上至下对应优先级由高到低） ** 幂运算 ~ + - 取反、正号、负号 * / % // 乘、除、取模、取整除 + - 加法、减法 &gt;&gt; &lt;&lt; 右移、左移 &amp; 与 ^ | 异或、或 &lt;= &lt; &gt; &gt;= == != 比较运算符(默认从右往左) = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 % 取余 ** 乘方 / 除法 // 整除 %= 比如c%=a相当于c=c%a #注意is比较id的情况 a=1;b=1;print(a is b) #True c=1.0;d=1.0;print(c is d) #True e=\"abc\";f=\"abc\";print(e is f) #True g= (1,2,3);h=(1,2,3);print(g is h);print(f\"{id(g)} {id(h)}\") #元组True i=[1,2,3];j=[1,2,3];print(i is j);print(f\"{id(i)} {id(j)}\") #列表False score1={'张三':100,'李四':98,'王五':45} score2={'张三':100,'李四':98,'王五':45} print(score1 is score2)#字典False m1={100,'李四','王五'} m2={100,'李四','王五'} print(m1 is m2)#集合False String字符串 以单引号 '、双引号&quot;、三引号 ''' 或 &quot;&quot;&quot;括起来的文本 单引号，双引号完全相同。 字符串有两种索引方式，从左往右以0开始，从右往左以-1开始 python字符串格式化符号: 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%‘输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) 字符串截取： 使用三引号(‘’’ 或 “”&quot;)可以指定一个多行字符串。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始，区间左闭右开 Python 中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] a=\"abcdef\" print(a[-1::-1]) #fedcba print(a[:]) #abcdef print(a) #abcdef print(a[0:-1]) # 输出第一个到倒数第二个的所有字符,abcde print(a[0]) # 输出字符串第一个字符，a print(a[2:5]) # 输出从第三个开始到第五个的字符，cde print(a[2:]) # 输出从第三个开始后的所有字符,cdef print(a[:2]) #ab print(a[1:5:2]) # bd print(a * 2) # 输出字符串两次,abcdefabcdef print(a + '你好') # 连接字符串 print(\"this\"\"is\"\"string\") #thisisstring print(a[-2:]) #ef print('{0:.3}'.format(3.1415926))#输出3.14表示一共输出3位数 print('{0:.3f}'.format(3.1415926))#输出3.142输出三位小数 var1[a:b] #如果a>=b, 默认输出为空。 print(var1[3: 3]); print(var1[3: 2]); # \\r后面的内容移到字符串开头，并逐一替换开头部分的字符， m=\"jkloli\\rdj\" print(m[0:])#dj print(m[-1::-1])#倒序打印 字符串增删改查 #字符串的查询操作 s='hello,hello' #index()查询字串第一次出现的位置，若不存在则抛出ValueError print(s.index('lo'))#3 #find()查询字串第一次出现的位置，若不存在则返回-1 print(s.find('lo'))#3 #rindex()查询字串最后一次出现的位置，若不存在则抛出ValueError print(s.rindex('lo'))#9 #rfind()查询字串最后一次出现的位置，若不存在则返回-1 print(s.rfind('lo'))#9 #大小写转换操作 name=\"i love you\" print(name.title())#首字母大写I Love You print(name.upper())#I LOVE YOU print(name.lower())#i love you print(name.capitalize())#I love you name=name.title();print(name.swapcase())#i lOVE yOU #对齐操作 s='i love you' print(s.center(15,'*'))#居中对齐，若第二个参数不指定填充符，默认为空格，指定小于原字符串则返回原字符串,***i love you** print(s.ljust(15,'*'))#左对齐,i love you***** print(s.rjust(15,'*'))#右对齐,*****i love you print(s.zfill(15))#右对齐，左侧用0对齐,00000i love you print('-8910'.zfill(8))#-0008910 #拆分操作 a=\"i got a smoke\" l=a.split() #['i', 'got', 'a', 'smoke'] b=\"i#got#you#all#my#mind\" l2=b.split(\"#\") #['i', 'got', 'you', 'all', 'my', 'mind'] l3=b.split(sep=\"#\",maxsplit=2) #设置最大分割次数，['i', 'got', 'you#all#my#mind'] l4=b.rsplit(sep=\"#\",maxsplit=2) #['i#got#you#all', 'my', 'mind'] #字符串判断相关 s='hello,python' print(s.isidentifier())#False,判断是否是合法的标识符字符串 print('\\t'.isspace())#True,判断是否是全部由空白字符组成（回车、换行、水平制表符） print('abc张三'.isalpha())#True,判断是否全部由字符组成 print('123'.isdecimal())#True,判断是否全部是十进制数字 print('123四Ⅳ'.isnumeric())#True,判断是否全由数字组成 print('abc1'.isalnum())#True,是否全部由字母和数字组成 #合并成一个字符串，join函数 'sep'.join(seq) sep：分隔符。可以为空 seq：要连接的元素列表、字符串、元组、字典 d = {'hello':1,'good':2,'boy':3,'doiido':4} print (':'.join(d)) #boy:good:doiido:hello s = \"hello good boy doiido\" print(':'.join(s)) #h:e:l:l:o: :g:o:o:d: :b:o:y: :d:o:i:i:d:o t=('aa','bb','cc','dd') print(\":\".join(t)) #aa:bb:cc:dd #编码转换 s='海上生明月' #编码 print(s.encode(encoding='GBK'))#在GBK这种编码格式中，一个中文占两个字节 print(s.encode(encoding='UTF-8'))#一个中文占三个字节 #解码 byte=s.encode(encoding='GBK') print(byte.decode(encoding='GBK')) #编码格式和解码格式要相同 字符串驻留机制(不重要) 字符串驻留机制的定义：仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串的驻留池中。python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量。需 前提： 要在控制台进入python(交互模式) 字符串的长度为0或1时 符合标识符（只含有数字、字母、下划线，不能以数字开头，不能以关键字重名）的字符串 字符串只在编译时进行驻留，而非运行时(join函数只在运行时才会输出结果) [-5,256]之间的整数数字 特点: 拼接字符串和修改字符串是会比较影响性能的。(用join方法解决) 强行驻留: >>> b='1abc' >>> import sys >>> a=sys.intern(b) >>> a is b True 对于长字符串使用“==”比较时可能会出现意外的结果，应该使用“is”进行比较。 +++ \\000空 \\a响铃 \\n换行 List列表 有序的可变序列 根据需要动态分配和回收内存 任意数据类型混存 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表创建 l1=[1,2,3,4,5] l2=list([1,2,3,'abc',4,5]) l3=[i*i for i in range(1,10)] 列表截取 list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ] Genshin=[1,2,3] print (list[1:3]) # 从第二个开始输出到第三个元素 print (list * 2) # 输出两次列表 print (list + Genshin) # 连接列表 print(list[-1:-3:-1]) #步长可以为负 a[2:5] = [] # 将对应的元素值设置为空 列表增删改查 # 从第二位开始（包含）截取到倒数第二位（不包含） print (\"list[1:-2]: \", list[1:-2]) # 查询操作 l=['a','b','c','d','a'] print(l.index('a')) #0,index查索引(第一次出现位置) print(l.index('a',0,5)) #0,从第一个元素查到第五个元素 print(l.count('a')) #2，a元素出现两次 #添加操作1 list1 = ['G', 'R', 'T'] list1.append('B') #末尾加B元素 l[len(l):] = [1,2,3] #l末尾加上三个元素 l.extend(list1) #末尾依次加上list1的全部元素 k=['q','w','e','r'] k.insert(1,80) #在第二个元素前插入一个元素 #['q', 80, 'w', 'e', 'r'] squares = [1, 2,3] squares += [4,5,6] print(squares) # [1, 2, 3, 4, 5, 6] b=squares.copy() #相当于b=squares[:] #添加操作2（列表被当成一个元素） l.append(list1) #末尾加元素list1(有括号括起来) #['a', 'b', 'c', 'd', 'a', ['G', 'R', 'T', 'B']] print(l[5][2]) #T k=['q','w','e','r'] k[1]=[1,2] #['q', [1, 2], 'e', 'r'] k.insert(0,[1,2]) #[[1, 2], 'q', [1, 2], 'e', 'r'] a = ['a', 'b', 'c'] n = [1, 2, 3] x = [a, n] print(x) #嵌套成二维数组 [['a', 'b', 'c'], [1, 2, 3]] #删除表中元素 l=[1,['a',2],3,'a'] del l[0] #删除第一个元素 l.remove('a') #删除表内第一个值为'a'的元素 print(l) #[['a', 2], 3] l[:]=[] #列表置空 l.pop() #删除表最后一个元素 l.pop(2) #删除表第三个元素 l.clear() #删除表中所有元素 del l #删除列表对象l #修改操作 l=[1,2,3,4,5] l[1:3]=[8,9,7,6] #覆盖第二个元素到第三个元素，并在后面补上没覆盖的元素 l[0]=0 print(l) #[0, 8, 9, 7, 6, 4, 5] l.sort() #升序排序 l.sort(reverse=True) #降序排序 m=sorted(l) #升序排序 m=sorted(l,reverse=True) #降序排序 l.reverse() #倒排列表中的元素。 #列表比较需要引入 operator 模块的 eq 方法 Tuple元组 有序不可变序列 tuple(iterable)将可迭代系列转换为元组。 元组创建 t = tuple((x for x in range(1,10))) t2=tuple(('a',1,2,3)) t3=(10,) #只包含一个元素的元组要加逗号,不然当成数字 t4=('py',1,2,3) t5=() #空元组 元组操作 #查询 print(len(t)) print(max(t)) #打印元组中的最大值 print(min(t)) #打印元组中的最小值 print(t[0]) #元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组 del tup #元组中元素不能被修改，我们要用重新赋值的方式操作 #与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 len(tuple) 计算元组元素个数。 Set集合 无序不重复数据集合 注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 集合创建 s = {x for x in 'abracadabra' if x not in 'abc'} s1={2, 3, 4, 5, 5, 6, 7, 7}#集合中元素不允许重复 print(s) #{2, 3, 4, 5, 6, 7} s2=set(range(5)) #{0, 1, 2, 3, 4} s3=set([1,2,3,4,5,5,5]) #转为集合,{1, 2, 3, 4, 5} s4=set() #生成空集合 s= {''} #生成集合{''} 集合增删改查 #添加方法 s= set((\"a\",'b','c')) s.add(\"d\") #集合添加一个d s.update((1,2,3)) s.update([1,4],[5,6]) #无序，大概长这样{'b', 1, 2, 3, 4, 5, 6, 'd', 'a', 'c'} #删除方法 s.remove(1) 删除集合中的元素1 s.discard(1) a=s.pop() #随机删除一个元素，数字为0的概率比较高 print(a) #展示被删除的删除元素 s.clear() #清空集合 #查询方法 a=len(s) 集合关系与运算 #集合关系 s1 = {10, 20, 30, 40, 50, 60} s2 = {10, 20, 30, 40} print(s2.issubset(s1))#True，s2是s1的子集 print(s1.issuperset(s2))#True，s1是s2的超集 #两个集合是否含有交集 print(s2.isdisjoint(s1))#False 有交集为False # set可以进行集合运算 a = set('abracadabra') b = set('alacazam') print(a) print(a - b) # a 和 b 的差集，a.difference(b) print(a | b) # a 和 b 的并集，a.union(b) print(a &amp; b) # a 和 b 的交集，a.intersection(b) print(a ^ b) # a 和 b 中不同时存在的元素，a.symmetric_difference(b) Dictionary字典 字典是无序的key-value集合。(python3.6以前) 字典当中的元素是通过键来存取的，而不是通过偏移存取。 键(key)必须使用不可变类型。 在同一个字典中，键(key)必须是唯一的。 print(d[‘one’])不存在抛出异常，print(d.get(“one”))不存在输出None zip函数 zip()函数返回的是一个tuple的迭代器,需要强制转换成list()或dict()对象 names = ['John', 'Amy', 'Jack'] scores = [98, 100, 85] data = list(zip(names, scores)) #元组列表[('John', 98), ('Amy', 100), ('Jack', 85)] data2= dict(zip(names,scores)) #{'John': 98, 'Amy': 100, 'Jack': 85} if __name__=='__main__': dict_one = dict(a=1, b=2, c='jack') dict_two = dict([(1, \"yi\"), (2, \"er\"), ('one', 1)]) for (k1, v1), (k2, v2) in zip(dict_one.items(),dict_two.items()): print(k1, '->', v1) print(k2, '->', v2) a -> 1 1 -> yi b -> 2 2 -> er c -> jack one -> 1 字典创建 d={};d[1]=\"666\";d[2]=\"888\" #先创建空字典对象，再赋值 d1={1:'yi',2:'er',3:'san','one':1} d2=dict(a=1,b=2,c='jack') d3=dict([(1,\"yi\"),(2,\"er\"),('one',1)]) key=[\"ABC\",\"MN\",\"K\"] value=[\"1\",\"2\",\"3\"] d4={k.lower():v for k,v in zip(key,value)} #{'abc': '1', 'mn': '2', 'k': '3'} d5 = {k:len(k) for k in key} #{'ABC': 3, 'MN': 2, 'K': 1} d6={x: x**2 for x in (2, 4, 6)} #{2: 4, 4: 16, 6: 36} 字典增删改查 #查询操作 d={1:'yi',2:'er',3:'san','one':1} print (d['one']) # 输出键为 'one' 的值 print (d[2]) # 输出键为 2 的值 print (d) # 输出完整的字典 print(str(d)) #当成字符串，输出完整字典字典 print (d.keys()) # 输出所有键dict_keys([1, 2, 3, 'one']) print (d.values()) # 输出所有值dict_values(['yi', 'er', 'san', 1]) print(d.items()) #获取所有键值对 #dict_items([(1, 'yi'), (2, 'er'), (3, 'san'), ('one', 1)]) print('one' in d) #True #增加操作 d[\"dj\"]=\"qwe\" #修改操作 d[\"dj\"]=\"rty\" #修改value my_dict = {'a': 4, 'b': 2, 'c': 1, 'd': 3} sorted_dict = dict(sorted(my_dict.items(), key=lambda x: x[1])) ''' 1. 使用items()方法将字典转换为元组列表，元组的第一个元素为键，第二个元素为值。 2. 在sorted()函数中，使用lambda表达式指定排序规则，例如按值从小到大排序：key=lambda x: x[1]。 3. 使用dict()方法将排序后的元组列表转换回字典。 ''' #删除操作 del d[3] # 删除键3 d.clear() # 清空字典 del d # 删除字典 str(d)#输出字典，可以打印的字符串表示。 #不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住 #键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行 浅拷贝与深拷贝 参考:https://github.com/familyld/learnpython/blob/master/Difference_between_DeepCopy_and_ShallowCopy.md 非容器类型（如数字、字符串、和其他’原子’类型的对象）不存在拷贝。 只包含原子类型对象的元组变量不存在拷贝。 ​ 首先，如果我们不进行拷贝，而是直接赋值，很有可能会出现意料之外的结果。比如a是一个列表，b=a，那么修改a的同时，b也会同样被修改，因为Python对象的赋值都是进行引用（内存地址）传递的，实际上a和b指向的都是同一个对象。 ​ 浅拷贝会创建一个新的对象，然后把生成的新对象赋值给新变量，新的对象是指copy创建了一个新的列表对象，而不是列表里的int对象。这样a和b这两个变量指向的列表对象就不是同一个，但和两个列表对象里面的元素依然是按引用传递的，所以a列表中的对象1和b列表中的对象1是同一个。这时只有修改a列表的可变对象，b列表才会受到影响。 >>> a = [1,2,3] >>> import copy >>> b = copy.copy(a) >>> b is a False >>> a[0] is b[0] True >>> a[0] = 4 >>> a [4, 2, 3] >>> b [1, 2, 3] >>> a = [1,2,[3,]] #可变对象[3,] >>> b = copy.copy(a) >>> a is b False >>> a[2].append(4) >>> a [1, 2, [3, 4]] >>> b [1, 2, [3, 4]] ​ 深拷贝不仅重新创建对象，还重新创建对象里的元素。但是对于对象中的不可变元素，深拷贝不会重新生成，变量改动时会自动生成另一个不可变对象，然后改变引用的地址。 >>> a = [1,2,[3,]] >>> b = copy.deepcopy(a) >>> a is b False >>> a[0] is b[0] True >>> a[2] is b[2] False [1, 2, [3]] >>> a = [1,2,[3,]] >>> b = copy.deepcopy(a) >>> a[2].append(4) >>> a [1, 2, [3, 4]] >>> b [1, 2, [3]] generator生成器 在 Python 中，生成器是一种特殊的迭代器，它使用了 yield 语句来实现迭代器的协议，并且可以动态地生成值，避免了一次性生成大量数据所带来的内存消耗。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 # 示例 1：使用生成器函数创建生成器 def my_generator(): yield 1 yield 2 yield 3 # 使用 for 循环遍历生成器 for i in my_generator(): print(i) # 示例 2：使用生成器表达式创建生成器 gen = (x*x for x in range(5)) # 使用 for 循环遍历生成器 for i in gen: print(i) Iterator迭代器 Iterable 可迭代对象：可以直接作用于for循环的对象 Iterator迭代器：可以被next()函数调用并不断返回下一个值的对象。 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数，iter(list1) list=[1,2,3,4] it = iter(list) # 创建迭代器对象 print (next(it)) #1 输出迭代器的下一个元素 print (next(it)) #2 #目录遍历 list=[1,2,3,4] it = iter(list) # 创建迭代器对象 for x in it: print (x, end=\" \") #输出1 2 3 4 #用next()函数 import sys # 引入 sys 模块 list=[1,2,3,4] it = iter(list) # 创建迭代器对象 while True: try: print (next(it)) except StopIteration: sys.exit() #把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。 #在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 #迭代20次终止 class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration #标识迭代的完成 myclass = MyNumbers() myiter = iter(myclass) for x in myiter: print(x) 3. 条件语句和循环语句 if…elif…else… 两种写法如下 score=int(input('请输入一个成绩:')) if score>=90 and score&lt;=100: print('A级') elif score>=80 and score&lt;=89: print('B级') elif score>=70 and score&lt;=79: print('C级') elif score>=60 and score&lt;=69: print('D级') elif score>=0 and score&lt;=59: print('E级') else: print(\"对不起，您的输入有误\") score2=int(input('请输入第二个成绩:')) print('score>score2') if score>score2 else print('score&lt;=score2') range函数创建列表 #range的三种创建方式 r=range(10)#默认从0开始，默认相差1 print(r)#range(0,10)，区间左闭右开 print(list(r))#可用该方法查看range对象中的整数序列 r=range(1,10)#指定了起始值，从1开始不包含10 print(list(r)) r=range(1,10,2)#指定了起始值结束值和步长 print(list(r)) while a=0 sum=0 while a&lt;=100: if not bool(a%2): sum+=a a+=1 print('1-100的偶数和',sum) for-in循环 for item in 'Python': print(item) for i in range(10): print(i) list = ['chinese','english','japanese'] u = 'say:' for i, j in enumerate(list): list[i] = u + j.title() print(list) #输出['say:Chinese', 'say:English', 'say:Japanese'] #循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。 pass 不做任何事情，一般用做占位语句 import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter > n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=\" \") except StopIteration: sys.exit() 4. 函数 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内部定义的变量前面加global可以让该变量变为全局变量 return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 **不可变类型：**变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。 **可变类型：**变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： **不可变类型：**值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。 **可变类型：**引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响 可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了 #py传递不可变对象 def change(a): print(id(a)) # 指向的是同一个对象 a=10 print(id(a)) # 一个新对象 a=1 print(id(a)) change(a) print(id(a)) #输出 3177650651376 3177650651376 3177650651664 3177650651376 #可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。 参数 1. 参数类型 位置参数 ：调用函数时根据函数定义的参数位置来传递参数。 关键字参数：函数调用时通过“键=值”形式传递参数。 缺省参数：也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传入该默认参数的值。 不定长参数：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数（包括不传参）的场景。 注意： ​ 定义函数时，要遵循普通参数，默认参数，第一种不定长参数，第二种不定长参数的顺序。def func(a,b=3,*c,**d) ​ 调用函数时，位置参数必须在关键字参数的前面，普通参数必须赋值。 #!/usr/bin/python3 def printinfo( name, age = 35 ): # 默认参数age=35需要放在普通参数后面，不然会报错 print (\"名字: \", name,end=' ') print (\"年龄: \", age) return #调用函数 printinfo( age=50, name=\"a\" ) #关键字参数 printinfo( name=\"a\" ) #name必须传值 printinfo(\"zhangsan\",25) #位置参数 名字: a 年龄: 50 名字: a 年龄: 35 名字: zhangsan 年龄: 25 #不定长参数 1. 位置传递：以*标记一个形式参数，以元组的形式接受参数，一般命名为args。 2. 关键字传递：以**标记一个形式参数，以字典的形式接受参数，一般命名为kwargs。 def sun(*a, **b): print(a) print(b) sun(1, 2, x=3, y=4) ''' (1, 2) {'x': 3, 'y': 4} ''' # 使用不定长参数传固定值,注意，*a、**b可省略，name不可省略,否则报错 def printinfo( name,age = 35 ,*a,**b, ): #定义函数 # 默认参数age=35需要放在最后，不然会报错 print ( name,end=' ') print ( age) print(a) print(b) return #调用函数 printinfo( \"a\", 50,1,2,3,a=1,b=2 ) #注意顺序 # 如果单独出现星号 *，则星号 * 后的参数必须用关键字传入： def f(a,b,*,c): return a+b+c print(f(1,2,c=3)) def fun(a,b,c): print(a,b,c) lst=[11,22,33] fun(*lst)#11 22 33,在函数调用时，将列表中的每个元素都转换为位置实参传入 dic={'a':111,'b':222,'c':333} #a=111,b=222,c=333 fun(**dic)#111 222 333,在函数调用时，将字典中的键值对都转换为关键字实参传入 2. 匿名函数 Python 使用 lambda 来创建匿名函数。 lambda 传入参数:函数体 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 #!/usr/bin/python3 sum = lambda arg1, arg2: arg1 + arg2 #只能写一行 print ( sum( 10, 20 )) # 30 rs=(lambda x,y:x if x>=y else y)(10,20) print(rs)# 20 我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。 def myfunc(n): return lambda a : a * n mydoubler = myfunc(2) mytripler = myfunc(3) print(mydoubler(11)) # 22 print(mytripler(11)) # 33 5. 面向对象 1. 基础 在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 class Student2(object): \"\"\"docstring for Student\"\"\" def __init__(self, name, score): #构造方法 print(\"调用了构造函数\") self.__name = name #私有属性赋值 self.__score = score def print_score(self): #类的方法必须有self参数 print('%s : %s ' % (self.__name, self.__score)) def get_name(self): return self.__name #外部通过get_name函数访问私有属性 def __del__(self): print(\"调用了析构函数\") bartt = Student2('bart', 59) bartt.print_score() bartt.swecore=89 print(bartt.swecore) print(bartt.get_name()) #Python解释器对外把__name变量改成了_Student__name,所以，仍然可以通过_Student__name来访问__name变量： print(bartt._Student2__name) 2.魔术方法 简单的 __init__ 构造函数 __del__ 析构函数 __dict__ 获取对象属性和方法 __mro__ 查看类的方法的解析顺序(类的调用顺序) call class Student2(object): def __init__(self, name, score): # 构造方法 print(\"调用了构造函数\") self.__name = name # 私有属性赋值 self.__score = score def __call__(self, a, b): print(a, b) c = Student2(1,2) #先创建对象并调用构造函数 c( 3, 4) #使得类实例对象可以像调用普通函数那样使用 调用了构造函数 3 4 str和new __new__ 创建一个新的实例对象的静态方法 至少传入一个参数cls，cls表示要实例化的类 若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行，将没有__init__被调用。 class A(object): def __init__(self, value): print(\"into A __init__\") self.value = value def __new__(cls, *args, **kwargs): print(\"into A __new__\") return object.__new__(cls) # 不知道为啥这里参数只能是cls class B(A): def __init__(self, value): #子类重写父类__init__()方法 print(\"into B __init__\") self.value = value def __new__(cls, *args, **kwargs): print(\"into B __new__\") return super(B, cls).__new__(cls, *args, **kwargs) def __str__(self): # 重写__str__方法，返回值必须是字符串 return str(self.value) if __name__=='__main__': b = B(10) print(b) # 自动调用__str__方法 #结果 into B __new__ into A __new__ into B __init__ 10 class PositiveInteger(int): #自定义一个整数类型 def __new__(cls, value): return super(PositiveInteger, cls).__new__(cls, abs(value)) i = PositiveInteger(-3) print(i) #3 3. 继承，重写 多重继承顺序:https://zhuanlan.zhihu.com/p/268136917 python使用C3 linearization算法搜索 class people: name = \"\" age = 0 __weight = 0 def __init__(self,n,a,w): self.name=n self.age=a self.__weight=w def speak(self): print(\"%s 说：我今年 %d 岁了，体重 %d kg\" % (self.name,self.age,self.__weight)) def get_weight(self): return self.__weight #单继承示例 class student(people): #子类student继承父类people grade='' def __init__(self,n,a,w,g): super(student,self).__init__(n,a,w)#调用父类构造函数 #或者people.__init__(self,n,a,w) 使用这个可能会出现父类__init__多次调用的情况 #或者super().__init__(n,a,w) # 也可以super().__init__(self,n,a,w) self.grade=g def speak(self): #子类重写父类方法 print(\"%s 说：我今年 %d 岁，读 %d 年级，体重 %d kg\" % (self.name, self.age,self.grade, self.get_weight())) class speaker(): topic = '' name = '' def __init__(self, n, t): self.name = n self.topic = t def speak(self): print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\" % (self.name, self.topic)) #多继承 class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__( self,n, a, w, g) super(sample,self).__init__( n, t) test = sample(\"Tim\",25,80,4,\"Python\") print(sample.__mro__) #查看方法的搜索顺序 test.speak() #方法名同，一般调用的是在括号中参数位置排前父类的方法(sample(speaker,student)) #我叫 Tim，我是一个演说家，我演讲的主题是 Python super(student,test).speak()#调用student父类方法 #Tim 说：我今年 25 岁了，体重 80 kg t2=student(test.name,test.age,test.get_weight(),test.grade) t2.speak() #Tim 说：我今年 25 岁，读 4 年级，体重 80 kg print(list(test.__dict__.values())[0:4]) #['Tim', 25, 80, 4] #__dict__属性获取sample类对象test的属性字典 #提取字典的值，转为列表形式，截取前四个参数 t3=student(*list(test.__dict__.values())[0:4]) t3.speak() #Tim 说：我今年 25 岁，读 4 年级，体重 80 kg 4. 抽象类与多态 import abc# abstract base class class Animal(metaclass=abc.ABCMeta): #同一类事物:动物 #或者class Animal(abc.ABC): #metaclass 控制类的创建与行为 @abc.abstractmethod def talk(self): pass class Cat(Animal): #动物的形态之一:猫 def __init__(self,name): self.name=name def talk(self): print(f'{self.name} say miaomiao') class Dog(Animal): #动物的形态之二:狗 def talk(self): print('say wangwang') class Pig(Animal): #动物的形态之三:猪 def talk(self): print('say aoao') # 多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承） if __name__=='__main__': c=Cat(\"power\") c.talk() #结果 power say miaomiao 5. 闭包与装饰器 1.闭包 函数的返回值必须是被包函数对象(函数名) 闭包中必须引用了外层函数作用域内的变量或者形参 def outer(n): def inner(n1): print(n+n1) return inner if __name__=='__main__': jk=outer(11) #此时jk可看作inner jk(22) #33 执行jk()就相当于执行inner() 闭包修改外部函数变量 函数内部想要修改全局变量，使用global关键字 在闭包函数内部，想要修改外部函数的局部变量，需要使用nonlocal关键字 def outer(): num = 10 def inner(): # num = 100 ,这一行的num只是inner里面的num nonlocal num # 声明使用外部变量 num ，不重新定义 num = 100 print(f'调用inner之前：{num}') inner() print(f'调用inner之后：{num}') return inner func = outer() 调用inner之前：10 调用inner之后：100 闭包陷阱 outer 函数返回了一个包含三个闭包（inner 函数）的列表 f_list。每个闭包都捕获了循环变量 i 的引用，而不是在它们被创建时的值。因此，在循环结束后，这些闭包引用的 i 都指向了最终的循环结束值，即 3。 def outer(): f_list = [] for i in range(1, 4): def inner(): return i * i f_list.append(inner) return f_list for fun in outer(): print(fun()) #输出 9 9 9 #解决问题：创建闭包时传递参数来捕获循环变量的值 def inner(x=i): # 使用参数 x 捕获循环变量值 return x * x 2. 装饰器简介 装饰器本质就是一个闭包函数，只不过比较特殊 ​ 1.定义外层函数(要求参数只有一个，类型是函数类型，调用时传参传递的是原函数） ​ 2.定义内层函数，在内层函数中，书写新的功能，并在合适的时机调用原函数 ​ 3.返回内部函数的地址 import time def jkloli(): print(\"我是jkloli\") time.sleep(2) def count_time(func): def inner(): t1 = time.time() func() #引用外部函数的形参func,实际是调用原函数jkloli() print(\"执行时间为：\", time.time() - t1) return inner #返回内层函数地址 if __name__ == '__main__': jk = count_time(jkloli) jk() #jk()相当于inner() 我是jkloli 执行时间为： 2.0066511631011963 3. 装饰器语法糖 def login_check(fn): def inner(): # 书写新的功能，使用print进行模拟 print('登录验证......') # 新的功能书写完成之后，调用原函数 fn() return inner # 装饰器的语法糖格式， @login_check # comment =login_check(comment) def comment(): # 使用print输出模拟评论功能 print('进行评论检查......') if __name__ == '__main__': comment() 登录验证...... 进行评论检查...... 4. 装饰带返回值的原函数 如果原函数有返回值，返回的就是原函数的返回值 如果没有返回的是None def logger(fn): def inner(*args, **kwargs): print(f'{fn.__name__} enter....',end=' ') result = fn(*args, **kwargs) print(f'{fn.__name__} leave....',end=' ') # 函数没有书写返回值，默认返回None return result return inner @logger # func=logger(func) def func(into): return into @logger def my_sum(a, b): return a + b if __name__ == '__main__': print(func('hello')) #func('hello')相当于inner('hello') print(func((3, 6))) print(my_sum(1,3)) # 结果 func enter.... func leave.... hello func enter.... func leave.... (3, 6) my_sum enter.... my_sum leave.... 4 5. 带参数的装饰器 def p(name=None): def outer(fnc): # 捕获传递给它的函数f def inner(j=name): return fnc(j) #注意return return inner return outer @p(name=\"abc\") # 将f函数传给装饰器工厂p,然后被包裹在outer和inner里 def f(name): return name if __name__=='__main__': print(f()) k = p(name=\"abc\")(f) # 手动调用装饰器 print(k()) #结果 abc abc 6. 类装饰器 回到装饰器上的概念上来，装饰器要求接受一个callable对象，并返回一个callable对象（不太严谨）。那么用类来实现也是也可以的。我们可以让类的构造函数__init__()接受一个函数，然后重载__call__()并返回一个函数，也可以达到装饰器函数的效果。 class logging(object): def __init__(self, func): print(\"进入init函数\") self.func = func def __call__(self, *args, **kwargs): print(\"进入call函数\") return self.func(*args, **kwargs) @logging #此时进入init函数 def say(something): print(\"say {}!\".format(something)) say(555) #结果 进入init函数 进入call函数 say 555! 相当于 def say(something): print(\"say {}!\".format(something)) say=logging(say) say(555) 7. 带参数的类装饰器 class logging(object): def __init__(self, a, b): print(\"进入init函数\") self.a = a self.b = b def __call__(self, fnc): print(\"进入call函数\") def speak(*args): print(f\"参数：{self.a} {self.b}\") fnc(*args) return speak @logging(\"come on\", \"daddy\") def say(something): print(\"say {}!\".format(something)) say(888) #结果 进入init函数 进入call函数 参数：come on daddy say 888! 6. 文件操作 1. 文件基本读写 模式 mode字符 意义 'r' 文本读取（默认） 'w' 文本写入，并先清空文件（慎用），文件不存在则创建 'x' 文本写，排它性创建，如果文件已存在则失败 'a' 文本追加，如果文件存在则在末尾追加，不存在则创建 与mode组合字符 意义 'b' 二进制模式，例如：'rb'表示二进制读，不需要encoding 't' 文本模式（默认），例如：rt 一般省略 t '+' 读取与写入，例如：'r+' 表示同时读写 一些读写函数 编号 关键字 使用方法 作用 1 open 文件对象 = open（file，mode，encoding） 打开文件获得指定文件对象 2 read 文件对象.read（num） 文本模式下读取num长度字符，二进制下读取num长度字节，不指定num读取文件全部 3 readline 文件对象.readline（） 读取一行 4 readlines 文件对象.readline（） 读取全部行，得到列表 5 for for line in 文件对象 for循环文件行，一次循环得到一行数据 6 close 文件对象.close（） 关闭文件对象，具有flush的作用 7 with open with open（） as fp 打开文件，不用fp.close()，可以自动关闭 8 flush fp.flush() 当调用flush时，内容才会真正写入文件 9 write fp.write() 直接调用write，内容并未真正写入文件，而是积攒在程序的内存中，称为缓冲区 10 tell fp.tell() 文件指针距离文件开头的字节数 11 seek fp.seek() 详见下面解析 注意文本模式下只允许从文件的开头进行偏移，也只支持 whence=0 seek 移动文件句柄 seek 方法接收两个参数： offset 表示偏移指针的字节数 whence 表示偏移参考，默认为 0 0 表示偏移参考文件的开头，offset 必须是 >=0 的整数 1 表示偏移参考当前位置，offset 可以是负数 2 表示偏移参考文件的结尾，offset 一般是负数 f = open(\"test.txt\", \"rb\") #建议二进制形式打开 f.seek(5,1) #ce.txt用记事本敲入下面内容 i love you baby 123456 78910 #展示读操作 fp=open(\"C:\\\\Users\\\\21609\\\\Desktop\\\\ce.txt\",\"rt\",encoding=\"utf-8\") #创建文件对象fp line=fp.readlines() p=\"\" for i in line: p+=i print(p) ''' i love you baby 123456 78910 ''' print(line) #['i love you\\n', ' baby\\n', '123456\\n', '78910'] fp.close() #展示写操作 with open(r\"C:\\Users\\21609\\Desktop\\ce.txt\",\"a+\",encoding=\"utf-8\") as fp: #r防止转义，创建文件对象fp fp.write(\"\\n原神，启动！\") fp.flush() #刷新一下 print(fp.tell()) #文件指针距离文件开头的字节数 fp.seek(0) #文件指针回到开头 a=fp.read() print(a) ''' 52 i love you baby 123456 78910 原神，启动！ '''","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://eyjafjalla6.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://eyjafjalla6.github.io/tags/python/"}]},{"title":"我的博客","slug":"我的博客","date":"2023-06-24T07:45:33.000Z","updated":"2023-06-24T07:45:33.311Z","comments":true,"path":"2023/06/24/我的博客/","link":"","permalink":"https://eyjafjalla6.github.io/2023/06/24/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-06-24T04:18:42.467Z","updated":"2023-06-24T04:15:00.287Z","comments":true,"path":"2023/06/24/hello-world/","link":"","permalink":"https://eyjafjalla6.github.io/2023/06/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"大一","slug":"大一","permalink":"https://eyjafjalla6.github.io/categories/%E5%A4%A7%E4%B8%80/"},{"name":"计算机语言基础","slug":"计算机语言基础","permalink":"https://eyjafjalla6.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"测试","slug":"测试","permalink":"https://eyjafjalla6.github.io/categories/%E6%B5%8B%E8%AF%95/"},{"name":"大二","slug":"大二","permalink":"https://eyjafjalla6.github.io/categories/%E5%A4%A7%E4%BA%8C/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://eyjafjalla6.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://eyjafjalla6.github.io/tags/python/"}]}